<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="utf-8">
<meta property="og:title" content="dpp::cluster Class Reference - D++ - The lightweight C++ Discord API Library">
<meta property="og:description" content="A lightweight C++ Discord API library supporting the entire Discord API, including Slash Commands, Voice/Audio, Sharding, Clustering and more!">
<meta name="description" content="dpp::cluster Class Reference - D++ - A lightweight C++ Discord API library supporting the entire Discord API, including Slash Commands, Voice/Audio, Sharding, Clustering and more!">
<meta property="og:image" content="https://dpp.dev/DPP-Logo.png">
<meta property="og:url" content="https://dpp.dev/">
<meta property="og:type" content="website">
<meta property="twitter:title" content="dpp::cluster Class Reference - D++ - The lightweight C++ Discord API Library">
<title>dpp::cluster Class Reference - D++ - The lightweight C++ Discord API Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<script>
	setTimeout(function() {
		$("#main-menu").html($("#main-menu").html() + "<li><select name='vsv' onchange='window.location.href=this.options[this.selectedIndex].value'><option value='/'>master</option><option value='/10.0.3/'>10.0.3</option><option value='/10.0.2/'>10.0.2</option><option value='/10.0.1/'>10.0.1</option><option value='/10.0.0/'>10.0.0</option><option value='/9.0.19/'>9.0.19</option><option value='/9.0.18/'>9.0.18</option><option value='/9.0.17/'>9.0.17</option><option value='/9.0.16/'>9.0.16</option><option value='/9.0.15/'>9.0.15</option><option value='/9.0.14/'>9.0.14</option><option selected value='/9.0.13/'>9.0.13</option><option value='/9.0.12/'>9.0.12</option><option value='/9.0.11/'>9.0.11</option><option value='/9.0.10/'>9.0.10</option><option value='/9.0.9/'>9.0.9</option><option value='/9.0.8/'>9.0.8</option><option value='/9.0.7/'>9.0.7</option><option value='/9.0.6/'>9.0.6</option><option value='/9.0.5/'>9.0.5</option><option value='/9.0.4/'>9.0.4</option><option value='/9.0.3/'>9.0.3</option><option value='/9.0.2/'>9.0.2</option><option value='/9.0.1/'>9.0.1</option><option value='/9.0.0/'>9.0.0</option><option value='/1.0.2/'>1.0.2</option><option value='/1.0.1/'>1.0.1</option><option value='/1.0.0/'>1.0.0</option></select></li>");
	}, 500);
</script>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td id="projectlogo"><img alt="Logo" src="DPP-Logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">D++ (DPP)
   </div>
   <div id="projectbrief">A Lightweight C++ library for Discord</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<label for="MSearchField" style="display: none">Search</label>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classdpp_1_1cluster.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classdpp_1_1cluster-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dpp::cluster Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The cluster class represents a group of shards and a command queue for sending and receiving commands from discord via HTTP. You should usually instantiate a cluster object at the very least to make use of the library.  
 <a href="classdpp_1_1cluster.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for dpp::cluster:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classdpp_1_1cluster__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac40e45e1ff8efb4e9ae75a7ecacc786"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aac40e45e1ff8efb4e9ae75a7ecacc786">cluster</a> (const std::string &amp;<a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a>, uint32_t <a class="el" href="namespacedpp.html#a0042c0fc8164da4239b977d5be8e2ef5">intents</a>=<a class="el" href="namespacedpp.html#a0042c0fc8164da4239b977d5be8e2ef5a561a52b3c6883808735c41891351c68f">i_default_intents</a>, uint32_t shards=0, uint32_t <a class="el" href="classdpp_1_1cluster.html#a5155862c1d7267c7f4ee8781ff3e8d7f">cluster_id</a>=0, uint32_t <a class="el" href="classdpp_1_1cluster.html#ad80e4df300e69988d163d61c14e540ab">maxclusters</a>=1, bool compressed=true, <a class="el" href="structdpp_1_1cache__policy__t.html">cache_policy_t</a> policy={<a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>, <a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>, <a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>})</td></tr>
<tr class="memdesc:aac40e45e1ff8efb4e9ae75a7ecacc786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating a cluster. All but the token are optional.  <a href="classdpp_1_1cluster.html#aac40e45e1ff8efb4e9ae75a7ecacc786">More...</a><br /></td></tr>
<tr class="separator:aac40e45e1ff8efb4e9ae75a7ecacc786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0b523f89559b4ce204ca9ed9693d79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6b0b523f89559b4ce204ca9ed9693d79">cluster</a> (const <a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6b0b523f89559b4ce204ca9ed9693d79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdpp_1_1cluster.html" title="The cluster class represents a group of shards and a command queue for sending and receiving commands...">dpp::cluster</a> is non-copyable  <a href="classdpp_1_1cluster.html#a6b0b523f89559b4ce204ca9ed9693d79">More...</a><br /></td></tr>
<tr class="separator:a6b0b523f89559b4ce204ca9ed9693d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d957f52245734f6d44444af8380c952"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2d957f52245734f6d44444af8380c952">cluster</a> (const <a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a2d957f52245734f6d44444af8380c952"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdpp_1_1cluster.html" title="The cluster class represents a group of shards and a command queue for sending and receiving commands...">dpp::cluster</a> is non-moveable  <a href="classdpp_1_1cluster.html#a2d957f52245734f6d44444af8380c952">More...</a><br /></td></tr>
<tr class="separator:a2d957f52245734f6d44444af8380c952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270be0ab59aff4f335ef3f4af7559d92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a270be0ab59aff4f335ef3f4af7559d92">~cluster</a> ()</td></tr>
<tr class="memdesc:a270be0ab59aff4f335ef3f4af7559d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the cluster object.  <a href="classdpp_1_1cluster.html#a270be0ab59aff4f335ef3f4af7559d92">More...</a><br /></td></tr>
<tr class="separator:a270be0ab59aff4f335ef3f4af7559d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056e4191c03dd210c2a410b6599a0bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a056e4191c03dd210c2a410b6599a0bf9">set_websocket_protocol</a> (<a class="el" href="namespacedpp.html#af7cde3079d745428f44ef6231a2ac672">websocket_protocol_t</a> mode)</td></tr>
<tr class="memdesc:a056e4191c03dd210c2a410b6599a0bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the websocket protocol for all shards on this cluster. You should call this method before <a class="el" href="classdpp_1_1cluster.html#a40e99d13e1380eccd30d13123014594f" title="Start the cluster, connecting all its shards. Returns once all shards are connected.">cluster::start</a>. Generally ws_etf is faster, but provides less facilities for debugging should something go wrong. It is recommended to use ETF in production and JSON in development.  <a href="classdpp_1_1cluster.html#a056e4191c03dd210c2a410b6599a0bf9">More...</a><br /></td></tr>
<tr class="separator:a056e4191c03dd210c2a410b6599a0bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcc02c388c197cf7050551ef89aeefe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe">set_audit_reason</a> (const std::string &amp;reason)</td></tr>
<tr class="memdesc:adbcc02c388c197cf7050551ef89aeefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the audit log reason for the next REST call to be made. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically.  <a href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe">More...</a><br /></td></tr>
<tr class="separator:adbcc02c388c197cf7050551ef89aeefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e3f0868ece15373e81844dff719aa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af1e3f0868ece15373e81844dff719aa0">clear_audit_reason</a> ()</td></tr>
<tr class="memdesc:af1e3f0868ece15373e81844dff719aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the audit log reason for the next REST call to be made. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically.  <a href="classdpp_1_1cluster.html#af1e3f0868ece15373e81844dff719aa0">More...</a><br /></td></tr>
<tr class="separator:af1e3f0868ece15373e81844dff719aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a2958625740b4a6fde6643042c5f7e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab7a2958625740b4a6fde6643042c5f7e">get_audit_reason</a> ()</td></tr>
<tr class="memdesc:ab7a2958625740b4a6fde6643042c5f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the audit reason set for the next REST call to be made on this thread. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically.  <a href="classdpp_1_1cluster.html#ab7a2958625740b4a6fde6643042c5f7e">More...</a><br /></td></tr>
<tr class="separator:ab7a2958625740b4a6fde6643042c5f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13689440c9cc80279d415c563a6363c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a13689440c9cc80279d415c563a6363c0">log</a> (<a class="el" href="namespacedpp.html#a7d48d478ccc3bffb34637bdb48f629c2">dpp::loglevel</a> severity, const std::string &amp;msg) const</td></tr>
<tr class="memdesc:a13689440c9cc80279d415c563a6363c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log a message to whatever log the user is using. The logged message is passed up the chain to the on_log event in user code which can then do whatever it wants to do with it.  <a href="classdpp_1_1cluster.html#a13689440c9cc80279d415c563a6363c0">More...</a><br /></td></tr>
<tr class="separator:a13689440c9cc80279d415c563a6363c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6164d5543b7594731a980da9b0b2088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae6164d5543b7594731a980da9b0b2088">get_dm_channel</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id)</td></tr>
<tr class="memdesc:ae6164d5543b7594731a980da9b0b2088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dm channel for a user id.  <a href="classdpp_1_1cluster.html#ae6164d5543b7594731a980da9b0b2088">More...</a><br /></td></tr>
<tr class="separator:ae6164d5543b7594731a980da9b0b2088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc501cc0ebb334d09a7f4bb1ea6b3e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3fc501cc0ebb334d09a7f4bb1ea6b3e6">set_dm_channel</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id)</td></tr>
<tr class="memdesc:a3fc501cc0ebb334d09a7f4bb1ea6b3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dm channel id for a user id.  <a href="classdpp_1_1cluster.html#a3fc501cc0ebb334d09a7f4bb1ea6b3e6">More...</a><br /></td></tr>
<tr class="separator:a3fc501cc0ebb334d09a7f4bb1ea6b3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12b5b33ea156bde9977796858066a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdpp_1_1utility_1_1uptime.html">dpp::utility::uptime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af12b5b33ea156bde9977796858066a6b">uptime</a> ()</td></tr>
<tr class="memdesc:af12b5b33ea156bde9977796858066a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uptime of the cluster.  <a href="classdpp_1_1cluster.html#af12b5b33ea156bde9977796858066a6b">More...</a><br /></td></tr>
<tr class="separator:af12b5b33ea156bde9977796858066a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e99d13e1380eccd30d13123014594f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a40e99d13e1380eccd30d13123014594f">start</a> (bool return_after=true)</td></tr>
<tr class="memdesc:a40e99d13e1380eccd30d13123014594f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the cluster, connecting all its shards. Returns once all shards are connected.  <a href="classdpp_1_1cluster.html#a40e99d13e1380eccd30d13123014594f">More...</a><br /></td></tr>
<tr class="separator:a40e99d13e1380eccd30d13123014594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b67c9455ac0378712e4c0fd0ba7f2a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9b67c9455ac0378712e4c0fd0ba7f2a9">set_presence</a> (const class <a class="el" href="classdpp_1_1presence.html">dpp::presence</a> &amp;p)</td></tr>
<tr class="memdesc:a9b67c9455ac0378712e4c0fd0ba7f2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the presence for all shards on the cluster.  <a href="classdpp_1_1cluster.html#a9b67c9455ac0378712e4c0fd0ba7f2a9">More...</a><br /></td></tr>
<tr class="separator:a9b67c9455ac0378712e4c0fd0ba7f2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c677c0d5c059e87cc01ce598d49487d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1discord__client.html">discord_client</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5c677c0d5c059e87cc01ce598d49487d">get_shard</a> (uint32_t id)</td></tr>
<tr class="memdesc:a5c677c0d5c059e87cc01ce598d49487d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shard by id, returning the <a class="el" href="classdpp_1_1discord__client.html" title="Implements a discord client. Each discord_client connects to one shard and derives from a websocket c...">discord_client</a>.  <a href="classdpp_1_1cluster.html#a5c677c0d5c059e87cc01ce598d49487d">More...</a><br /></td></tr>
<tr class="separator:a5c677c0d5c059e87cc01ce598d49487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d6195862e6d25c644902631a0b34d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedpp.html#a13c4d4e6238396245b349e6a637897e0">shard_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af4d6195862e6d25c644902631a0b34d1">get_shards</a> ()</td></tr>
<tr class="memdesc:af4d6195862e6d25c644902631a0b34d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of shards.  <a href="classdpp_1_1cluster.html#af4d6195862e6d25c644902631a0b34d1">More...</a><br /></td></tr>
<tr class="separator:af4d6195862e6d25c644902631a0b34d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130b16feb7cb7f79a30401e95888109d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a130b16feb7cb7f79a30401e95888109d">on_voice_state_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1voice__state__update__t.html">voice_state_update_t</a> &amp;_event)&gt; _voice_state_update)</td></tr>
<tr class="memdesc:a130b16feb7cb7f79a30401e95888109d"><td class="mdescLeft">&#160;</td><td class="mdescRight">on voice state update event  <a href="classdpp_1_1cluster.html#a130b16feb7cb7f79a30401e95888109d">More...</a><br /></td></tr>
<tr class="separator:a130b16feb7cb7f79a30401e95888109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa959ff17934bc9f044abf70c20ce5dd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa959ff17934bc9f044abf70c20ce5dd7">detach_voice_state_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _voice_state_update)</td></tr>
<tr class="memdesc:aa959ff17934bc9f044abf70c20ce5dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_voice_state_update event.  <a href="classdpp_1_1cluster.html#aa959ff17934bc9f044abf70c20ce5dd7">More...</a><br /></td></tr>
<tr class="separator:aa959ff17934bc9f044abf70c20ce5dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f6e8daa30e7ed1ebb9f9547ef89206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab6f6e8daa30e7ed1ebb9f9547ef89206">on_voice_client_disconnect</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1voice__client__disconnect__t.html">voice_client_disconnect_t</a> &amp;_event)&gt; _voice_client_disconnect)</td></tr>
<tr class="memdesc:ab6f6e8daa30e7ed1ebb9f9547ef89206"><td class="mdescLeft">&#160;</td><td class="mdescRight">on voice client disconnect event  <a href="classdpp_1_1cluster.html#ab6f6e8daa30e7ed1ebb9f9547ef89206">More...</a><br /></td></tr>
<tr class="separator:ab6f6e8daa30e7ed1ebb9f9547ef89206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6b912887c0a0ed75be521b39934611"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8d6b912887c0a0ed75be521b39934611">detach_voice_client_disconnect</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _voice_client_disconnect)</td></tr>
<tr class="memdesc:a8d6b912887c0a0ed75be521b39934611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_voice_client_disconnect event.  <a href="classdpp_1_1cluster.html#a8d6b912887c0a0ed75be521b39934611">More...</a><br /></td></tr>
<tr class="separator:a8d6b912887c0a0ed75be521b39934611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818e39c9b8ada848f03cd873a1eaf424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a818e39c9b8ada848f03cd873a1eaf424">on_voice_client_speaking</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1voice__client__speaking__t.html">voice_client_speaking_t</a> &amp;_event)&gt; _voice_client_speaking)</td></tr>
<tr class="memdesc:a818e39c9b8ada848f03cd873a1eaf424"><td class="mdescLeft">&#160;</td><td class="mdescRight">on voice client speaking event  <a href="classdpp_1_1cluster.html#a818e39c9b8ada848f03cd873a1eaf424">More...</a><br /></td></tr>
<tr class="separator:a818e39c9b8ada848f03cd873a1eaf424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2cf7f141061299f9226c5d16de7016"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1c2cf7f141061299f9226c5d16de7016">detach_voice_client_speaking</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _voice_client_speaking)</td></tr>
<tr class="memdesc:a1c2cf7f141061299f9226c5d16de7016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_voice_client_speaking event.  <a href="classdpp_1_1cluster.html#a1c2cf7f141061299f9226c5d16de7016">More...</a><br /></td></tr>
<tr class="separator:a1c2cf7f141061299f9226c5d16de7016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbab2120fd480aeaca4d76802708320e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#adbab2120fd480aeaca4d76802708320e">on_log</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1log__t.html">log_t</a> &amp;_event)&gt; _log)</td></tr>
<tr class="memdesc:adbab2120fd480aeaca4d76802708320e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a log message is to be written to the log. You can attach any logging system here you wish, e.g. spdlog, or even just a simple use of std::cout or printf. If nothing attaches this log event, then the library will be silent.  <a href="classdpp_1_1cluster.html#adbab2120fd480aeaca4d76802708320e">More...</a><br /></td></tr>
<tr class="separator:adbab2120fd480aeaca4d76802708320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df9a1442cc4748228b5349bd1286ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a02df9a1442cc4748228b5349bd1286ad">detach_log</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _log)</td></tr>
<tr class="memdesc:a02df9a1442cc4748228b5349bd1286ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_log event.  <a href="classdpp_1_1cluster.html#a02df9a1442cc4748228b5349bd1286ad">More...</a><br /></td></tr>
<tr class="separator:a02df9a1442cc4748228b5349bd1286ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71993919fb741b379465c28e353c0b10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a71993919fb741b379465c28e353c0b10">on_guild_join_request_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__join__request__delete__t.html">guild_join_request_delete_t</a> &amp;_event)&gt; _guild_join_request_delete)</td></tr>
<tr class="memdesc:a71993919fb741b379465c28e353c0b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">on guild join request delete. Triggered when a user declines the membership screening questionnaire for a guild.  <a href="classdpp_1_1cluster.html#a71993919fb741b379465c28e353c0b10">More...</a><br /></td></tr>
<tr class="separator:a71993919fb741b379465c28e353c0b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40727e8a623206fd029688b61e5589f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa40727e8a623206fd029688b61e5589f">detach_guild_join_request_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_join_request_delete)</td></tr>
<tr class="memdesc:aa40727e8a623206fd029688b61e5589f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_join_request_delete event.  <a href="classdpp_1_1cluster.html#aa40727e8a623206fd029688b61e5589f">More...</a><br /></td></tr>
<tr class="separator:aa40727e8a623206fd029688b61e5589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3287881d5f1aba46a7013c695b69a591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3287881d5f1aba46a7013c695b69a591">on_interaction_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1interaction__create__t.html">interaction_create_t</a> &amp;_event)&gt; _interaction_create)</td></tr>
<tr class="memdesc:a3287881d5f1aba46a7013c695b69a591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new interaction is created. Interactions are created by discord when commands you have registered are issued by a user. For an example of this in action please see <a class="el" href="slashcommands.html">Using Slash Commands and Interactions</a>.  <a href="classdpp_1_1cluster.html#a3287881d5f1aba46a7013c695b69a591">More...</a><br /></td></tr>
<tr class="separator:a3287881d5f1aba46a7013c695b69a591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa6c9506b2f5688453f048d31358e86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1fa6c9506b2f5688453f048d31358e86">detach_interaction_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _interaction_create)</td></tr>
<tr class="memdesc:a1fa6c9506b2f5688453f048d31358e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_interaction_create event.  <a href="classdpp_1_1cluster.html#a1fa6c9506b2f5688453f048d31358e86">More...</a><br /></td></tr>
<tr class="separator:a1fa6c9506b2f5688453f048d31358e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad657d4be274b38e641db9bab63e8a420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad657d4be274b38e641db9bab63e8a420">on_button_click</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1button__click__t.html">button_click_t</a> &amp;_event)&gt; _button_click)</td></tr>
<tr class="memdesc:ad657d4be274b38e641db9bab63e8a420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a button is clicked attached to a message. Button clicks are triggered by discord when buttons are clicked which you have associated with a message using <a class="el" href="classdpp_1_1component.html" title="Represents the component object. A component is a clickable button or drop down list within a discord...">dpp::component</a>.  <a href="classdpp_1_1cluster.html#ad657d4be274b38e641db9bab63e8a420">More...</a><br /></td></tr>
<tr class="separator:ad657d4be274b38e641db9bab63e8a420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af063fbe8c46e362c4e18cad517f743f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af063fbe8c46e362c4e18cad517f743f8">detach_button_click</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _button_click)</td></tr>
<tr class="memdesc:af063fbe8c46e362c4e18cad517f743f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_button_click event.  <a href="classdpp_1_1cluster.html#af063fbe8c46e362c4e18cad517f743f8">More...</a><br /></td></tr>
<tr class="separator:af063fbe8c46e362c4e18cad517f743f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3477074ee2798aecb28542ee5afc36f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3477074ee2798aecb28542ee5afc36f3">on_autocomplete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1autocomplete__t.html">autocomplete_t</a> &amp;_event)&gt; _autocomplete)</td></tr>
<tr class="memdesc:a3477074ee2798aecb28542ee5afc36f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an auto completed field needs suggestions to present to the user This is triggered by discord when option choices have auto completion enabled which you have associated with a <a class="el" href="classdpp_1_1slashcommand.html" title="Represents an application command, created by your bot either globally, or on a guild.">dpp::slashcommand</a>.  <a href="classdpp_1_1cluster.html#a3477074ee2798aecb28542ee5afc36f3">More...</a><br /></td></tr>
<tr class="separator:a3477074ee2798aecb28542ee5afc36f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886b16b2329d74ea1003507628d35b96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a886b16b2329d74ea1003507628d35b96">detach_autocomplete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _autocomplete)</td></tr>
<tr class="memdesc:a886b16b2329d74ea1003507628d35b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_autocomplete event.  <a href="classdpp_1_1cluster.html#a886b16b2329d74ea1003507628d35b96">More...</a><br /></td></tr>
<tr class="separator:a886b16b2329d74ea1003507628d35b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca854b9de47fc5eae411d072f6acff4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2ca854b9de47fc5eae411d072f6acff4">on_select_click</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1select__click__t.html">select_click_t</a> &amp;_event)&gt; _select_click)</td></tr>
<tr class="memdesc:a2ca854b9de47fc5eae411d072f6acff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a select menu is clicked attached to a message. Select menu clicks are triggered by discord when select menus are clicked which you have associated with a message using <a class="el" href="classdpp_1_1component.html" title="Represents the component object. A component is a clickable button or drop down list within a discord...">dpp::component</a>.  <a href="classdpp_1_1cluster.html#a2ca854b9de47fc5eae411d072f6acff4">More...</a><br /></td></tr>
<tr class="separator:a2ca854b9de47fc5eae411d072f6acff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74bca8b1d4dc3f6a2d27d53e7d3509a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae74bca8b1d4dc3f6a2d27d53e7d3509a">detach_select_click</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _select_click)</td></tr>
<tr class="memdesc:ae74bca8b1d4dc3f6a2d27d53e7d3509a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_select_click event.  <a href="classdpp_1_1cluster.html#ae74bca8b1d4dc3f6a2d27d53e7d3509a">More...</a><br /></td></tr>
<tr class="separator:ae74bca8b1d4dc3f6a2d27d53e7d3509a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd66b3f7268c8f7a6f7fb937bfd45d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#abdd66b3f7268c8f7a6f7fb937bfd45d9">on_guild_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__delete__t.html">guild_delete_t</a> &amp;_event)&gt; _guild_delete)</td></tr>
<tr class="memdesc:abdd66b3f7268c8f7a6f7fb937bfd45d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a guild is deleted. A guild can be deleted via the bot being kicked, the bot leaving the guild explicitly with dpp::guild_delete, or via the guild being unavaialble due to an outage.  <a href="classdpp_1_1cluster.html#abdd66b3f7268c8f7a6f7fb937bfd45d9">More...</a><br /></td></tr>
<tr class="separator:abdd66b3f7268c8f7a6f7fb937bfd45d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca51095bfb14b99a303405fb62677dd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aca51095bfb14b99a303405fb62677dd7">detach_guild_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_delete)</td></tr>
<tr class="memdesc:aca51095bfb14b99a303405fb62677dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_delete event.  <a href="classdpp_1_1cluster.html#aca51095bfb14b99a303405fb62677dd7">More...</a><br /></td></tr>
<tr class="separator:aca51095bfb14b99a303405fb62677dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d42302de6b917c75a7174c7e11f6e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad7d42302de6b917c75a7174c7e11f6e9">on_channel_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1channel__delete__t.html">channel_delete_t</a> &amp;_event)&gt; _channel_delete)</td></tr>
<tr class="memdesc:ad7d42302de6b917c75a7174c7e11f6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a channel is deleted from a guild. The channel will still be temporarily avaialble in the cache. Pointers to the channel should not be retained long-term as they will be deleted by the garbage collector.  <a href="classdpp_1_1cluster.html#ad7d42302de6b917c75a7174c7e11f6e9">More...</a><br /></td></tr>
<tr class="separator:ad7d42302de6b917c75a7174c7e11f6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5cc859e68b5933ecf4069fc89a46b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7e5cc859e68b5933ecf4069fc89a46b1">detach_channel_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _channel_delete)</td></tr>
<tr class="memdesc:a7e5cc859e68b5933ecf4069fc89a46b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_channel_delete event.  <a href="classdpp_1_1cluster.html#a7e5cc859e68b5933ecf4069fc89a46b1">More...</a><br /></td></tr>
<tr class="separator:a7e5cc859e68b5933ecf4069fc89a46b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac318487605dd012335dd3787115f1ec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac318487605dd012335dd3787115f1ec2">on_channel_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1channel__update__t.html">channel_update_t</a> &amp;_event)&gt; _channel_update)</td></tr>
<tr class="memdesc:ac318487605dd012335dd3787115f1ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a channel is edited on a guild. The new channel details have already been applied to the guild when you receive this event.  <a href="classdpp_1_1cluster.html#ac318487605dd012335dd3787115f1ec2">More...</a><br /></td></tr>
<tr class="separator:ac318487605dd012335dd3787115f1ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27f3c53bcf391580003b2bf5eea2c17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af27f3c53bcf391580003b2bf5eea2c17">detach_channel_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _channel_update)</td></tr>
<tr class="memdesc:af27f3c53bcf391580003b2bf5eea2c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_channel_update event.  <a href="classdpp_1_1cluster.html#af27f3c53bcf391580003b2bf5eea2c17">More...</a><br /></td></tr>
<tr class="separator:af27f3c53bcf391580003b2bf5eea2c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598c59a3848bf30d82938fdd7f5813a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a598c59a3848bf30d82938fdd7f5813a3">on_ready</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1ready__t.html">ready_t</a> &amp;_event)&gt; _ready)</td></tr>
<tr class="memdesc:a598c59a3848bf30d82938fdd7f5813a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a shard is connected and ready. A set of on_guild_create events will follow this event.  <a href="classdpp_1_1cluster.html#a598c59a3848bf30d82938fdd7f5813a3">More...</a><br /></td></tr>
<tr class="separator:a598c59a3848bf30d82938fdd7f5813a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062bc58abb7ddc45c6e545a0792b5665"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a062bc58abb7ddc45c6e545a0792b5665">detach_ready</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _ready)</td></tr>
<tr class="memdesc:a062bc58abb7ddc45c6e545a0792b5665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_ready event.  <a href="classdpp_1_1cluster.html#a062bc58abb7ddc45c6e545a0792b5665">More...</a><br /></td></tr>
<tr class="separator:a062bc58abb7ddc45c6e545a0792b5665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874df5eb51a2ab5ce006687b449207ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a874df5eb51a2ab5ce006687b449207ec">on_message_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1message__delete__t.html">message_delete_t</a> &amp;_event)&gt; _message_delete)</td></tr>
<tr class="memdesc:a874df5eb51a2ab5ce006687b449207ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a message is deleted. The message has already been deleted from Discord when you receive this event.  <a href="classdpp_1_1cluster.html#a874df5eb51a2ab5ce006687b449207ec">More...</a><br /></td></tr>
<tr class="separator:a874df5eb51a2ab5ce006687b449207ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f052123a147c6713b736a2ef8b5b24f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6f052123a147c6713b736a2ef8b5b24f">detach_message_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _message_delete)</td></tr>
<tr class="memdesc:a6f052123a147c6713b736a2ef8b5b24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_message_delete event.  <a href="classdpp_1_1cluster.html#a6f052123a147c6713b736a2ef8b5b24f">More...</a><br /></td></tr>
<tr class="separator:a6f052123a147c6713b736a2ef8b5b24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f244bc712531ce761c51fdcc61d96a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0f244bc712531ce761c51fdcc61d96a2">on_application_command_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1application__command__delete__t.html">application_command_delete_t</a> &amp;_event)&gt; _application_command_delete)</td></tr>
<tr class="memdesc:a0f244bc712531ce761c51fdcc61d96a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an application command (slash command) is deleted.  <a href="classdpp_1_1cluster.html#a0f244bc712531ce761c51fdcc61d96a2">More...</a><br /></td></tr>
<tr class="separator:a0f244bc712531ce761c51fdcc61d96a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac82a31ffbc97b156cbbc48bf57326e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#adac82a31ffbc97b156cbbc48bf57326e">detach_application_command_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _application_command_delete)</td></tr>
<tr class="memdesc:adac82a31ffbc97b156cbbc48bf57326e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_application_command_delete event.  <a href="classdpp_1_1cluster.html#adac82a31ffbc97b156cbbc48bf57326e">More...</a><br /></td></tr>
<tr class="separator:adac82a31ffbc97b156cbbc48bf57326e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4343a2d7352d93ba62405c82606df307"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4343a2d7352d93ba62405c82606df307">on_guild_member_remove</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__member__remove__t.html">guild_member_remove_t</a> &amp;_event)&gt; _guild_member_remove)</td></tr>
<tr class="memdesc:a4343a2d7352d93ba62405c82606df307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user leaves a guild (either through being kicked, or choosing to leave)  <a href="classdpp_1_1cluster.html#a4343a2d7352d93ba62405c82606df307">More...</a><br /></td></tr>
<tr class="separator:a4343a2d7352d93ba62405c82606df307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6f3b5f210ea0d6b183005b51d0a9fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6b6f3b5f210ea0d6b183005b51d0a9fd">detach_guild_member_remove</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_member_remove)</td></tr>
<tr class="memdesc:a6b6f3b5f210ea0d6b183005b51d0a9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_member_remove event.  <a href="classdpp_1_1cluster.html#a6b6f3b5f210ea0d6b183005b51d0a9fd">More...</a><br /></td></tr>
<tr class="separator:a6b6f3b5f210ea0d6b183005b51d0a9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4c89e99887415ff9309d704f2899ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5e4c89e99887415ff9309d704f2899ac">on_application_command_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1application__command__create__t.html">application_command_create_t</a> &amp;_event)&gt; _application_command_create)</td></tr>
<tr class="memdesc:a5e4c89e99887415ff9309d704f2899ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new application command (slash command) is registered.  <a href="classdpp_1_1cluster.html#a5e4c89e99887415ff9309d704f2899ac">More...</a><br /></td></tr>
<tr class="separator:a5e4c89e99887415ff9309d704f2899ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fa8b2df61d6f2c2f8267525dcd7ace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a48fa8b2df61d6f2c2f8267525dcd7ace">detach_application_command_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _application_command_create)</td></tr>
<tr class="memdesc:a48fa8b2df61d6f2c2f8267525dcd7ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_application_command_create event.  <a href="classdpp_1_1cluster.html#a48fa8b2df61d6f2c2f8267525dcd7ace">More...</a><br /></td></tr>
<tr class="separator:a48fa8b2df61d6f2c2f8267525dcd7ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92176f33b0b70ddfb3a57ce35847692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac92176f33b0b70ddfb3a57ce35847692">on_resumed</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1resumed__t.html">resumed_t</a> &amp;_event)&gt; _resumed)</td></tr>
<tr class="memdesc:ac92176f33b0b70ddfb3a57ce35847692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a connection to a shard successfully resumes. A resumed session does not need to re-synchronise guilds, members, etc. This is generally non-fatal and informational only.  <a href="classdpp_1_1cluster.html#ac92176f33b0b70ddfb3a57ce35847692">More...</a><br /></td></tr>
<tr class="separator:ac92176f33b0b70ddfb3a57ce35847692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf616451ceb2605d472997c17cabdfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7cf616451ceb2605d472997c17cabdfc">detach_resumed</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _resumed)</td></tr>
<tr class="memdesc:a7cf616451ceb2605d472997c17cabdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_resumed event.  <a href="classdpp_1_1cluster.html#a7cf616451ceb2605d472997c17cabdfc">More...</a><br /></td></tr>
<tr class="separator:a7cf616451ceb2605d472997c17cabdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3449a9c5305ed837cd345d9cfe27692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab3449a9c5305ed837cd345d9cfe27692">on_guild_role_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__role__create__t.html">guild_role_create_t</a> &amp;_event)&gt; _guild_role_create)</td></tr>
<tr class="memdesc:ab3449a9c5305ed837cd345d9cfe27692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new role is created on a guild.  <a href="classdpp_1_1cluster.html#ab3449a9c5305ed837cd345d9cfe27692">More...</a><br /></td></tr>
<tr class="separator:ab3449a9c5305ed837cd345d9cfe27692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf56d37e5d0634545687d74947366d3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#acf56d37e5d0634545687d74947366d3e">detach_guild_role_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_role_create)</td></tr>
<tr class="memdesc:acf56d37e5d0634545687d74947366d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_role_create event.  <a href="classdpp_1_1cluster.html#acf56d37e5d0634545687d74947366d3e">More...</a><br /></td></tr>
<tr class="separator:acf56d37e5d0634545687d74947366d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2981966cc8349aed024d9f8aaf5882e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2981966cc8349aed024d9f8aaf5882e8">on_typing_start</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1typing__start__t.html">typing_start_t</a> &amp;_event)&gt; _typing_start)</td></tr>
<tr class="memdesc:a2981966cc8349aed024d9f8aaf5882e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user is typing on a channel.  <a href="classdpp_1_1cluster.html#a2981966cc8349aed024d9f8aaf5882e8">More...</a><br /></td></tr>
<tr class="separator:a2981966cc8349aed024d9f8aaf5882e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5639b37b839c21b8a7ae4716e72d2b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa5639b37b839c21b8a7ae4716e72d2b7">detach_typing_start</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _typing_start)</td></tr>
<tr class="memdesc:aa5639b37b839c21b8a7ae4716e72d2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_typing_start event.  <a href="classdpp_1_1cluster.html#aa5639b37b839c21b8a7ae4716e72d2b7">More...</a><br /></td></tr>
<tr class="separator:aa5639b37b839c21b8a7ae4716e72d2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b998c5d26840d75933c7c48613c2abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2b998c5d26840d75933c7c48613c2abe">on_message_reaction_add</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__add__t.html">message_reaction_add_t</a> &amp;_event)&gt; _message_reaction_add)</td></tr>
<tr class="memdesc:a2b998c5d26840d75933c7c48613c2abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new reaction is added to a message.  <a href="classdpp_1_1cluster.html#a2b998c5d26840d75933c7c48613c2abe">More...</a><br /></td></tr>
<tr class="separator:a2b998c5d26840d75933c7c48613c2abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe425bc201ab9d3058fd8cf7ef3287f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#afe425bc201ab9d3058fd8cf7ef3287f0">detach_message_reaction_add</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _message_reaction_add)</td></tr>
<tr class="memdesc:afe425bc201ab9d3058fd8cf7ef3287f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_message_reaction_add event.  <a href="classdpp_1_1cluster.html#afe425bc201ab9d3058fd8cf7ef3287f0">More...</a><br /></td></tr>
<tr class="separator:afe425bc201ab9d3058fd8cf7ef3287f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fffc28979d1ecb8c7d653501e31d04c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8fffc28979d1ecb8c7d653501e31d04c">on_guild_members_chunk</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__members__chunk__t.html">guild_members_chunk_t</a> &amp;_event)&gt; _guild_members_chunk)</td></tr>
<tr class="memdesc:a8fffc28979d1ecb8c7d653501e31d04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a set of members is received for a guild. D++ will request these for all new guilds if needed, after the on_guild_create events.  <a href="classdpp_1_1cluster.html#a8fffc28979d1ecb8c7d653501e31d04c">More...</a><br /></td></tr>
<tr class="separator:a8fffc28979d1ecb8c7d653501e31d04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8979f9fe0fb3aa5ee9a475832f30607"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab8979f9fe0fb3aa5ee9a475832f30607">detach_guild_members_chunk</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_members_chunk)</td></tr>
<tr class="memdesc:ab8979f9fe0fb3aa5ee9a475832f30607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_members_chunk event.  <a href="classdpp_1_1cluster.html#ab8979f9fe0fb3aa5ee9a475832f30607">More...</a><br /></td></tr>
<tr class="separator:ab8979f9fe0fb3aa5ee9a475832f30607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d39347e77d032a3bd9d11f29fc753f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0d39347e77d032a3bd9d11f29fc753f9">on_message_reaction_remove</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__remove__t.html">message_reaction_remove_t</a> &amp;_event)&gt; _message_reaction_remove)</td></tr>
<tr class="memdesc:a0d39347e77d032a3bd9d11f29fc753f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a single reaction is removed from a message.  <a href="classdpp_1_1cluster.html#a0d39347e77d032a3bd9d11f29fc753f9">More...</a><br /></td></tr>
<tr class="separator:a0d39347e77d032a3bd9d11f29fc753f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09075271f76213392f7bbc3f8ef19c6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a09075271f76213392f7bbc3f8ef19c6a">detach_message_reaction_remove</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _message_reaction_remove)</td></tr>
<tr class="memdesc:a09075271f76213392f7bbc3f8ef19c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_message_reaction_remove event.  <a href="classdpp_1_1cluster.html#a09075271f76213392f7bbc3f8ef19c6a">More...</a><br /></td></tr>
<tr class="separator:a09075271f76213392f7bbc3f8ef19c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5164c0f1ebeb101c1fa80b03d6e09a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5164c0f1ebeb101c1fa80b03d6e09a4a">on_guild_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__create__t.html">guild_create_t</a> &amp;_event)&gt; _guild_create)</td></tr>
<tr class="memdesc:a5164c0f1ebeb101c1fa80b03d6e09a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new guild is created. D++ will request members for the guild for its cache using guild_members_chunk.  <a href="classdpp_1_1cluster.html#a5164c0f1ebeb101c1fa80b03d6e09a4a">More...</a><br /></td></tr>
<tr class="separator:a5164c0f1ebeb101c1fa80b03d6e09a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adcba64c577f2a617aa3436a5b52dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4adcba64c577f2a617aa3436a5b52dd4">detach_guild_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_create)</td></tr>
<tr class="memdesc:a4adcba64c577f2a617aa3436a5b52dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_create event.  <a href="classdpp_1_1cluster.html#a4adcba64c577f2a617aa3436a5b52dd4">More...</a><br /></td></tr>
<tr class="separator:a4adcba64c577f2a617aa3436a5b52dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335adc4a68c5651dd5201642f54bc446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a335adc4a68c5651dd5201642f54bc446">on_channel_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1channel__create__t.html">channel_create_t</a> &amp;_event)&gt; _channel_create)</td></tr>
<tr class="memdesc:a335adc4a68c5651dd5201642f54bc446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new channel is created on a guild.  <a href="classdpp_1_1cluster.html#a335adc4a68c5651dd5201642f54bc446">More...</a><br /></td></tr>
<tr class="separator:a335adc4a68c5651dd5201642f54bc446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632a552219431205d5e0b9ff2dc6abb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a632a552219431205d5e0b9ff2dc6abb7">detach_channel_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _channel_create)</td></tr>
<tr class="memdesc:a632a552219431205d5e0b9ff2dc6abb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_channel_create event.  <a href="classdpp_1_1cluster.html#a632a552219431205d5e0b9ff2dc6abb7">More...</a><br /></td></tr>
<tr class="separator:a632a552219431205d5e0b9ff2dc6abb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68da8c59d05684d232e60ef3ca068c47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a68da8c59d05684d232e60ef3ca068c47">on_message_reaction_remove_emoji</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__remove__emoji__t.html">message_reaction_remove_emoji_t</a> &amp;_event)&gt; _message_reaction_remove_emoji)</td></tr>
<tr class="memdesc:a68da8c59d05684d232e60ef3ca068c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when all reactions for a particular emoji are removed from a message.  <a href="classdpp_1_1cluster.html#a68da8c59d05684d232e60ef3ca068c47">More...</a><br /></td></tr>
<tr class="separator:a68da8c59d05684d232e60ef3ca068c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9dd859d5054cba8e2e0d7eb3c8a34b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0c9dd859d5054cba8e2e0d7eb3c8a34b">detach_message_reaction_remove_emoji</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _message_reaction_remove_emoji)</td></tr>
<tr class="memdesc:a0c9dd859d5054cba8e2e0d7eb3c8a34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_message_reaction_remove_emoji event.  <a href="classdpp_1_1cluster.html#a0c9dd859d5054cba8e2e0d7eb3c8a34b">More...</a><br /></td></tr>
<tr class="separator:a0c9dd859d5054cba8e2e0d7eb3c8a34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d201a0a872eb18d73abcad10b0ceec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad9d201a0a872eb18d73abcad10b0ceec">on_message_delete_bulk</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1message__delete__bulk__t.html">message_delete_bulk_t</a> &amp;_event)&gt; _message_delete_bulk)</td></tr>
<tr class="memdesc:ad9d201a0a872eb18d73abcad10b0ceec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when multiple messages are deleted from a channel or DM.  <a href="classdpp_1_1cluster.html#ad9d201a0a872eb18d73abcad10b0ceec">More...</a><br /></td></tr>
<tr class="separator:ad9d201a0a872eb18d73abcad10b0ceec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2aeb6d3e1348d04389577fde4bebada"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab2aeb6d3e1348d04389577fde4bebada">detach_message_delete_bulk</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _message_delete_bulk)</td></tr>
<tr class="memdesc:ab2aeb6d3e1348d04389577fde4bebada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_message_delete_bulk event.  <a href="classdpp_1_1cluster.html#ab2aeb6d3e1348d04389577fde4bebada">More...</a><br /></td></tr>
<tr class="separator:ab2aeb6d3e1348d04389577fde4bebada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbf2f6a526453d97616d6c3fdf15cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#acbbf2f6a526453d97616d6c3fdf15cdd">on_guild_role_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__role__update__t.html">guild_role_update_t</a> &amp;_event)&gt; _guild_role_update)</td></tr>
<tr class="memdesc:acbbf2f6a526453d97616d6c3fdf15cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an existing role is updated on a guild.  <a href="classdpp_1_1cluster.html#acbbf2f6a526453d97616d6c3fdf15cdd">More...</a><br /></td></tr>
<tr class="separator:acbbf2f6a526453d97616d6c3fdf15cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779ebb839d4467583ff65ae57b815e6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a779ebb839d4467583ff65ae57b815e6a">detach_guild_role_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_role_update)</td></tr>
<tr class="memdesc:a779ebb839d4467583ff65ae57b815e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_role_update event.  <a href="classdpp_1_1cluster.html#a779ebb839d4467583ff65ae57b815e6a">More...</a><br /></td></tr>
<tr class="separator:a779ebb839d4467583ff65ae57b815e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae250fcc04d66b9fc2449b05e1fc04c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae250fcc04d66b9fc2449b05e1fc04c7a">on_guild_role_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__role__delete__t.html">guild_role_delete_t</a> &amp;_event)&gt; _guild_role_delete)</td></tr>
<tr class="memdesc:ae250fcc04d66b9fc2449b05e1fc04c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a role is deleted in a guild.  <a href="classdpp_1_1cluster.html#ae250fcc04d66b9fc2449b05e1fc04c7a">More...</a><br /></td></tr>
<tr class="separator:ae250fcc04d66b9fc2449b05e1fc04c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be23b9b8849a4493338207e85a41033"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1be23b9b8849a4493338207e85a41033">detach_guild_role_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_role_delete)</td></tr>
<tr class="memdesc:a1be23b9b8849a4493338207e85a41033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_role_delete event.  <a href="classdpp_1_1cluster.html#a1be23b9b8849a4493338207e85a41033">More...</a><br /></td></tr>
<tr class="separator:a1be23b9b8849a4493338207e85a41033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fe59534c81060533f8b31865b3a23a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a57fe59534c81060533f8b31865b3a23a">on_channel_pins_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1channel__pins__update__t.html">channel_pins_update_t</a> &amp;_event)&gt; _channel_pins_update)</td></tr>
<tr class="memdesc:a57fe59534c81060533f8b31865b3a23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a message is pinned. Note that the pinned message is not returned to this event, just the timestamp of the last pinned message.  <a href="classdpp_1_1cluster.html#a57fe59534c81060533f8b31865b3a23a">More...</a><br /></td></tr>
<tr class="separator:a57fe59534c81060533f8b31865b3a23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0548cce6c1916b6bc1335a0142c2f5fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0548cce6c1916b6bc1335a0142c2f5fe">detach_channel_pins_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _channel_pins_update)</td></tr>
<tr class="memdesc:a0548cce6c1916b6bc1335a0142c2f5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_channel_pins_update event.  <a href="classdpp_1_1cluster.html#a0548cce6c1916b6bc1335a0142c2f5fe">More...</a><br /></td></tr>
<tr class="separator:a0548cce6c1916b6bc1335a0142c2f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba2fda7d5eaf854e8b27083521738a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7ba2fda7d5eaf854e8b27083521738a5">on_message_reaction_remove_all</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__remove__all__t.html">message_reaction_remove_all_t</a> &amp;_event)&gt; _message_reaction_remove_all)</td></tr>
<tr class="memdesc:a7ba2fda7d5eaf854e8b27083521738a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when all reactions are removed from a message.  <a href="classdpp_1_1cluster.html#a7ba2fda7d5eaf854e8b27083521738a5">More...</a><br /></td></tr>
<tr class="separator:a7ba2fda7d5eaf854e8b27083521738a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf9410441b0b0b525b46e5335b098dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#addf9410441b0b0b525b46e5335b098dc">detach_message_reaction_remove_all</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _message_reaction_remove_all)</td></tr>
<tr class="memdesc:addf9410441b0b0b525b46e5335b098dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_message_reaction_remove_all event.  <a href="classdpp_1_1cluster.html#addf9410441b0b0b525b46e5335b098dc">More...</a><br /></td></tr>
<tr class="separator:addf9410441b0b0b525b46e5335b098dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b48bed7a6a1e0d0f824e66c839a7d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a52b48bed7a6a1e0d0f824e66c839a7d8">on_voice_server_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1voice__server__update__t.html">voice_server_update_t</a> &amp;_event)&gt; _voice_server_update)</td></tr>
<tr class="memdesc:a52b48bed7a6a1e0d0f824e66c839a7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when we are told which voice server we can use. This will be sent either when we establish a new voice channel connection, or as discord rearrange their infrastructure.  <a href="classdpp_1_1cluster.html#a52b48bed7a6a1e0d0f824e66c839a7d8">More...</a><br /></td></tr>
<tr class="separator:a52b48bed7a6a1e0d0f824e66c839a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8894dbcd25a4e288c9bdbf116db4277"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa8894dbcd25a4e288c9bdbf116db4277">detach_voice_server_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _voice_server_update)</td></tr>
<tr class="memdesc:aa8894dbcd25a4e288c9bdbf116db4277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_voice_server_update event.  <a href="classdpp_1_1cluster.html#aa8894dbcd25a4e288c9bdbf116db4277">More...</a><br /></td></tr>
<tr class="separator:aa8894dbcd25a4e288c9bdbf116db4277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2f6179869a30c910f1bef89c511d7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0d2f6179869a30c910f1bef89c511d7c">on_guild_emojis_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__emojis__update__t.html">guild_emojis_update_t</a> &amp;_event)&gt; _guild_emojis_update)</td></tr>
<tr class="memdesc:a0d2f6179869a30c910f1bef89c511d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new emojis are added to a guild. The complete set of emojis is sent every time.  <a href="classdpp_1_1cluster.html#a0d2f6179869a30c910f1bef89c511d7c">More...</a><br /></td></tr>
<tr class="separator:a0d2f6179869a30c910f1bef89c511d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe2b42f0103cdcf0e3dd91a1ae56367"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aebe2b42f0103cdcf0e3dd91a1ae56367">detach_guild_emojis_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_emojis_update)</td></tr>
<tr class="memdesc:aebe2b42f0103cdcf0e3dd91a1ae56367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_emojis_update event.  <a href="classdpp_1_1cluster.html#aebe2b42f0103cdcf0e3dd91a1ae56367">More...</a><br /></td></tr>
<tr class="separator:aebe2b42f0103cdcf0e3dd91a1ae56367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a04d841ce5b7e6221e6da7da8b18a7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1a04d841ce5b7e6221e6da7da8b18a7a">on_guild_stickers_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__stickers__update__t.html">guild_stickers_update_t</a> &amp;_event)&gt; _guild_stickers_update)</td></tr>
<tr class="memdesc:a1a04d841ce5b7e6221e6da7da8b18a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new stickers are added to a guild. The complete set of stickers is sent every time.  <a href="classdpp_1_1cluster.html#a1a04d841ce5b7e6221e6da7da8b18a7a">More...</a><br /></td></tr>
<tr class="separator:a1a04d841ce5b7e6221e6da7da8b18a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada013c47908344d05f0081a265b395c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ada013c47908344d05f0081a265b395c2">detach_guild_stickers_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_stickers_update)</td></tr>
<tr class="memdesc:ada013c47908344d05f0081a265b395c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_stickers_update event.  <a href="classdpp_1_1cluster.html#ada013c47908344d05f0081a265b395c2">More...</a><br /></td></tr>
<tr class="separator:ada013c47908344d05f0081a265b395c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8484375dcceebd05c115ff4dbe58cb5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8484375dcceebd05c115ff4dbe58cb5b">on_presence_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1presence__update__t.html">presence_update_t</a> &amp;_event)&gt; _presence_update)</td></tr>
<tr class="memdesc:a8484375dcceebd05c115ff4dbe58cb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user's presence is updated. To receive these you will need the GUILD_PRESENCES privileged intent. You will receive many of these, very often, and receiving them will significantly increase your bot's CPU usage. If you don't need them it is recommended to not ask for them.  <a href="classdpp_1_1cluster.html#a8484375dcceebd05c115ff4dbe58cb5b">More...</a><br /></td></tr>
<tr class="separator:a8484375dcceebd05c115ff4dbe58cb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222adf2230d34a2767bbc2d8309fe3a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a222adf2230d34a2767bbc2d8309fe3a9">detach_presence_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _presence_update)</td></tr>
<tr class="memdesc:a222adf2230d34a2767bbc2d8309fe3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_presence_update event.  <a href="classdpp_1_1cluster.html#a222adf2230d34a2767bbc2d8309fe3a9">More...</a><br /></td></tr>
<tr class="separator:a222adf2230d34a2767bbc2d8309fe3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf720a6c565961648577ebfb46bd716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#afcf720a6c565961648577ebfb46bd716">on_webhooks_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1webhooks__update__t.html">webhooks_update_t</a> &amp;_event)&gt; _webhooks_update)</td></tr>
<tr class="memdesc:afcf720a6c565961648577ebfb46bd716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the webhooks for a guild are updated.  <a href="classdpp_1_1cluster.html#afcf720a6c565961648577ebfb46bd716">More...</a><br /></td></tr>
<tr class="separator:afcf720a6c565961648577ebfb46bd716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781737ff70ccc19ee517025a7131aaf7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a781737ff70ccc19ee517025a7131aaf7">detach_webhooks_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _webhooks_update)</td></tr>
<tr class="memdesc:a781737ff70ccc19ee517025a7131aaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_webhooks_update event.  <a href="classdpp_1_1cluster.html#a781737ff70ccc19ee517025a7131aaf7">More...</a><br /></td></tr>
<tr class="separator:a781737ff70ccc19ee517025a7131aaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77b960a3530d07e972e82d8fff5a8ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa77b960a3530d07e972e82d8fff5a8ae">on_guild_member_add</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__member__add__t.html">guild_member_add_t</a> &amp;_event)&gt; _guild_member_add)</td></tr>
<tr class="memdesc:aa77b960a3530d07e972e82d8fff5a8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new member joins a guild.  <a href="classdpp_1_1cluster.html#aa77b960a3530d07e972e82d8fff5a8ae">More...</a><br /></td></tr>
<tr class="separator:aa77b960a3530d07e972e82d8fff5a8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4e5114eeaa38be6711200e65767fe8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4b4e5114eeaa38be6711200e65767fe8">detach_guild_member_add</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_member_add)</td></tr>
<tr class="memdesc:a4b4e5114eeaa38be6711200e65767fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_member_add event.  <a href="classdpp_1_1cluster.html#a4b4e5114eeaa38be6711200e65767fe8">More...</a><br /></td></tr>
<tr class="separator:a4b4e5114eeaa38be6711200e65767fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3283aad1e815362ff1e489af5e216da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3283aad1e815362ff1e489af5e216da3">on_invite_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1invite__delete__t.html">invite_delete_t</a> &amp;_event)&gt; _invite_delete)</td></tr>
<tr class="memdesc:a3283aad1e815362ff1e489af5e216da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an invite is deleted from a guild.  <a href="classdpp_1_1cluster.html#a3283aad1e815362ff1e489af5e216da3">More...</a><br /></td></tr>
<tr class="separator:a3283aad1e815362ff1e489af5e216da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0749d432ed12b5ad4e4a0afd89cfcc76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0749d432ed12b5ad4e4a0afd89cfcc76">detach_invite_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _invite_delete)</td></tr>
<tr class="memdesc:a0749d432ed12b5ad4e4a0afd89cfcc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_invite_delete event.  <a href="classdpp_1_1cluster.html#a0749d432ed12b5ad4e4a0afd89cfcc76">More...</a><br /></td></tr>
<tr class="separator:a0749d432ed12b5ad4e4a0afd89cfcc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1bc31f6ad73a63417020ae1ae40bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0d1bc31f6ad73a63417020ae1ae40bb4">on_guild_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__update__t.html">guild_update_t</a> &amp;_event)&gt; _guild_update)</td></tr>
<tr class="memdesc:a0d1bc31f6ad73a63417020ae1ae40bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when details of a guild are updated.  <a href="classdpp_1_1cluster.html#a0d1bc31f6ad73a63417020ae1ae40bb4">More...</a><br /></td></tr>
<tr class="separator:a0d1bc31f6ad73a63417020ae1ae40bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e352cbb7fce4d05df26e3dfd949dbc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3e352cbb7fce4d05df26e3dfd949dbc2">detach_guild_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_update)</td></tr>
<tr class="memdesc:a3e352cbb7fce4d05df26e3dfd949dbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_update event.  <a href="classdpp_1_1cluster.html#a3e352cbb7fce4d05df26e3dfd949dbc2">More...</a><br /></td></tr>
<tr class="separator:a3e352cbb7fce4d05df26e3dfd949dbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731cc99b15dd5f15568ee5856d8ceffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a731cc99b15dd5f15568ee5856d8ceffa">on_guild_integrations_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__integrations__update__t.html">guild_integrations_update_t</a> &amp;_event)&gt; _guild_integrations_update)</td></tr>
<tr class="memdesc:a731cc99b15dd5f15568ee5856d8ceffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an integration is updated for a guild. This returns the complete list. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc.  <a href="classdpp_1_1cluster.html#a731cc99b15dd5f15568ee5856d8ceffa">More...</a><br /></td></tr>
<tr class="separator:a731cc99b15dd5f15568ee5856d8ceffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dd91d6f6b735b35ab3867e99507ef6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a69dd91d6f6b735b35ab3867e99507ef6">detach_guild_integrations_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_integrations_update)</td></tr>
<tr class="memdesc:a69dd91d6f6b735b35ab3867e99507ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_integrations_update event.  <a href="classdpp_1_1cluster.html#a69dd91d6f6b735b35ab3867e99507ef6">More...</a><br /></td></tr>
<tr class="separator:a69dd91d6f6b735b35ab3867e99507ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3ffd9036946ac953be2e5f552e988c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aad3ffd9036946ac953be2e5f552e988c">on_guild_member_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__member__update__t.html">guild_member_update_t</a> &amp;_event)&gt; _guild_member_update)</td></tr>
<tr class="memdesc:aad3ffd9036946ac953be2e5f552e988c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when details of a guild member (e.g. their roles or nickname) are updated.  <a href="classdpp_1_1cluster.html#aad3ffd9036946ac953be2e5f552e988c">More...</a><br /></td></tr>
<tr class="separator:aad3ffd9036946ac953be2e5f552e988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5489624b95b26f76e1cee48cef28bf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad5489624b95b26f76e1cee48cef28bf6">detach_guild_member_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_member_update)</td></tr>
<tr class="memdesc:ad5489624b95b26f76e1cee48cef28bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_member_update event.  <a href="classdpp_1_1cluster.html#ad5489624b95b26f76e1cee48cef28bf6">More...</a><br /></td></tr>
<tr class="separator:ad5489624b95b26f76e1cee48cef28bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbbc1e590a5c23311f2895db63d5d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2dbbc1e590a5c23311f2895db63d5d5f">on_application_command_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1application__command__update__t.html">application_command_update_t</a> &amp;_event)&gt; _application_command_update)</td></tr>
<tr class="memdesc:a2dbbc1e590a5c23311f2895db63d5d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an application command (slash command) is updated. You will only receive this event for application commands that belong to your bot/application.  <a href="classdpp_1_1cluster.html#a2dbbc1e590a5c23311f2895db63d5d5f">More...</a><br /></td></tr>
<tr class="separator:a2dbbc1e590a5c23311f2895db63d5d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a7dba8a5219ab613bfebac352a8213"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a16a7dba8a5219ab613bfebac352a8213">detach_application_command_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _application_command_update)</td></tr>
<tr class="memdesc:a16a7dba8a5219ab613bfebac352a8213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_application_command_update event.  <a href="classdpp_1_1cluster.html#a16a7dba8a5219ab613bfebac352a8213">More...</a><br /></td></tr>
<tr class="separator:a16a7dba8a5219ab613bfebac352a8213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4128b323c8e48236da083841d9cfa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3b4128b323c8e48236da083841d9cfa8">on_invite_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1invite__create__t.html">invite_create_t</a> &amp;_event)&gt; _invite_create)</td></tr>
<tr class="memdesc:a3b4128b323c8e48236da083841d9cfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new invite is created for a guild.  <a href="classdpp_1_1cluster.html#a3b4128b323c8e48236da083841d9cfa8">More...</a><br /></td></tr>
<tr class="separator:a3b4128b323c8e48236da083841d9cfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384e99ac71372c0031c88aa73aada59c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a384e99ac71372c0031c88aa73aada59c">detach_invite_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _invite_create)</td></tr>
<tr class="memdesc:a384e99ac71372c0031c88aa73aada59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_invite_create event.  <a href="classdpp_1_1cluster.html#a384e99ac71372c0031c88aa73aada59c">More...</a><br /></td></tr>
<tr class="separator:a384e99ac71372c0031c88aa73aada59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66873c7ab2b1d86a9a353d889484944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad66873c7ab2b1d86a9a353d889484944">on_message_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1message__update__t.html">message_update_t</a> &amp;_event)&gt; _message_update)</td></tr>
<tr class="memdesc:ad66873c7ab2b1d86a9a353d889484944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a message is updated (edited).  <a href="classdpp_1_1cluster.html#ad66873c7ab2b1d86a9a353d889484944">More...</a><br /></td></tr>
<tr class="separator:ad66873c7ab2b1d86a9a353d889484944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4188de5ccc26bf335f640772326fd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0c4188de5ccc26bf335f640772326fd6">detach_message_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _message_update)</td></tr>
<tr class="memdesc:a0c4188de5ccc26bf335f640772326fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_message_update event.  <a href="classdpp_1_1cluster.html#a0c4188de5ccc26bf335f640772326fd6">More...</a><br /></td></tr>
<tr class="separator:a0c4188de5ccc26bf335f640772326fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa293c651143a9ccffb6090830eed3e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#afa293c651143a9ccffb6090830eed3e5">on_user_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1user__update__t.html">user_update_t</a> &amp;_event)&gt; _user_update)</td></tr>
<tr class="memdesc:afa293c651143a9ccffb6090830eed3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user is updated. This is separate to guild_member_update and includes things such as an avatar change, username change, discriminator change or change in subscription status for nitro.  <a href="classdpp_1_1cluster.html#afa293c651143a9ccffb6090830eed3e5">More...</a><br /></td></tr>
<tr class="separator:afa293c651143a9ccffb6090830eed3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e0e647a6620c6b3cbd74f97134f120"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a65e0e647a6620c6b3cbd74f97134f120">detach_user_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _user_update)</td></tr>
<tr class="memdesc:a65e0e647a6620c6b3cbd74f97134f120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_user_update event.  <a href="classdpp_1_1cluster.html#a65e0e647a6620c6b3cbd74f97134f120">More...</a><br /></td></tr>
<tr class="separator:a65e0e647a6620c6b3cbd74f97134f120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaafcd2c26fe588021454ee3d0d0fec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aaaafcd2c26fe588021454ee3d0d0fec8">on_message_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1message__create__t.html">message_create_t</a> &amp;_event)&gt; _message_create)</td></tr>
<tr class="memdesc:aaaafcd2c26fe588021454ee3d0d0fec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new message arrives from discord. Note that D++ does not cache messages. If you want to cache these objects you should create something yourself within your bot. Caching of messages is not on the roadmap to be supported as it consumes excessive amounts of RAM.  <a href="classdpp_1_1cluster.html#aaaafcd2c26fe588021454ee3d0d0fec8">More...</a><br /></td></tr>
<tr class="separator:aaaafcd2c26fe588021454ee3d0d0fec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e7c6138397c0507013a293d7c8dfb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af1e7c6138397c0507013a293d7c8dfb7">detach_message_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _message_create)</td></tr>
<tr class="memdesc:af1e7c6138397c0507013a293d7c8dfb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_message_create event.  <a href="classdpp_1_1cluster.html#af1e7c6138397c0507013a293d7c8dfb7">More...</a><br /></td></tr>
<tr class="separator:af1e7c6138397c0507013a293d7c8dfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425b60f353b4d7c48d870b850bff785e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a425b60f353b4d7c48d870b850bff785e">on_guild_ban_add</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__ban__add__t.html">guild_ban_add_t</a> &amp;_event)&gt; _guild_ban_add)</td></tr>
<tr class="memdesc:a425b60f353b4d7c48d870b850bff785e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a ban is added to a guild.  <a href="classdpp_1_1cluster.html#a425b60f353b4d7c48d870b850bff785e">More...</a><br /></td></tr>
<tr class="separator:a425b60f353b4d7c48d870b850bff785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e32b89f223d3362c948c346c7fc1a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a87e32b89f223d3362c948c346c7fc1a0">detach_guild_ban_add</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_ban_add)</td></tr>
<tr class="memdesc:a87e32b89f223d3362c948c346c7fc1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_ban_add event.  <a href="classdpp_1_1cluster.html#a87e32b89f223d3362c948c346c7fc1a0">More...</a><br /></td></tr>
<tr class="separator:a87e32b89f223d3362c948c346c7fc1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbd27652ac7192502d6da555e0dc6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#afcbd27652ac7192502d6da555e0dc6c9">on_guild_ban_remove</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__ban__remove__t.html">guild_ban_remove_t</a> &amp;_event)&gt; _guild_ban_remove)</td></tr>
<tr class="memdesc:afcbd27652ac7192502d6da555e0dc6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a ban is removed from a guild.  <a href="classdpp_1_1cluster.html#afcbd27652ac7192502d6da555e0dc6c9">More...</a><br /></td></tr>
<tr class="separator:afcbd27652ac7192502d6da555e0dc6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9561236abcd3ca267caf6a17e6388a3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9561236abcd3ca267caf6a17e6388a3f">detach_guild_ban_remove</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_ban_remove)</td></tr>
<tr class="memdesc:a9561236abcd3ca267caf6a17e6388a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_ban_remove event.  <a href="classdpp_1_1cluster.html#a9561236abcd3ca267caf6a17e6388a3f">More...</a><br /></td></tr>
<tr class="separator:a9561236abcd3ca267caf6a17e6388a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0915881738f80397da118da81358022d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0915881738f80397da118da81358022d">on_integration_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1integration__create__t.html">integration_create_t</a> &amp;_event)&gt; _integration_create)</td></tr>
<tr class="memdesc:a0915881738f80397da118da81358022d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new intgration is attached to a guild by a user. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc.  <a href="classdpp_1_1cluster.html#a0915881738f80397da118da81358022d">More...</a><br /></td></tr>
<tr class="separator:a0915881738f80397da118da81358022d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accde43676031714042f9f76fc81458be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#accde43676031714042f9f76fc81458be">detach_integration_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _integration_create)</td></tr>
<tr class="memdesc:accde43676031714042f9f76fc81458be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_integration_create event.  <a href="classdpp_1_1cluster.html#accde43676031714042f9f76fc81458be">More...</a><br /></td></tr>
<tr class="separator:accde43676031714042f9f76fc81458be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a8130ec8031b283468705f82b940fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a01a8130ec8031b283468705f82b940fa">on_integration_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1integration__update__t.html">integration_update_t</a> &amp;_event)&gt; _integration_update)</td></tr>
<tr class="memdesc:a01a8130ec8031b283468705f82b940fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an integration is updated by a user. This returns details of just the single integration that has changed. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc.  <a href="classdpp_1_1cluster.html#a01a8130ec8031b283468705f82b940fa">More...</a><br /></td></tr>
<tr class="separator:a01a8130ec8031b283468705f82b940fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78a659a6d62231f05d3ccb6c35bc0d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af78a659a6d62231f05d3ccb6c35bc0d3">detach_integration_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _integration_update)</td></tr>
<tr class="memdesc:af78a659a6d62231f05d3ccb6c35bc0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_integration_update event.  <a href="classdpp_1_1cluster.html#af78a659a6d62231f05d3ccb6c35bc0d3">More...</a><br /></td></tr>
<tr class="separator:af78a659a6d62231f05d3ccb6c35bc0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62516361826a0f9256d2ff79b93b9f86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a62516361826a0f9256d2ff79b93b9f86">on_integration_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1integration__delete__t.html">integration_delete_t</a> &amp;_event)&gt; _integration_delete)</td></tr>
<tr class="memdesc:a62516361826a0f9256d2ff79b93b9f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an integration is removed by a user. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc.  <a href="classdpp_1_1cluster.html#a62516361826a0f9256d2ff79b93b9f86">More...</a><br /></td></tr>
<tr class="separator:a62516361826a0f9256d2ff79b93b9f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e49e860707d4fb023f0f94819e4f3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a78e49e860707d4fb023f0f94819e4f3a">detach_integration_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _integration_delete)</td></tr>
<tr class="memdesc:a78e49e860707d4fb023f0f94819e4f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_integration_delete event.  <a href="classdpp_1_1cluster.html#a78e49e860707d4fb023f0f94819e4f3a">More...</a><br /></td></tr>
<tr class="separator:a78e49e860707d4fb023f0f94819e4f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4a35dd08b7c9e90cc338de3105423c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4e4a35dd08b7c9e90cc338de3105423c">on_thread_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1thread__create__t.html">thread_create_t</a> &amp;_event)&gt; _thread_create)</td></tr>
<tr class="memdesc:a4e4a35dd08b7c9e90cc338de3105423c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a thread is created Note: Threads are not cached by D++, but a list of thread IDs is accessible in a guild object.  <a href="classdpp_1_1cluster.html#a4e4a35dd08b7c9e90cc338de3105423c">More...</a><br /></td></tr>
<tr class="separator:a4e4a35dd08b7c9e90cc338de3105423c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab223fa13c5509258857caf06ea6f5d81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab223fa13c5509258857caf06ea6f5d81">detach_thread_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _thread_create)</td></tr>
<tr class="memdesc:ab223fa13c5509258857caf06ea6f5d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_thread_create event.  <a href="classdpp_1_1cluster.html#ab223fa13c5509258857caf06ea6f5d81">More...</a><br /></td></tr>
<tr class="separator:ab223fa13c5509258857caf06ea6f5d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5047e0ea3ee5f77b92e10fdd8e7f1bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5047e0ea3ee5f77b92e10fdd8e7f1bb8">on_thread_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1thread__update__t.html">thread_update_t</a> &amp;_event)&gt; _thread_update)</td></tr>
<tr class="memdesc:a5047e0ea3ee5f77b92e10fdd8e7f1bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a thread is updated.  <a href="classdpp_1_1cluster.html#a5047e0ea3ee5f77b92e10fdd8e7f1bb8">More...</a><br /></td></tr>
<tr class="separator:a5047e0ea3ee5f77b92e10fdd8e7f1bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b22493483a49de30065ed9bd90b666"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac6b22493483a49de30065ed9bd90b666">detach_thread_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _thread_update)</td></tr>
<tr class="memdesc:ac6b22493483a49de30065ed9bd90b666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_thread_update event.  <a href="classdpp_1_1cluster.html#ac6b22493483a49de30065ed9bd90b666">More...</a><br /></td></tr>
<tr class="separator:ac6b22493483a49de30065ed9bd90b666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a96cbbac9227e14a125c21bab9d8d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab9a96cbbac9227e14a125c21bab9d8d7">on_thread_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1thread__delete__t.html">thread_delete_t</a> &amp;_event)&gt; _thread_delete)</td></tr>
<tr class="memdesc:ab9a96cbbac9227e14a125c21bab9d8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a thread is deleted.  <a href="classdpp_1_1cluster.html#ab9a96cbbac9227e14a125c21bab9d8d7">More...</a><br /></td></tr>
<tr class="separator:ab9a96cbbac9227e14a125c21bab9d8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa31e287f586783edc6d5844d4396cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#affa31e287f586783edc6d5844d4396cf">detach_thread_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _thread_delete)</td></tr>
<tr class="memdesc:affa31e287f586783edc6d5844d4396cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_thread_delete event.  <a href="classdpp_1_1cluster.html#affa31e287f586783edc6d5844d4396cf">More...</a><br /></td></tr>
<tr class="separator:affa31e287f586783edc6d5844d4396cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148422098b97980a26de5effb6fba208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a148422098b97980a26de5effb6fba208">on_thread_list_sync</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1thread__list__sync__t.html">thread_list_sync_t</a> &amp;_event)&gt; _thread_list_sync)</td></tr>
<tr class="memdesc:a148422098b97980a26de5effb6fba208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when thread list is synced (upon gaining access to a channel) Note: Threads are not cached by D++, but a list of thread IDs is accessible in a guild object.  <a href="classdpp_1_1cluster.html#a148422098b97980a26de5effb6fba208">More...</a><br /></td></tr>
<tr class="separator:a148422098b97980a26de5effb6fba208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaec9dce7a9f8f8619579c990bf714f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aeaec9dce7a9f8f8619579c990bf714f5">detach_thread_list_sync</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _thread_list_sync)</td></tr>
<tr class="memdesc:aeaec9dce7a9f8f8619579c990bf714f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_thread_list_sync event.  <a href="classdpp_1_1cluster.html#aeaec9dce7a9f8f8619579c990bf714f5">More...</a><br /></td></tr>
<tr class="separator:aeaec9dce7a9f8f8619579c990bf714f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40e5e964c728a7e56b7b0379ef699db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae40e5e964c728a7e56b7b0379ef699db">on_thread_member_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1thread__member__update__t.html">thread_member_update_t</a> &amp;_event)&gt; _thread_member_update)</td></tr>
<tr class="memdesc:ae40e5e964c728a7e56b7b0379ef699db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when current user's thread member object is updated.  <a href="classdpp_1_1cluster.html#ae40e5e964c728a7e56b7b0379ef699db">More...</a><br /></td></tr>
<tr class="separator:ae40e5e964c728a7e56b7b0379ef699db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567b3f5bf160831373933f058bd177d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a567b3f5bf160831373933f058bd177d2">detach_thread_member_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _thread_member_update)</td></tr>
<tr class="memdesc:a567b3f5bf160831373933f058bd177d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_thread_member_update event.  <a href="classdpp_1_1cluster.html#a567b3f5bf160831373933f058bd177d2">More...</a><br /></td></tr>
<tr class="separator:a567b3f5bf160831373933f058bd177d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9e5c58c9fe8b5cb7f98e3aaf3944d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#abe9e5c58c9fe8b5cb7f98e3aaf3944d3">on_thread_members_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1thread__members__update__t.html">thread_members_update_t</a> &amp;_event)&gt; _thread_members_update)</td></tr>
<tr class="memdesc:abe9e5c58c9fe8b5cb7f98e3aaf3944d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a thread's member list is updated (without GUILD_MEMBERS intent, is only called for current user)  <a href="classdpp_1_1cluster.html#abe9e5c58c9fe8b5cb7f98e3aaf3944d3">More...</a><br /></td></tr>
<tr class="separator:abe9e5c58c9fe8b5cb7f98e3aaf3944d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284102ffbb5953325e4b8fb36155a7f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a284102ffbb5953325e4b8fb36155a7f7">detach_thread_members_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _thread_members_update)</td></tr>
<tr class="memdesc:a284102ffbb5953325e4b8fb36155a7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_thread_members_update event.  <a href="classdpp_1_1cluster.html#a284102ffbb5953325e4b8fb36155a7f7">More...</a><br /></td></tr>
<tr class="separator:a284102ffbb5953325e4b8fb36155a7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1d9a0fbc87cfd2312faf2ad2aab381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aac1d9a0fbc87cfd2312faf2ad2aab381">on_guild_scheduled_event_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__create__t.html">guild_scheduled_event_create_t</a> &amp;_event)&gt; _guild_scheduled_event_create)</td></tr>
<tr class="memdesc:aac1d9a0fbc87cfd2312faf2ad2aab381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new scheduled event is created.  <a href="classdpp_1_1cluster.html#aac1d9a0fbc87cfd2312faf2ad2aab381">More...</a><br /></td></tr>
<tr class="separator:aac1d9a0fbc87cfd2312faf2ad2aab381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9a58f0e8f7dfcabec9ed86d494dac4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1d9a58f0e8f7dfcabec9ed86d494dac4">detach_guild_scheduled_event_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_scheduled_event_create)</td></tr>
<tr class="memdesc:a1d9a58f0e8f7dfcabec9ed86d494dac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_scheduled_event_create.  <a href="classdpp_1_1cluster.html#a1d9a58f0e8f7dfcabec9ed86d494dac4">More...</a><br /></td></tr>
<tr class="separator:a1d9a58f0e8f7dfcabec9ed86d494dac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdebff7b0db64e06bb8585193bd41a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#abdebff7b0db64e06bb8585193bd41a52">on_guild_scheduled_event_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__update__t.html">guild_scheduled_event_update_t</a> &amp;_event)&gt; _guild_scheduled_event_update)</td></tr>
<tr class="memdesc:abdebff7b0db64e06bb8585193bd41a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new scheduled event is updated.  <a href="classdpp_1_1cluster.html#abdebff7b0db64e06bb8585193bd41a52">More...</a><br /></td></tr>
<tr class="separator:abdebff7b0db64e06bb8585193bd41a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee3b48a74d9243df3b160ec5d688335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8ee3b48a74d9243df3b160ec5d688335">detach_guild_scheduled_event_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_scheduled_event_update)</td></tr>
<tr class="memdesc:a8ee3b48a74d9243df3b160ec5d688335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_scheduled_event_update.  <a href="classdpp_1_1cluster.html#a8ee3b48a74d9243df3b160ec5d688335">More...</a><br /></td></tr>
<tr class="separator:a8ee3b48a74d9243df3b160ec5d688335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f19dadb24daf8a92186fdea29a7599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a31f19dadb24daf8a92186fdea29a7599">on_guild_scheduled_event_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__delete__t.html">guild_scheduled_event_delete_t</a> &amp;_event)&gt; _guild_scheduled_event_delete)</td></tr>
<tr class="memdesc:a31f19dadb24daf8a92186fdea29a7599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new scheduled event is deleted.  <a href="classdpp_1_1cluster.html#a31f19dadb24daf8a92186fdea29a7599">More...</a><br /></td></tr>
<tr class="separator:a31f19dadb24daf8a92186fdea29a7599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4988a9fa82fc1593a9f66627626f1e78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4988a9fa82fc1593a9f66627626f1e78">detach_guild_scheduled_event_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_scheduled_event_delete)</td></tr>
<tr class="memdesc:a4988a9fa82fc1593a9f66627626f1e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_scheduled_event_delete.  <a href="classdpp_1_1cluster.html#a4988a9fa82fc1593a9f66627626f1e78">More...</a><br /></td></tr>
<tr class="separator:a4988a9fa82fc1593a9f66627626f1e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad448883ec484005d51c98330c8fc26ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad448883ec484005d51c98330c8fc26ce">on_guild_scheduled_event_user_add</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__user__add__t.html">guild_scheduled_event_user_add_t</a> &amp;_event)&gt; _guild_scheduled_event_user_add)</td></tr>
<tr class="memdesc:ad448883ec484005d51c98330c8fc26ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user is added to a scheduled event.  <a href="classdpp_1_1cluster.html#ad448883ec484005d51c98330c8fc26ce">More...</a><br /></td></tr>
<tr class="separator:ad448883ec484005d51c98330c8fc26ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae706fc7e036a45aa686ca1b88a4b88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6ae706fc7e036a45aa686ca1b88a4b88">detach_guild_scheduled_event_user_add</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_scheduled_event_user_add)</td></tr>
<tr class="memdesc:a6ae706fc7e036a45aa686ca1b88a4b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_scheduled_event_user_add.  <a href="classdpp_1_1cluster.html#a6ae706fc7e036a45aa686ca1b88a4b88">More...</a><br /></td></tr>
<tr class="separator:a6ae706fc7e036a45aa686ca1b88a4b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a9b0e0f6e35314b91f5c765823b75f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a67a9b0e0f6e35314b91f5c765823b75f">on_guild_scheduled_event_user_remove</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__user__remove__t.html">guild_scheduled_event_user_remove_t</a> &amp;_event)&gt; _guild_scheduled_event_user_remove)</td></tr>
<tr class="memdesc:a67a9b0e0f6e35314b91f5c765823b75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user is removed to a scheduled event.  <a href="classdpp_1_1cluster.html#a67a9b0e0f6e35314b91f5c765823b75f">More...</a><br /></td></tr>
<tr class="separator:a67a9b0e0f6e35314b91f5c765823b75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4622b6cadc6edd6a6f067f5d811a32b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4622b6cadc6edd6a6f067f5d811a32b1">detach_guild_scheduled_event_user_remove</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _guild_scheduled_event_user_remove)</td></tr>
<tr class="memdesc:a4622b6cadc6edd6a6f067f5d811a32b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_guild_scheduled_event_user_remove.  <a href="classdpp_1_1cluster.html#a4622b6cadc6edd6a6f067f5d811a32b1">More...</a><br /></td></tr>
<tr class="separator:a4622b6cadc6edd6a6f067f5d811a32b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c915eafbf888a369278f21989f8476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae1c915eafbf888a369278f21989f8476">on_voice_buffer_send</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1voice__buffer__send__t.html">voice_buffer_send_t</a> &amp;_event)&gt; _voice_buffer_send)</td></tr>
<tr class="memdesc:ae1c915eafbf888a369278f21989f8476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when packets are sent from the voice buffer. The voice buffer contains packets that are already encoded with Opus and encrypted with Sodium, and merged into packets by the repacketizer, which is done in the dpp::discord_voice_client::send_audio method. You should use the buffer size properties of <a class="el" href="structdpp_1_1voice__buffer__send__t.html" title="voice buffer send">dpp::voice_buffer_send_t</a> to determine if you should fill the buffer with more content.  <a href="classdpp_1_1cluster.html#ae1c915eafbf888a369278f21989f8476">More...</a><br /></td></tr>
<tr class="separator:ae1c915eafbf888a369278f21989f8476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d89e1aeb06cfef9fe246fad880fb7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab8d89e1aeb06cfef9fe246fad880fb7c">detach_voice_buffer_send</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _voice_buffer_send)</td></tr>
<tr class="memdesc:ab8d89e1aeb06cfef9fe246fad880fb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_voice_buffer_send event.  <a href="classdpp_1_1cluster.html#ab8d89e1aeb06cfef9fe246fad880fb7c">More...</a><br /></td></tr>
<tr class="separator:ab8d89e1aeb06cfef9fe246fad880fb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee7911f1695b3873d6963260264d8ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aaee7911f1695b3873d6963260264d8ef">on_voice_user_talking</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1voice__user__talking__t.html">voice_user_talking_t</a> &amp;_event)&gt; _voice_user_talking)</td></tr>
<tr class="memdesc:aaee7911f1695b3873d6963260264d8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user is talking on a voice channel.  <a href="classdpp_1_1cluster.html#aaee7911f1695b3873d6963260264d8ef">More...</a><br /></td></tr>
<tr class="separator:aaee7911f1695b3873d6963260264d8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f35e4e2f509df9137c203569883744"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a42f35e4e2f509df9137c203569883744">detach_voice_user_talking</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _voice_user_talking)</td></tr>
<tr class="memdesc:a42f35e4e2f509df9137c203569883744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_voice_user_talking event.  <a href="classdpp_1_1cluster.html#a42f35e4e2f509df9137c203569883744">More...</a><br /></td></tr>
<tr class="separator:a42f35e4e2f509df9137c203569883744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad350f1c81f3c81d5128fe5d03bbfa711"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad350f1c81f3c81d5128fe5d03bbfa711">on_voice_ready</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1voice__ready__t.html">voice_ready_t</a> &amp;_event)&gt; _voice_ready)</td></tr>
<tr class="memdesc:ad350f1c81f3c81d5128fe5d03bbfa711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a voice channel is connected and ready to send audio. Note that this is not directly attached to the READY event of the websocket, as there is further connection that needs to be done before audio is ready to send.  <a href="classdpp_1_1cluster.html#ad350f1c81f3c81d5128fe5d03bbfa711">More...</a><br /></td></tr>
<tr class="separator:ad350f1c81f3c81d5128fe5d03bbfa711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f71ab5f93e806992228a7c2461c65e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2f71ab5f93e806992228a7c2461c65e1">detach_voice_ready</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _voice_ready)</td></tr>
<tr class="memdesc:a2f71ab5f93e806992228a7c2461c65e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_voice_ready event.  <a href="classdpp_1_1cluster.html#a2f71ab5f93e806992228a7c2461c65e1">More...</a><br /></td></tr>
<tr class="separator:a2f71ab5f93e806992228a7c2461c65e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1667f6fda196df3bb7f858e690ff91f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1667f6fda196df3bb7f858e690ff91f3">on_voice_receive</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1voice__receive__t.html">voice_receive_t</a> &amp;_event)&gt; _voice_receive)</td></tr>
<tr class="memdesc:a1667f6fda196df3bb7f858e690ff91f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new audio data is received. Each separate user's audio from the voice channel will arrive tagged with their user id in the event, if a user can be attributed to the received audio.  <a href="classdpp_1_1cluster.html#a1667f6fda196df3bb7f858e690ff91f3">More...</a><br /></td></tr>
<tr class="separator:a1667f6fda196df3bb7f858e690ff91f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb9547eb81c13acd4059dfb81b9d752"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2cb9547eb81c13acd4059dfb81b9d752">detach_voice_receive</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _voice_receive)</td></tr>
<tr class="memdesc:a2cb9547eb81c13acd4059dfb81b9d752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_voice_receive event.  <a href="classdpp_1_1cluster.html#a2cb9547eb81c13acd4059dfb81b9d752">More...</a><br /></td></tr>
<tr class="separator:a2cb9547eb81c13acd4059dfb81b9d752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0777f715bdfd39c897f7ef93d67427a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0777f715bdfd39c897f7ef93d67427a1">on_voice_track_marker</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1voice__track__marker__t.html">voice_track_marker_t</a> &amp;_event)&gt; _voice_track_marker)</td></tr>
<tr class="memdesc:a0777f715bdfd39c897f7ef93d67427a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when sending of audio passes over a track marker. Track markers are arbitrarily placed "bookmarks" in the audio buffer, placed by the bot developer. Each track marker can have a string value associated with it which is specified in <a class="el" href="classdpp_1_1discord__voice__client.html#a84fc0cb1aaf9691aed818e18daea1b84" title="Insert a track marker into the audio output buffer. A track marker is an arbitrary flag in the buffer...">dpp::discord_voice_client::insert_marker</a> and returned to this event.  <a href="classdpp_1_1cluster.html#a0777f715bdfd39c897f7ef93d67427a1">More...</a><br /></td></tr>
<tr class="separator:a0777f715bdfd39c897f7ef93d67427a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46e5cf28809fb46b5e1468b4081377c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac46e5cf28809fb46b5e1468b4081377c">detach_voice_track_marker</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _voice_track_marker)</td></tr>
<tr class="memdesc:ac46e5cf28809fb46b5e1468b4081377c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_voice_track_marker event.  <a href="classdpp_1_1cluster.html#ac46e5cf28809fb46b5e1468b4081377c">More...</a><br /></td></tr>
<tr class="separator:ac46e5cf28809fb46b5e1468b4081377c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7a98c044ea5b84612453b60b0b3850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7d7a98c044ea5b84612453b60b0b3850">on_stage_instance_create</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1stage__instance__create__t.html">stage_instance_create_t</a> &amp;_event)&gt; _stage_instance_create)</td></tr>
<tr class="memdesc:a7d7a98c044ea5b84612453b60b0b3850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new stage instance is created on a stage channel.  <a href="classdpp_1_1cluster.html#a7d7a98c044ea5b84612453b60b0b3850">More...</a><br /></td></tr>
<tr class="separator:a7d7a98c044ea5b84612453b60b0b3850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549c1e6b226996ce1b4fbd12bd369d18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a549c1e6b226996ce1b4fbd12bd369d18">detach_stage_instance_create</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _stage_instance_create)</td></tr>
<tr class="memdesc:a549c1e6b226996ce1b4fbd12bd369d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_stage_instance_create event.  <a href="classdpp_1_1cluster.html#a549c1e6b226996ce1b4fbd12bd369d18">More...</a><br /></td></tr>
<tr class="separator:a549c1e6b226996ce1b4fbd12bd369d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670c983ad24021e64c3efda9e937dd07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a670c983ad24021e64c3efda9e937dd07">on_stage_instance_update</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1stage__instance__update__t.html">stage_instance_update_t</a> &amp;_event)&gt; _stage_instance_update)</td></tr>
<tr class="memdesc:a670c983ad24021e64c3efda9e937dd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a stage instance is updated.  <a href="classdpp_1_1cluster.html#a670c983ad24021e64c3efda9e937dd07">More...</a><br /></td></tr>
<tr class="separator:a670c983ad24021e64c3efda9e937dd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a04dc288d0af562e7ce947df5877bce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8a04dc288d0af562e7ce947df5877bce">detach_stage_instance_update</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _stage_instance_update)</td></tr>
<tr class="memdesc:a8a04dc288d0af562e7ce947df5877bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_stage_instance_update event.  <a href="classdpp_1_1cluster.html#a8a04dc288d0af562e7ce947df5877bce">More...</a><br /></td></tr>
<tr class="separator:a8a04dc288d0af562e7ce947df5877bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e70453187414601a4e3593f5b99810c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1e70453187414601a4e3593f5b99810c">on_stage_instance_delete</a> (std::function&lt; void(const <a class="el" href="structdpp_1_1stage__instance__delete__t.html">stage_instance_delete_t</a> &amp;_event)&gt; _stage_instance_delete)</td></tr>
<tr class="memdesc:a1e70453187414601a4e3593f5b99810c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an existing stage instance is deleted from a stage channel.  <a href="classdpp_1_1cluster.html#a1e70453187414601a4e3593f5b99810c">More...</a><br /></td></tr>
<tr class="separator:a1e70453187414601a4e3593f5b99810c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9c5b7a912e92e4e4a6ad72df560625"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8a9c5b7a912e92e4e4a6ad72df560625">detach_stage_instance_delete</a> (const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> _stage_instance_delete)</td></tr>
<tr class="memdesc:a8a9c5b7a912e92e4e4a6ad72df560625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach listener from on_stage_instance_delete event.  <a href="classdpp_1_1cluster.html#a8a9c5b7a912e92e4e4a6ad72df560625">More...</a><br /></td></tr>
<tr class="separator:a8a9c5b7a912e92e4e4a6ad72df560625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b83ee3be02df68eb5e697ddc5efc0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a62b83ee3be02df68eb5e697ddc5efc0a">post_rest</a> (const std::string &amp;endpoint, const std::string &amp;major_parameters, const std::string &amp;parameters, <a class="el" href="namespacedpp.html#a805ef1feb2862a208ec0e9d1be005c88">http_method</a> method, const std::string &amp;postdata, <a class="el" href="namespacedpp.html#aafc7fb6792b12d92c4e77b46d20924ee">json_encode_t</a> callback, const std::string &amp;filename=&quot;&quot;, const std::string &amp;filecontent=&quot;&quot;)</td></tr>
<tr class="memdesc:a62b83ee3be02df68eb5e697ddc5efc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a REST request. Where possible use a helper method instead like message_create.  <a href="classdpp_1_1cluster.html#a62b83ee3be02df68eb5e697ddc5efc0a">More...</a><br /></td></tr>
<tr class="separator:a62b83ee3be02df68eb5e697ddc5efc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156fe68358c421111e690f553c4e4f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a156fe68358c421111e690f553c4e4f52">request</a> (const std::string &amp;url, <a class="el" href="namespacedpp.html#a805ef1feb2862a208ec0e9d1be005c88">http_method</a> method, <a class="el" href="namespacedpp.html#ae3249e99494d04bb4be50341f474621e">http_completion_event</a> callback, const std::string &amp;postdata=&quot;&quot;, const std::string &amp;mimetype=&quot;text/plain&quot;, const std::multimap&lt; std::string, std::string &gt; &amp;headers={})</td></tr>
<tr class="memdesc:a156fe68358c421111e690f553c4e4f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a HTTP(S) request. For use when wanting asnyncronous access to HTTP APIs outside of Discord.  <a href="classdpp_1_1cluster.html#a156fe68358c421111e690f553c4e4f52">More...</a><br /></td></tr>
<tr class="separator:a156fe68358c421111e690f553c4e4f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c92a68228fe9dcb96b1c7cb6b8ae795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4c92a68228fe9dcb96b1c7cb6b8ae795">interaction_response_create</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> interaction_id, const std::string &amp;<a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a>, const <a class="el" href="structdpp_1_1interaction__response.html">interaction_response</a> &amp;r, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a4c92a68228fe9dcb96b1c7cb6b8ae795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Respond to a slash command.  <a href="classdpp_1_1cluster.html#a4c92a68228fe9dcb96b1c7cb6b8ae795">More...</a><br /></td></tr>
<tr class="separator:a4c92a68228fe9dcb96b1c7cb6b8ae795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c9c18dd9185dfc2cc61b463ad7cf0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a41c9c18dd9185dfc2cc61b463ad7cf0f">interaction_response_edit</a> (const std::string &amp;<a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a>, const <a class="el" href="structdpp_1_1message.html">message</a> &amp;r, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a41c9c18dd9185dfc2cc61b463ad7cf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Respond to a slash command.  <a href="classdpp_1_1cluster.html#a41c9c18dd9185dfc2cc61b463ad7cf0f">More...</a><br /></td></tr>
<tr class="separator:a41c9c18dd9185dfc2cc61b463ad7cf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124b1a52ca2f5ae298f1bb99ca964dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a124b1a52ca2f5ae298f1bb99ca964dcb">global_command_create</a> (const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;s, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a124b1a52ca2f5ae298f1bb99ca964dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global slash command (a bot can have a maximum of 100 of these).  <a href="classdpp_1_1cluster.html#a124b1a52ca2f5ae298f1bb99ca964dcb">More...</a><br /></td></tr>
<tr class="separator:a124b1a52ca2f5ae298f1bb99ca964dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a61aa62ddf9207c197bfd496ae6ade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a74a61aa62ddf9207c197bfd496ae6ade">guild_auditlog_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a74a61aa62ddf9207c197bfd496ae6ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the audit log for a guild.  <a href="classdpp_1_1cluster.html#a74a61aa62ddf9207c197bfd496ae6ade">More...</a><br /></td></tr>
<tr class="separator:a74a61aa62ddf9207c197bfd496ae6ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0ce1ad5256a252ab0ce43923a07ae3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4c0ce1ad5256a252ab0ce43923a07ae3">guild_command_create</a> (const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;s, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a4c0ce1ad5256a252ab0ce43923a07ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slash command local to a guild.  <a href="classdpp_1_1cluster.html#a4c0ce1ad5256a252ab0ce43923a07ae3">More...</a><br /></td></tr>
<tr class="separator:a4c0ce1ad5256a252ab0ce43923a07ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aad2d123fe4d13cb880ff59d8048f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa7aad2d123fe4d13cb880ff59d8048f5">guild_bulk_command_create</a> (const std::vector&lt; <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &gt; &amp;commands, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa7aad2d123fe4d13cb880ff59d8048f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create/overwrite guild slash commands. Any existing guild slash commands on this guild will be deleted and replaced with these.  <a href="classdpp_1_1cluster.html#aa7aad2d123fe4d13cb880ff59d8048f5">More...</a><br /></td></tr>
<tr class="separator:aa7aad2d123fe4d13cb880ff59d8048f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2319ca200dcd5cce1b9b6696946ece22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2319ca200dcd5cce1b9b6696946ece22">global_bulk_command_create</a> (const std::vector&lt; <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &gt; &amp;commands, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a2319ca200dcd5cce1b9b6696946ece22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create/overwrite global slash commands. Any existing global slash commands will be deletd and replaced with these.  <a href="classdpp_1_1cluster.html#a2319ca200dcd5cce1b9b6696946ece22">More...</a><br /></td></tr>
<tr class="separator:a2319ca200dcd5cce1b9b6696946ece22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef037a47fee2efddedfe78ba4bf0467c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aef037a47fee2efddedfe78ba4bf0467c">global_command_edit</a> (const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;s, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aef037a47fee2efddedfe78ba4bf0467c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a global slash command (a bot can have a maximum of 100 of these)  <a href="classdpp_1_1cluster.html#aef037a47fee2efddedfe78ba4bf0467c">More...</a><br /></td></tr>
<tr class="separator:aef037a47fee2efddedfe78ba4bf0467c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d555ccc3e69298ccac9d160ce3a71bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4d555ccc3e69298ccac9d160ce3a71bf">guild_command_edit</a> (const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;s, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a4d555ccc3e69298ccac9d160ce3a71bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a slash command local to a guild.  <a href="classdpp_1_1cluster.html#a4d555ccc3e69298ccac9d160ce3a71bf">More...</a><br /></td></tr>
<tr class="separator:a4d555ccc3e69298ccac9d160ce3a71bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebb701d07c25d3667f0e1640670bbc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4ebb701d07c25d3667f0e1640670bbc1">guild_command_edit_permissions</a> (const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;s, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a4ebb701d07c25d3667f0e1640670bbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit slash command permissions local to a guild, permissions are read from s.permissions.  <a href="classdpp_1_1cluster.html#a4ebb701d07c25d3667f0e1640670bbc1">More...</a><br /></td></tr>
<tr class="separator:a4ebb701d07c25d3667f0e1640670bbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb7e2a8ddcb41a39d989802853a8605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7cb7e2a8ddcb41a39d989802853a8605">global_command_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a7cb7e2a8ddcb41a39d989802853a8605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a global slash command (a bot can have a maximum of 100 of these)  <a href="classdpp_1_1cluster.html#a7cb7e2a8ddcb41a39d989802853a8605">More...</a><br /></td></tr>
<tr class="separator:a7cb7e2a8ddcb41a39d989802853a8605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4a91a572c4e33ae60a3b09041ae3c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5b4a91a572c4e33ae60a3b09041ae3c2">guild_command_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a5b4a91a572c4e33ae60a3b09041ae3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a slash command local to a guild.  <a href="classdpp_1_1cluster.html#a5b4a91a572c4e33ae60a3b09041ae3c2">More...</a><br /></td></tr>
<tr class="separator:a5b4a91a572c4e33ae60a3b09041ae3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01623d7535dc359905990e710ae3b5e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a01623d7535dc359905990e710ae3b5e9">guild_commands_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a01623d7535dc359905990e710ae3b5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the application's slash commands for a guild.  <a href="classdpp_1_1cluster.html#a01623d7535dc359905990e710ae3b5e9">More...</a><br /></td></tr>
<tr class="separator:a01623d7535dc359905990e710ae3b5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8cadcdde42fcfa8d29c0c4fd0bec5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8a8cadcdde42fcfa8d29c0c4fd0bec5b">global_commands_get</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a8a8cadcdde42fcfa8d29c0c4fd0bec5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the application's global slash commands.  <a href="classdpp_1_1cluster.html#a8a8cadcdde42fcfa8d29c0c4fd0bec5b">More...</a><br /></td></tr>
<tr class="separator:a8a8cadcdde42fcfa8d29c0c4fd0bec5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a5e7d9ba9dcbfc1e219eeb029f61ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae3a5e7d9ba9dcbfc1e219eeb029f61ad">direct_message_create</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, const <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ae3a5e7d9ba9dcbfc1e219eeb029f61ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a direct message, also create the channel for the direct message if needed.  <a href="classdpp_1_1cluster.html#ae3a5e7d9ba9dcbfc1e219eeb029f61ad">More...</a><br /></td></tr>
<tr class="separator:ae3a5e7d9ba9dcbfc1e219eeb029f61ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3b0f7c3dae4ecb1980cabe8f10ccd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9d3b0f7c3dae4ecb1980cabe8f10ccd7">message_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a9d3b0f7c3dae4ecb1980cabe8f10ccd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a message.  <a href="classdpp_1_1cluster.html#a9d3b0f7c3dae4ecb1980cabe8f10ccd7">More...</a><br /></td></tr>
<tr class="separator:a9d3b0f7c3dae4ecb1980cabe8f10ccd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630d744322d1f570a63f33ae10b23ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a630d744322d1f570a63f33ae10b23ae9">messages_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> around, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> before, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> after, uint8_t limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a630d744322d1f570a63f33ae10b23ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multiple messages.  <a href="classdpp_1_1cluster.html#a630d744322d1f570a63f33ae10b23ae9">More...</a><br /></td></tr>
<tr class="separator:a630d744322d1f570a63f33ae10b23ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080a8cefc6ceb0b882fdb6fe70c078a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a080a8cefc6ceb0b882fdb6fe70c078a6">message_create</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a080a8cefc6ceb0b882fdb6fe70c078a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to a channel. The callback function is called when the message has been sent.  <a href="classdpp_1_1cluster.html#a080a8cefc6ceb0b882fdb6fe70c078a6">More...</a><br /></td></tr>
<tr class="separator:a080a8cefc6ceb0b882fdb6fe70c078a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdf2c55ac48902e7b194ab8e651d869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8cdf2c55ac48902e7b194ab8e651d869">message_crosspost</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a8cdf2c55ac48902e7b194ab8e651d869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crosspost a message. The callback function is called when the message has been sent.  <a href="classdpp_1_1cluster.html#a8cdf2c55ac48902e7b194ab8e651d869">More...</a><br /></td></tr>
<tr class="separator:a8cdf2c55ac48902e7b194ab8e651d869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754206a7e97f1aaab4ab83ed53e4f351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a754206a7e97f1aaab4ab83ed53e4f351">message_edit</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a754206a7e97f1aaab4ab83ed53e4f351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a message on a channel. The callback function is called when the message has been edited.  <a href="classdpp_1_1cluster.html#a754206a7e97f1aaab4ab83ed53e4f351">More...</a><br /></td></tr>
<tr class="separator:a754206a7e97f1aaab4ab83ed53e4f351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eb4e0352a29a92587d677d4b5fd6a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a08eb4e0352a29a92587d677d4b5fd6a7">message_add_reaction</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a08eb4e0352a29a92587d677d4b5fd6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a reaction to a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a08eb4e0352a29a92587d677d4b5fd6a7">More...</a><br /></td></tr>
<tr class="separator:a08eb4e0352a29a92587d677d4b5fd6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9abca51107d5aed147fa9b0aa8d675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aba9abca51107d5aed147fa9b0aa8d675">message_delete_own_reaction</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aba9abca51107d5aed147fa9b0aa8d675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete own reaction from a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#aba9abca51107d5aed147fa9b0aa8d675">More...</a><br /></td></tr>
<tr class="separator:aba9abca51107d5aed147fa9b0aa8d675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b04160e95d808013fe222a9b690dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a72b04160e95d808013fe222a9b690dae">message_delete_reaction</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a72b04160e95d808013fe222a9b690dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a user's reaction from a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a72b04160e95d808013fe222a9b690dae">More...</a><br /></td></tr>
<tr class="separator:a72b04160e95d808013fe222a9b690dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05fea3d6c298d5f2371704084383f8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab05fea3d6c298d5f2371704084383f8f">message_get_reactions</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> before, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> after, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ab05fea3d6c298d5f2371704084383f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reactions on a message for a particular emoji. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#ab05fea3d6c298d5f2371704084383f8f">More...</a><br /></td></tr>
<tr class="separator:ab05fea3d6c298d5f2371704084383f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ae40b4389928ce8e6f8d9b47512291"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a13ae40b4389928ce8e6f8d9b47512291">message_delete_all_reactions</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a13ae40b4389928ce8e6f8d9b47512291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all reactions on a message.  <a href="classdpp_1_1cluster.html#a13ae40b4389928ce8e6f8d9b47512291">More...</a><br /></td></tr>
<tr class="separator:a13ae40b4389928ce8e6f8d9b47512291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1478ca3f0fb3c645a34474099e4e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6a1478ca3f0fb3c645a34474099e4e04">message_delete_reaction_emoji</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a6a1478ca3f0fb3c645a34474099e4e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all reactions on a message using a particular emoji. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a6a1478ca3f0fb3c645a34474099e4e04">More...</a><br /></td></tr>
<tr class="separator:a6a1478ca3f0fb3c645a34474099e4e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c38aa5a7737577fbafcd67a783c60d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8c38aa5a7737577fbafcd67a783c60d1">message_add_reaction</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a8c38aa5a7737577fbafcd67a783c60d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a reaction to a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a8c38aa5a7737577fbafcd67a783c60d1">More...</a><br /></td></tr>
<tr class="separator:a8c38aa5a7737577fbafcd67a783c60d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b18295b9fc438b84c21cc5dd60db8db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3b18295b9fc438b84c21cc5dd60db8db">message_delete_own_reaction</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a3b18295b9fc438b84c21cc5dd60db8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete own reaction from a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a3b18295b9fc438b84c21cc5dd60db8db">More...</a><br /></td></tr>
<tr class="separator:a3b18295b9fc438b84c21cc5dd60db8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b157698d6c65e96a6a96ef93fee9f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0b157698d6c65e96a6a96ef93fee9f56">message_delete_reaction</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a0b157698d6c65e96a6a96ef93fee9f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a user's reaction from a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a0b157698d6c65e96a6a96ef93fee9f56">More...</a><br /></td></tr>
<tr class="separator:a0b157698d6c65e96a6a96ef93fee9f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06083a6cacaf7c4e41884cfb2a1078ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a06083a6cacaf7c4e41884cfb2a1078ab">message_get_reactions</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> before, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> after, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a06083a6cacaf7c4e41884cfb2a1078ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reactions on a message for a particular emoji by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a06083a6cacaf7c4e41884cfb2a1078ab">More...</a><br /></td></tr>
<tr class="separator:a06083a6cacaf7c4e41884cfb2a1078ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253f894d05325a56d85663a4759288a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a253f894d05325a56d85663a4759288a2">message_delete_all_reactions</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a253f894d05325a56d85663a4759288a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all reactions on a message by id.  <a href="classdpp_1_1cluster.html#a253f894d05325a56d85663a4759288a2">More...</a><br /></td></tr>
<tr class="separator:a253f894d05325a56d85663a4759288a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ffe65c0dda699e586f78c61649bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a144ffe65c0dda699e586f78c61649bf5">message_delete_reaction_emoji</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a144ffe65c0dda699e586f78c61649bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all reactions on a message using a particular emoji by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a144ffe65c0dda699e586f78c61649bf5">More...</a><br /></td></tr>
<tr class="separator:a144ffe65c0dda699e586f78c61649bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb75919ec5abd5b510255692ef439f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#abb75919ec5abd5b510255692ef439f97">message_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:abb75919ec5abd5b510255692ef439f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a message from a channel. The callback function is called when the message has been edited.  <a href="classdpp_1_1cluster.html#abb75919ec5abd5b510255692ef439f97">More...</a><br /></td></tr>
<tr class="separator:abb75919ec5abd5b510255692ef439f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4534c2c87bf45c326b126ef0a00ee80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab4534c2c87bf45c326b126ef0a00ee80">message_delete_bulk</a> (const std::vector&lt; <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> &gt; &amp;message_ids, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ab4534c2c87bf45c326b126ef0a00ee80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk delete messages from a channel. The callback function is called when the message has been edited.  <a href="classdpp_1_1cluster.html#ab4534c2c87bf45c326b126ef0a00ee80">More...</a><br /></td></tr>
<tr class="separator:ab4534c2c87bf45c326b126ef0a00ee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108f6f06b43709c8d47df5f94a3ca0a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a108f6f06b43709c8d47df5f94a3ca0a5">channel_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a108f6f06b43709c8d47df5f94a3ca0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a channel.  <a href="classdpp_1_1cluster.html#a108f6f06b43709c8d47df5f94a3ca0a5">More...</a><br /></td></tr>
<tr class="separator:a108f6f06b43709c8d47df5f94a3ca0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e67431b79cc2c3d0f12d59afd5a1c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a24e67431b79cc2c3d0f12d59afd5a1c8">channels_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a24e67431b79cc2c3d0f12d59afd5a1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all channels for a guild.  <a href="classdpp_1_1cluster.html#a24e67431b79cc2c3d0f12d59afd5a1c8">More...</a><br /></td></tr>
<tr class="separator:a24e67431b79cc2c3d0f12d59afd5a1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73706406e2f99b9a580319e389777be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad73706406e2f99b9a580319e389777be">channel_create</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad73706406e2f99b9a580319e389777be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a channel.  <a href="classdpp_1_1cluster.html#ad73706406e2f99b9a580319e389777be">More...</a><br /></td></tr>
<tr class="separator:ad73706406e2f99b9a580319e389777be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5511e31156dd2508387b1ba5a1612c09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5511e31156dd2508387b1ba5a1612c09">channel_edit</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a5511e31156dd2508387b1ba5a1612c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a channel.  <a href="classdpp_1_1cluster.html#a5511e31156dd2508387b1ba5a1612c09">More...</a><br /></td></tr>
<tr class="separator:a5511e31156dd2508387b1ba5a1612c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391779232600ba3a6f57d678047761b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a391779232600ba3a6f57d678047761b0">channel_edit_position</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a391779232600ba3a6f57d678047761b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a channel's position.  <a href="classdpp_1_1cluster.html#a391779232600ba3a6f57d678047761b0">More...</a><br /></td></tr>
<tr class="separator:a391779232600ba3a6f57d678047761b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb4457e63c60500b44bfdee27d80c75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#abfb4457e63c60500b44bfdee27d80c75">channel_edit_permissions</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> overwrite_id, uint32_t allow, uint32_t deny, bool member, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:abfb4457e63c60500b44bfdee27d80c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a channel's permissions.  <a href="classdpp_1_1cluster.html#abfb4457e63c60500b44bfdee27d80c75">More...</a><br /></td></tr>
<tr class="separator:abfb4457e63c60500b44bfdee27d80c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b00dafa69984d444422b500c3d18b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad3b00dafa69984d444422b500c3d18b3">channel_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad3b00dafa69984d444422b500c3d18b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a channel.  <a href="classdpp_1_1cluster.html#ad3b00dafa69984d444422b500c3d18b3">More...</a><br /></td></tr>
<tr class="separator:ad3b00dafa69984d444422b500c3d18b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d4220a93d6ba8c72d5472fd6718d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4a4d4220a93d6ba8c72d5472fd6718d0">invite_get</a> (const std::string &amp;<a class="el" href="classdpp_1_1invite.html">invite</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a4a4d4220a93d6ba8c72d5472fd6718d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get details about an invite.  <a href="classdpp_1_1cluster.html#a4a4d4220a93d6ba8c72d5472fd6718d0">More...</a><br /></td></tr>
<tr class="separator:a4a4d4220a93d6ba8c72d5472fd6718d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c22698fbbb32edebd9824309015a017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4c22698fbbb32edebd9824309015a017">invite_delete</a> (const std::string &amp;<a class="el" href="classdpp_1_1invite.html">invite</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a4c22698fbbb32edebd9824309015a017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an invite.  <a href="classdpp_1_1cluster.html#a4c22698fbbb32edebd9824309015a017">More...</a><br /></td></tr>
<tr class="separator:a4c22698fbbb32edebd9824309015a017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03a0da5c8e6801dc56bda258265da04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa03a0da5c8e6801dc56bda258265da04">channel_invites_get</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:aa03a0da5c8e6801dc56bda258265da04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get invites for a channel.  <a href="classdpp_1_1cluster.html#aa03a0da5c8e6801dc56bda258265da04">More...</a><br /></td></tr>
<tr class="separator:aa03a0da5c8e6801dc56bda258265da04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e66a7400101f466aab40ed58c67942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a07e66a7400101f466aab40ed58c67942">channel_invite_create</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, const class <a class="el" href="classdpp_1_1invite.html">invite</a> &amp;i, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a07e66a7400101f466aab40ed58c67942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create invite for a channel.  <a href="classdpp_1_1cluster.html#a07e66a7400101f466aab40ed58c67942">More...</a><br /></td></tr>
<tr class="separator:a07e66a7400101f466aab40ed58c67942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553bfda3b4f1671e75c5713275b781bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a553bfda3b4f1671e75c5713275b781bd">channel_pins_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a553bfda3b4f1671e75c5713275b781bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a channel's pins.  <a href="classdpp_1_1cluster.html#a553bfda3b4f1671e75c5713275b781bd">More...</a><br /></td></tr>
<tr class="separator:a553bfda3b4f1671e75c5713275b781bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad36637b9bb094d9f24d18f204138a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9ad36637b9bb094d9f24d18f204138a3">gdm_add</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, const std::string &amp;access_token, const std::string &amp;nick, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a9ad36637b9bb094d9f24d18f204138a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a recipient to a Group DM using their access token.  <a href="classdpp_1_1cluster.html#a9ad36637b9bb094d9f24d18f204138a3">More...</a><br /></td></tr>
<tr class="separator:a9ad36637b9bb094d9f24d18f204138a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be231a13131f6fae94f88ee6fcdc5f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6be231a13131f6fae94f88ee6fcdc5f0">gdm_remove</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a6be231a13131f6fae94f88ee6fcdc5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a recipient from a Group DM.  <a href="classdpp_1_1cluster.html#a6be231a13131f6fae94f88ee6fcdc5f0">More...</a><br /></td></tr>
<tr class="separator:a6be231a13131f6fae94f88ee6fcdc5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fce9638b93c6b5d5d67f8bea9f8f6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa2fce9638b93c6b5d5d67f8bea9f8f6c">channel_delete_permission</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> overwrite_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa2fce9638b93c6b5d5d67f8bea9f8f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a permission from a channel.  <a href="classdpp_1_1cluster.html#aa2fce9638b93c6b5d5d67f8bea9f8f6c">More...</a><br /></td></tr>
<tr class="separator:aa2fce9638b93c6b5d5d67f8bea9f8f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7593e4ba82977bf3d8ad9052c9c565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1b7593e4ba82977bf3d8ad9052c9c565">channel_follow_news</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> target_channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a1b7593e4ba82977bf3d8ad9052c9c565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Follow a news channel.  <a href="classdpp_1_1cluster.html#a1b7593e4ba82977bf3d8ad9052c9c565">More...</a><br /></td></tr>
<tr class="separator:a1b7593e4ba82977bf3d8ad9052c9c565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caf58e161373fd3fa26172a4a78c835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2caf58e161373fd3fa26172a4a78c835">channel_typing</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a2caf58e161373fd3fa26172a4a78c835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger channel typing indicator.  <a href="classdpp_1_1cluster.html#a2caf58e161373fd3fa26172a4a78c835">More...</a><br /></td></tr>
<tr class="separator:a2caf58e161373fd3fa26172a4a78c835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80ac0e99c0a20c9c05678631189b8f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad80ac0e99c0a20c9c05678631189b8f3">channel_typing</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> cid, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad80ac0e99c0a20c9c05678631189b8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger channel typing indicator.  <a href="classdpp_1_1cluster.html#ad80ac0e99c0a20c9c05678631189b8f3">More...</a><br /></td></tr>
<tr class="separator:ad80ac0e99c0a20c9c05678631189b8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa140a11ab0b2feede600761aaee2483b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa140a11ab0b2feede600761aaee2483b">message_pin</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa140a11ab0b2feede600761aaee2483b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pin a message.  <a href="classdpp_1_1cluster.html#aa140a11ab0b2feede600761aaee2483b">More...</a><br /></td></tr>
<tr class="separator:aa140a11ab0b2feede600761aaee2483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454e53cea10416ca9d299855dbb08e0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a454e53cea10416ca9d299855dbb08e0b">message_unpin</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a454e53cea10416ca9d299855dbb08e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpin a message.  <a href="classdpp_1_1cluster.html#a454e53cea10416ca9d299855dbb08e0b">More...</a><br /></td></tr>
<tr class="separator:a454e53cea10416ca9d299855dbb08e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a003669770549d25a951810bff0153e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6a003669770549d25a951810bff0153e">guild_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> g, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a6a003669770549d25a951810bff0153e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a guild.  <a href="classdpp_1_1cluster.html#a6a003669770549d25a951810bff0153e">More...</a><br /></td></tr>
<tr class="separator:a6a003669770549d25a951810bff0153e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecd82c6169107c9c944356f19abba9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3ecd82c6169107c9c944356f19abba9e">guild_get_preview</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> g, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a3ecd82c6169107c9c944356f19abba9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a guild preview. Returns a guild object but only a subset of the fields will be populated.  <a href="classdpp_1_1cluster.html#a3ecd82c6169107c9c944356f19abba9e">More...</a><br /></td></tr>
<tr class="separator:a3ecd82c6169107c9c944356f19abba9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e8227f11ef33cd2d9cc3abef46adfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a99e8227f11ef33cd2d9cc3abef46adfd">guild_get_member</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a99e8227f11ef33cd2d9cc3abef46adfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a guild member.  <a href="classdpp_1_1cluster.html#a99e8227f11ef33cd2d9cc3abef46adfd">More...</a><br /></td></tr>
<tr class="separator:a99e8227f11ef33cd2d9cc3abef46adfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cc92ce052d063854e0372539e4d9ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a52cc92ce052d063854e0372539e4d9ee">guild_search_members</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;query, uint16_t limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a52cc92ce052d063854e0372539e4d9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for guild members based on whether their username or nickname starts with the given string.  <a href="classdpp_1_1cluster.html#a52cc92ce052d063854e0372539e4d9ee">More...</a><br /></td></tr>
<tr class="separator:a52cc92ce052d063854e0372539e4d9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b24baba4de9d38f7d9a7cea2f71a545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6b24baba4de9d38f7d9a7cea2f71a545">guild_get_members</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, uint16_t limit, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> after, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a6b24baba4de9d38f7d9a7cea2f71a545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all guild members.  <a href="classdpp_1_1cluster.html#a6b24baba4de9d38f7d9a7cea2f71a545">More...</a><br /></td></tr>
<tr class="separator:a6b24baba4de9d38f7d9a7cea2f71a545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2937f10828bc3fbdeff87fc6b4463cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa2937f10828bc3fbdeff87fc6b4463cc">guild_add_member</a> (const <a class="el" href="classdpp_1_1guild__member.html">guild_member</a> &amp;gm, const std::string &amp;access_token, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa2937f10828bc3fbdeff87fc6b4463cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add guild member. Needs a specific oauth2 scope, from which you get the access_token.  <a href="classdpp_1_1cluster.html#aa2937f10828bc3fbdeff87fc6b4463cc">More...</a><br /></td></tr>
<tr class="separator:aa2937f10828bc3fbdeff87fc6b4463cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a1957b81c9606850e730c477dd44aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a57a1957b81c9606850e730c477dd44aa">guild_edit_member</a> (const <a class="el" href="classdpp_1_1guild__member.html">guild_member</a> &amp;gm, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a57a1957b81c9606850e730c477dd44aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit the properties of an existing guild member.  <a href="classdpp_1_1cluster.html#a57a1957b81c9606850e730c477dd44aa">More...</a><br /></td></tr>
<tr class="separator:a57a1957b81c9606850e730c477dd44aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40665f55528cfc1077b8adcae2d49086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a40665f55528cfc1077b8adcae2d49086">guild_member_move</a> (const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a40665f55528cfc1077b8adcae2d49086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the guild member to a other voice channel, if member is connected to one.  <a href="classdpp_1_1cluster.html#a40665f55528cfc1077b8adcae2d49086">More...</a><br /></td></tr>
<tr class="separator:a40665f55528cfc1077b8adcae2d49086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30ff4f80815720bafab51f9bc86b089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa30ff4f80815720bafab51f9bc86b089">guild_set_nickname</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;nickname, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa30ff4f80815720bafab51f9bc86b089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change current user nickname.  <a href="classdpp_1_1cluster.html#aa30ff4f80815720bafab51f9bc86b089">More...</a><br /></td></tr>
<tr class="separator:aa30ff4f80815720bafab51f9bc86b089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dcac8996e5eaad9b1eed9983ecefef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa9dcac8996e5eaad9b1eed9983ecefef">guild_member_add_role</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> role_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa9dcac8996e5eaad9b1eed9983ecefef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add role to guild member.  <a href="classdpp_1_1cluster.html#aa9dcac8996e5eaad9b1eed9983ecefef">More...</a><br /></td></tr>
<tr class="separator:aa9dcac8996e5eaad9b1eed9983ecefef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0289849ef90572a331e68fc84075cb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af0289849ef90572a331e68fc84075cb2">guild_member_delete_role</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> role_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:af0289849ef90572a331e68fc84075cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove role from guild member.  <a href="classdpp_1_1cluster.html#af0289849ef90572a331e68fc84075cb2">More...</a><br /></td></tr>
<tr class="separator:af0289849ef90572a331e68fc84075cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58be46d2934738b32229d984c266a4b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a58be46d2934738b32229d984c266a4b7">guild_member_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a58be46d2934738b32229d984c266a4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove (kick) a guild member.  <a href="classdpp_1_1cluster.html#a58be46d2934738b32229d984c266a4b7">More...</a><br /></td></tr>
<tr class="separator:a58be46d2934738b32229d984c266a4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2273fdee237880d5e6b948198ffae52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad2273fdee237880d5e6b948198ffae52">guild_ban_add</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, uint32_t delete_message_days, const std::string &amp;reason, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad2273fdee237880d5e6b948198ffae52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add guild ban.  <a href="classdpp_1_1cluster.html#ad2273fdee237880d5e6b948198ffae52">More...</a><br /></td></tr>
<tr class="separator:ad2273fdee237880d5e6b948198ffae52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f31527cd6b99cf2757e6c14dac5e5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a18f31527cd6b99cf2757e6c14dac5e5b">guild_ban_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a18f31527cd6b99cf2757e6c14dac5e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete guild ban.  <a href="classdpp_1_1cluster.html#a18f31527cd6b99cf2757e6c14dac5e5b">More...</a><br /></td></tr>
<tr class="separator:a18f31527cd6b99cf2757e6c14dac5e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fffa4f080e0b5abab1417fa8eb1b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af9fffa4f080e0b5abab1417fa8eb1b0f">guild_get_bans</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:af9fffa4f080e0b5abab1417fa8eb1b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild ban list.  <a href="classdpp_1_1cluster.html#af9fffa4f080e0b5abab1417fa8eb1b0f">More...</a><br /></td></tr>
<tr class="separator:af9fffa4f080e0b5abab1417fa8eb1b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad871d30ed11d0799da4a831ede8a7d95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad871d30ed11d0799da4a831ede8a7d95">guild_get_ban</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ad871d30ed11d0799da4a831ede8a7d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get single guild ban.  <a href="classdpp_1_1cluster.html#ad871d30ed11d0799da4a831ede8a7d95">More...</a><br /></td></tr>
<tr class="separator:ad871d30ed11d0799da4a831ede8a7d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52366e37144b166c6a2c773e14992b21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a52366e37144b166c6a2c773e14992b21">template_get</a> (const std::string &amp;code, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a52366e37144b166c6a2c773e14992b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a template.  <a href="classdpp_1_1cluster.html#a52366e37144b166c6a2c773e14992b21">More...</a><br /></td></tr>
<tr class="separator:a52366e37144b166c6a2c773e14992b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad277277c10ccdaecc3869a23d9ecb94b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad277277c10ccdaecc3869a23d9ecb94b">guild_create_from_template</a> (const std::string &amp;code, const std::string &amp;name, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad277277c10ccdaecc3869a23d9ecb94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new guild based on a template.  <a href="classdpp_1_1cluster.html#ad277277c10ccdaecc3869a23d9ecb94b">More...</a><br /></td></tr>
<tr class="separator:ad277277c10ccdaecc3869a23d9ecb94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faa321ede15b209c789ea1155a3d356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1faa321ede15b209c789ea1155a3d356">guild_templates_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a1faa321ede15b209c789ea1155a3d356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild templates.  <a href="classdpp_1_1cluster.html#a1faa321ede15b209c789ea1155a3d356">More...</a><br /></td></tr>
<tr class="separator:a1faa321ede15b209c789ea1155a3d356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38db2ce96431b742e98cabf8170a84d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a38db2ce96431b742e98cabf8170a84d7">guild_template_create</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;name, const std::string &amp;description, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a38db2ce96431b742e98cabf8170a84d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a template for the guild.  <a href="classdpp_1_1cluster.html#a38db2ce96431b742e98cabf8170a84d7">More...</a><br /></td></tr>
<tr class="separator:a38db2ce96431b742e98cabf8170a84d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc2ed8ec7e7550daa418f693ade1016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3fc2ed8ec7e7550daa418f693ade1016">guild_template_sync</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;code, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a3fc2ed8ec7e7550daa418f693ade1016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syncs the template to the guild's current state.  <a href="classdpp_1_1cluster.html#a3fc2ed8ec7e7550daa418f693ade1016">More...</a><br /></td></tr>
<tr class="separator:a3fc2ed8ec7e7550daa418f693ade1016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f9702b44025f54cf03920d3a3e554b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a22f9702b44025f54cf03920d3a3e554b">guild_template_modify</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;code, const std::string &amp;name, const std::string &amp;description, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a22f9702b44025f54cf03920d3a3e554b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the template's metadata.  <a href="classdpp_1_1cluster.html#a22f9702b44025f54cf03920d3a3e554b">More...</a><br /></td></tr>
<tr class="separator:a22f9702b44025f54cf03920d3a3e554b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91791a9d280c0973834223df37d39ac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a91791a9d280c0973834223df37d39ac8">guild_template_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;code, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a91791a9d280c0973834223df37d39ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the template.  <a href="classdpp_1_1cluster.html#a91791a9d280c0973834223df37d39ac8">More...</a><br /></td></tr>
<tr class="separator:a91791a9d280c0973834223df37d39ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af327d6e65c703ce001d666ef2adc4b25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af327d6e65c703ce001d666ef2adc4b25">guild_create</a> (const class <a class="el" href="classdpp_1_1guild.html">guild</a> &amp;g, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:af327d6e65c703ce001d666ef2adc4b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a guild.  <a href="classdpp_1_1cluster.html#af327d6e65c703ce001d666ef2adc4b25">More...</a><br /></td></tr>
<tr class="separator:af327d6e65c703ce001d666ef2adc4b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0ce3857773519ca2ed62b49c04f267"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5b0ce3857773519ca2ed62b49c04f267">guild_edit</a> (const class <a class="el" href="classdpp_1_1guild.html">guild</a> &amp;g, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a5b0ce3857773519ca2ed62b49c04f267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a guild.  <a href="classdpp_1_1cluster.html#a5b0ce3857773519ca2ed62b49c04f267">More...</a><br /></td></tr>
<tr class="separator:a5b0ce3857773519ca2ed62b49c04f267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a78935110be8ea8bf5fdc4f0734fd28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8a78935110be8ea8bf5fdc4f0734fd28">guild_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a8a78935110be8ea8bf5fdc4f0734fd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a guild.  <a href="classdpp_1_1cluster.html#a8a78935110be8ea8bf5fdc4f0734fd28">More...</a><br /></td></tr>
<tr class="separator:a8a78935110be8ea8bf5fdc4f0734fd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66ab98a72eb1ba8d2686fcaa1eb49db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad66ab98a72eb1ba8d2686fcaa1eb49db">guild_emojis_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ad66ab98a72eb1ba8d2686fcaa1eb49db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all emojis for a guild.  <a href="classdpp_1_1cluster.html#ad66ab98a72eb1ba8d2686fcaa1eb49db">More...</a><br /></td></tr>
<tr class="separator:ad66ab98a72eb1ba8d2686fcaa1eb49db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada721a222fb3a42a1a1bb6d93dfcc745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ada721a222fb3a42a1a1bb6d93dfcc745">guild_emoji_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> emoji_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ada721a222fb3a42a1a1bb6d93dfcc745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single emoji.  <a href="classdpp_1_1cluster.html#ada721a222fb3a42a1a1bb6d93dfcc745">More...</a><br /></td></tr>
<tr class="separator:ada721a222fb3a42a1a1bb6d93dfcc745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6d9dbdb2009bdea2fad46e93813af5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5f6d9dbdb2009bdea2fad46e93813af5">guild_emoji_create</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const class <a class="el" href="classdpp_1_1emoji.html">emoji</a> &amp;newemoji, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a5f6d9dbdb2009bdea2fad46e93813af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create single emoji. You must ensure that the emoji passed contained image data using the <a class="el" href="classdpp_1_1emoji.html#a33694c119238d58da105c55fdf9dbcd9" title="Load an image into the object as base64.">emoji::load_image()</a> method.  <a href="classdpp_1_1cluster.html#a5f6d9dbdb2009bdea2fad46e93813af5">More...</a><br /></td></tr>
<tr class="separator:a5f6d9dbdb2009bdea2fad46e93813af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4bf8c1767b71ed06bfa407341096d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2c4bf8c1767b71ed06bfa407341096d4">guild_emoji_edit</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const class <a class="el" href="classdpp_1_1emoji.html">emoji</a> &amp;newemoji, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a2c4bf8c1767b71ed06bfa407341096d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a single emoji. You must ensure that the emoji passed contained image data using the <a class="el" href="classdpp_1_1emoji.html#a33694c119238d58da105c55fdf9dbcd9" title="Load an image into the object as base64.">emoji::load_image()</a> method.  <a href="classdpp_1_1cluster.html#a2c4bf8c1767b71ed06bfa407341096d4">More...</a><br /></td></tr>
<tr class="separator:a2c4bf8c1767b71ed06bfa407341096d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c8f4357998bc8a77e8561edcb738c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af9c8f4357998bc8a77e8561edcb738c3">guild_emoji_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> emoji_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:af9c8f4357998bc8a77e8561edcb738c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a guild emoji.  <a href="classdpp_1_1cluster.html#af9c8f4357998bc8a77e8561edcb738c3">More...</a><br /></td></tr>
<tr class="separator:af9c8f4357998bc8a77e8561edcb738c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad296f07bd5b9f900dcedbf88c464e09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aad296f07bd5b9f900dcedbf88c464e09">guild_get_prune_counts</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const struct <a class="el" href="structdpp_1_1prune.html">prune</a> &amp;pruneinfo, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:aad296f07bd5b9f900dcedbf88c464e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get prune counts.  <a href="classdpp_1_1cluster.html#aad296f07bd5b9f900dcedbf88c464e09">More...</a><br /></td></tr>
<tr class="separator:aad296f07bd5b9f900dcedbf88c464e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2102835f11fabbc2cd2e6b41155783f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2102835f11fabbc2cd2e6b41155783f6">guild_begin_prune</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const struct <a class="el" href="structdpp_1_1prune.html">prune</a> &amp;pruneinfo, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a2102835f11fabbc2cd2e6b41155783f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin guild prune.  <a href="classdpp_1_1cluster.html#a2102835f11fabbc2cd2e6b41155783f6">More...</a><br /></td></tr>
<tr class="separator:a2102835f11fabbc2cd2e6b41155783f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5556385a69a408a268332f774ba6c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae5556385a69a408a268332f774ba6c3c">guild_get_voice_regions</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ae5556385a69a408a268332f774ba6c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild voice regions. Voice regions per guild are somewhat deprecated in preference of per-channel voice regions.  <a href="classdpp_1_1cluster.html#ae5556385a69a408a268332f774ba6c3c">More...</a><br /></td></tr>
<tr class="separator:ae5556385a69a408a268332f774ba6c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c0e07243611419141305da123c859a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a93c0e07243611419141305da123c859a">guild_get_invites</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a93c0e07243611419141305da123c859a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild invites.  <a href="classdpp_1_1cluster.html#a93c0e07243611419141305da123c859a">More...</a><br /></td></tr>
<tr class="separator:a93c0e07243611419141305da123c859a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cba3bd187f9b28dcaed5b4f4ed5bda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a43cba3bd187f9b28dcaed5b4f4ed5bda">guild_get_integrations</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a43cba3bd187f9b28dcaed5b4f4ed5bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild itegrations.  <a href="classdpp_1_1cluster.html#a43cba3bd187f9b28dcaed5b4f4ed5bda">More...</a><br /></td></tr>
<tr class="separator:a43cba3bd187f9b28dcaed5b4f4ed5bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb07fc90589ee936f73da5551cff1255"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#afb07fc90589ee936f73da5551cff1255">guild_modify_integration</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const class <a class="el" href="classdpp_1_1integration.html">integration</a> &amp;i, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:afb07fc90589ee936f73da5551cff1255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify guild integration.  <a href="classdpp_1_1cluster.html#afb07fc90589ee936f73da5551cff1255">More...</a><br /></td></tr>
<tr class="separator:afb07fc90589ee936f73da5551cff1255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db4a48d1ebc2133c30963a995e156e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0db4a48d1ebc2133c30963a995e156e1">guild_delete_integration</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> integration_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a0db4a48d1ebc2133c30963a995e156e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete guild integration.  <a href="classdpp_1_1cluster.html#a0db4a48d1ebc2133c30963a995e156e1">More...</a><br /></td></tr>
<tr class="separator:a0db4a48d1ebc2133c30963a995e156e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d976f9d101225e05482db7b739f986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a58d976f9d101225e05482db7b739f986">guild_sync_integration</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> integration_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a58d976f9d101225e05482db7b739f986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync guild integration.  <a href="classdpp_1_1cluster.html#a58d976f9d101225e05482db7b739f986">More...</a><br /></td></tr>
<tr class="separator:a58d976f9d101225e05482db7b739f986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57626c7a0e06aee1c362b986e44030c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a57626c7a0e06aee1c362b986e44030c2">guild_get_widget</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a57626c7a0e06aee1c362b986e44030c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild widget.  <a href="classdpp_1_1cluster.html#a57626c7a0e06aee1c362b986e44030c2">More...</a><br /></td></tr>
<tr class="separator:a57626c7a0e06aee1c362b986e44030c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb37eaa792a69f43171f580695fd4520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#afb37eaa792a69f43171f580695fd4520">guild_edit_widget</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const class <a class="el" href="classdpp_1_1guild__widget.html">guild_widget</a> &amp;gw, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:afb37eaa792a69f43171f580695fd4520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit guild widget.  <a href="classdpp_1_1cluster.html#afb37eaa792a69f43171f580695fd4520">More...</a><br /></td></tr>
<tr class="separator:afb37eaa792a69f43171f580695fd4520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1332e45cc89e871009e840c25145df5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad1332e45cc89e871009e840c25145df5">guild_get_vanity</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ad1332e45cc89e871009e840c25145df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild vanity url, if enabled.  <a href="classdpp_1_1cluster.html#ad1332e45cc89e871009e840c25145df5">More...</a><br /></td></tr>
<tr class="separator:ad1332e45cc89e871009e840c25145df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627510bf4f4d1c3a999ccb506c75ec47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a627510bf4f4d1c3a999ccb506c75ec47">create_webhook</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;w, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a627510bf4f4d1c3a999ccb506c75ec47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a webhook.  <a href="classdpp_1_1cluster.html#a627510bf4f4d1c3a999ccb506c75ec47">More...</a><br /></td></tr>
<tr class="separator:a627510bf4f4d1c3a999ccb506c75ec47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d352afcbc0430ca11576386278da7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8d352afcbc0430ca11576386278da7d0">get_guild_webhooks</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a8d352afcbc0430ca11576386278da7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild webhooks.  <a href="classdpp_1_1cluster.html#a8d352afcbc0430ca11576386278da7d0">More...</a><br /></td></tr>
<tr class="separator:a8d352afcbc0430ca11576386278da7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58b1f27711b42e9aa8a21e34147429f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae58b1f27711b42e9aa8a21e34147429f">get_channel_webhooks</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ae58b1f27711b42e9aa8a21e34147429f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get channel webhooks.  <a href="classdpp_1_1cluster.html#ae58b1f27711b42e9aa8a21e34147429f">More...</a><br /></td></tr>
<tr class="separator:ae58b1f27711b42e9aa8a21e34147429f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e140f1e2eda9632828bce461bc7338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a40e140f1e2eda9632828bce461bc7338">get_webhook</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> webhook_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a40e140f1e2eda9632828bce461bc7338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get webhook.  <a href="classdpp_1_1cluster.html#a40e140f1e2eda9632828bce461bc7338">More...</a><br /></td></tr>
<tr class="separator:a40e140f1e2eda9632828bce461bc7338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770526895ed13e2dfb746decc3f0be67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a770526895ed13e2dfb746decc3f0be67">get_webhook_with_token</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> webhook_id, const std::string &amp;<a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a770526895ed13e2dfb746decc3f0be67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get webhook using token.  <a href="classdpp_1_1cluster.html#a770526895ed13e2dfb746decc3f0be67">More...</a><br /></td></tr>
<tr class="separator:a770526895ed13e2dfb746decc3f0be67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af319c151f1b9b2b578d9303bab7ce5d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af319c151f1b9b2b578d9303bab7ce5d0">edit_webhook</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:af319c151f1b9b2b578d9303bab7ce5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit webhook.  <a href="classdpp_1_1cluster.html#af319c151f1b9b2b578d9303bab7ce5d0">More...</a><br /></td></tr>
<tr class="separator:af319c151f1b9b2b578d9303bab7ce5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bffc1fa43d6a78814f9ca0f378755c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2bffc1fa43d6a78814f9ca0f378755c5">edit_webhook_with_token</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a2bffc1fa43d6a78814f9ca0f378755c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit webhook with token (token is encapsulated in the webhook object)  <a href="classdpp_1_1cluster.html#a2bffc1fa43d6a78814f9ca0f378755c5">More...</a><br /></td></tr>
<tr class="separator:a2bffc1fa43d6a78814f9ca0f378755c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee76e0048ec1cd35420da1bfc5317646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aee76e0048ec1cd35420da1bfc5317646">delete_webhook</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> webhook_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aee76e0048ec1cd35420da1bfc5317646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a webhook.  <a href="classdpp_1_1cluster.html#aee76e0048ec1cd35420da1bfc5317646">More...</a><br /></td></tr>
<tr class="separator:aee76e0048ec1cd35420da1bfc5317646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae790b70aaecd9c42fe8a64c4c71a3d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae790b70aaecd9c42fe8a64c4c71a3d0c">delete_webhook_with_token</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> webhook_id, const std::string &amp;<a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ae790b70aaecd9c42fe8a64c4c71a3d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete webhook with token.  <a href="classdpp_1_1cluster.html#ae790b70aaecd9c42fe8a64c4c71a3d0c">More...</a><br /></td></tr>
<tr class="separator:ae790b70aaecd9c42fe8a64c4c71a3d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e83314cede8b9277a01b7b173abbad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad5e83314cede8b9277a01b7b173abbad">execute_webhook</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, bool wait=false, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id=0, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad5e83314cede8b9277a01b7b173abbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute webhook.  <a href="classdpp_1_1cluster.html#ad5e83314cede8b9277a01b7b173abbad">More...</a><br /></td></tr>
<tr class="separator:ad5e83314cede8b9277a01b7b173abbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8685b3bd821ab87342670d730689191e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8685b3bd821ab87342670d730689191e">get_webhook_message</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a8685b3bd821ab87342670d730689191e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get webhook message.  <a href="classdpp_1_1cluster.html#a8685b3bd821ab87342670d730689191e">More...</a><br /></td></tr>
<tr class="separator:a8685b3bd821ab87342670d730689191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a37684f9d12edd4ca7d00296a5443b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a86a37684f9d12edd4ca7d00296a5443b">edit_webhook_message</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a86a37684f9d12edd4ca7d00296a5443b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit webhook message.  <a href="classdpp_1_1cluster.html#a86a37684f9d12edd4ca7d00296a5443b">More...</a><br /></td></tr>
<tr class="separator:a86a37684f9d12edd4ca7d00296a5443b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e937f48e410469c90f37368afa4cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae6e937f48e410469c90f37368afa4cbe">delete_webhook_message</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ae6e937f48e410469c90f37368afa4cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete webhook message.  <a href="classdpp_1_1cluster.html#ae6e937f48e410469c90f37368afa4cbe">More...</a><br /></td></tr>
<tr class="separator:ae6e937f48e410469c90f37368afa4cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884dbb70619fcf92b06577dea8093219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a884dbb70619fcf92b06577dea8093219">roles_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a884dbb70619fcf92b06577dea8093219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a role for a guild.  <a href="classdpp_1_1cluster.html#a884dbb70619fcf92b06577dea8093219">More...</a><br /></td></tr>
<tr class="separator:a884dbb70619fcf92b06577dea8093219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab912eb28e9bb4df46954c7a9b93b283d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab912eb28e9bb4df46954c7a9b93b283d">role_create</a> (const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;r, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ab912eb28e9bb4df46954c7a9b93b283d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a role on a guild.  <a href="classdpp_1_1cluster.html#ab912eb28e9bb4df46954c7a9b93b283d">More...</a><br /></td></tr>
<tr class="separator:ab912eb28e9bb4df46954c7a9b93b283d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cc5286955e6641d574d232d8b47f55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a24cc5286955e6641d574d232d8b47f55">role_edit</a> (const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;r, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a24cc5286955e6641d574d232d8b47f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a role on a guild.  <a href="classdpp_1_1cluster.html#a24cc5286955e6641d574d232d8b47f55">More...</a><br /></td></tr>
<tr class="separator:a24cc5286955e6641d574d232d8b47f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77932ee797aeb44098c2013811b2887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac77932ee797aeb44098c2013811b2887">role_edit_position</a> (const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;r, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ac77932ee797aeb44098c2013811b2887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a role's position in a guild.  <a href="classdpp_1_1cluster.html#ac77932ee797aeb44098c2013811b2887">More...</a><br /></td></tr>
<tr class="separator:ac77932ee797aeb44098c2013811b2887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45414d0d189edd147c3d76b4480ec0b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a45414d0d189edd147c3d76b4480ec0b8">role_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> role_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a45414d0d189edd147c3d76b4480ec0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a role.  <a href="classdpp_1_1cluster.html#a45414d0d189edd147c3d76b4480ec0b8">More...</a><br /></td></tr>
<tr class="separator:a45414d0d189edd147c3d76b4480ec0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73483dbeb0f1946dc18b1d0a5331b0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a73483dbeb0f1946dc18b1d0a5331b0d0">user_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a73483dbeb0f1946dc18b1d0a5331b0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a user by id.  <a href="classdpp_1_1cluster.html#a73483dbeb0f1946dc18b1d0a5331b0d0">More...</a><br /></td></tr>
<tr class="separator:a73483dbeb0f1946dc18b1d0a5331b0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad927e85ed6b99e9b05f4190f1b19cae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aad927e85ed6b99e9b05f4190f1b19cae">current_user_get</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:aad927e85ed6b99e9b05f4190f1b19cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current (bot) user.  <a href="classdpp_1_1cluster.html#aad927e85ed6b99e9b05f4190f1b19cae">More...</a><br /></td></tr>
<tr class="separator:aad927e85ed6b99e9b05f4190f1b19cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc39069aaaa492727f39b35edd957e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac3dc39069aaaa492727f39b35edd957e">current_application_get</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ac3dc39069aaaa492727f39b35edd957e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current (bot) application.  <a href="classdpp_1_1cluster.html#ac3dc39069aaaa492727f39b35edd957e">More...</a><br /></td></tr>
<tr class="separator:ac3dc39069aaaa492727f39b35edd957e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e1e5dd813d36fffd6b532ed1b31178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a75e1e5dd813d36fffd6b532ed1b31178">current_user_connections_get</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a75e1e5dd813d36fffd6b532ed1b31178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current user's connections (linked accounts, e.g. steam, xbox). This call requires the oauth2 <code>connections</code> scope and cannot be executed against a bot token.  <a href="classdpp_1_1cluster.html#a75e1e5dd813d36fffd6b532ed1b31178">More...</a><br /></td></tr>
<tr class="separator:a75e1e5dd813d36fffd6b532ed1b31178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c8fd5f22e0eae6bf357ad498b43f87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a93c8fd5f22e0eae6bf357ad498b43f87">current_user_get_guilds</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a93c8fd5f22e0eae6bf357ad498b43f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current (bot) user guilds.  <a href="classdpp_1_1cluster.html#a93c8fd5f22e0eae6bf357ad498b43f87">More...</a><br /></td></tr>
<tr class="separator:a93c8fd5f22e0eae6bf357ad498b43f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4db23ebdf9a8323bd54458dadecaed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0a4db23ebdf9a8323bd54458dadecaed">current_user_edit</a> (const std::string &amp;nickname, const std::string &amp;image_blob=&quot;&quot;, const <a class="el" href="namespacedpp.html#a7d622bf5ff000e82a44af1a8ac794e83">image_type</a> type=<a class="el" href="namespacedpp.html#a7d622bf5ff000e82a44af1a8ac794e83ace2c4de1f89397132561031f246f89f7">i_png</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a0a4db23ebdf9a8323bd54458dadecaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit current (bot) user.  <a href="classdpp_1_1cluster.html#a0a4db23ebdf9a8323bd54458dadecaed">More...</a><br /></td></tr>
<tr class="separator:a0a4db23ebdf9a8323bd54458dadecaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662fc0a998c62395f166da5e4a2acaf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a662fc0a998c62395f166da5e4a2acaf3">current_user_get_dms</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a662fc0a998c62395f166da5e4a2acaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current user DM channels.  <a href="classdpp_1_1cluster.html#a662fc0a998c62395f166da5e4a2acaf3">More...</a><br /></td></tr>
<tr class="separator:a662fc0a998c62395f166da5e4a2acaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c6a9bb92a500aefc65a953e419c27f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a55c6a9bb92a500aefc65a953e419c27f">create_dm_channel</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a55c6a9bb92a500aefc65a953e419c27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dm channel.  <a href="classdpp_1_1cluster.html#a55c6a9bb92a500aefc65a953e419c27f">More...</a><br /></td></tr>
<tr class="separator:a55c6a9bb92a500aefc65a953e419c27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20f6c8ef35465a17c9510fa8353ef3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa20f6c8ef35465a17c9510fa8353ef3a">current_user_leave_guild</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa20f6c8ef35465a17c9510fa8353ef3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a guild.  <a href="classdpp_1_1cluster.html#aa20f6c8ef35465a17c9510fa8353ef3a">More...</a><br /></td></tr>
<tr class="separator:aa20f6c8ef35465a17c9510fa8353ef3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fc5594e7d2dabcc03e9ef031a361db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a62fc5594e7d2dabcc03e9ef031a361db">thread_create</a> (const std::string &amp;thread_name, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, uint16_t auto_archive_duration, <a class="el" href="namespacedpp.html#a8af3a726df107c304139477dbfa42092">channel_type</a> thread_type, bool invitable, uint16_t rate_limit_per_user, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a62fc5594e7d2dabcc03e9ef031a361db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread.  <a href="classdpp_1_1cluster.html#a62fc5594e7d2dabcc03e9ef031a361db">More...</a><br /></td></tr>
<tr class="separator:a62fc5594e7d2dabcc03e9ef031a361db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc314e4918852cc217b473ff9d95ddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aacc314e4918852cc217b473ff9d95ddc">thread_create_with_message</a> (const std::string &amp;thread_name, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, uint16_t auto_archive_duration, uint16_t rate_limit_per_user, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aacc314e4918852cc217b473ff9d95ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread with a message (Discord: ID of a thread is same as message ID)  <a href="classdpp_1_1cluster.html#aacc314e4918852cc217b473ff9d95ddc">More...</a><br /></td></tr>
<tr class="separator:aacc314e4918852cc217b473ff9d95ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485553dc602bb2a7ed3ca11057034221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a485553dc602bb2a7ed3ca11057034221">current_user_join_thread</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a485553dc602bb2a7ed3ca11057034221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a thread.  <a href="classdpp_1_1cluster.html#a485553dc602bb2a7ed3ca11057034221">More...</a><br /></td></tr>
<tr class="separator:a485553dc602bb2a7ed3ca11057034221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a819f21159771de3142d57eabfe306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a13a819f21159771de3142d57eabfe306">current_user_leave_thread</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a13a819f21159771de3142d57eabfe306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a thread.  <a href="classdpp_1_1cluster.html#a13a819f21159771de3142d57eabfe306">More...</a><br /></td></tr>
<tr class="separator:a13a819f21159771de3142d57eabfe306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066a4a71deac82b823757c2c80479a5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a066a4a71deac82b823757c2c80479a5d">thread_member_add</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a066a4a71deac82b823757c2c80479a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a member to a thread.  <a href="classdpp_1_1cluster.html#a066a4a71deac82b823757c2c80479a5d">More...</a><br /></td></tr>
<tr class="separator:a066a4a71deac82b823757c2c80479a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad253c2a68c5a1e78b880da7252a15814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad253c2a68c5a1e78b880da7252a15814">thread_member_remove</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad253c2a68c5a1e78b880da7252a15814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a member from a thread.  <a href="classdpp_1_1cluster.html#ad253c2a68c5a1e78b880da7252a15814">More...</a><br /></td></tr>
<tr class="separator:ad253c2a68c5a1e78b880da7252a15814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39edec2f1389d1aa5bb6c09e4318b6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad39edec2f1389d1aa5bb6c09e4318b6a">thread_member_get</a> (const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ad39edec2f1389d1aa5bb6c09e4318b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread member.  <a href="classdpp_1_1cluster.html#ad39edec2f1389d1aa5bb6c09e4318b6a">More...</a><br /></td></tr>
<tr class="separator:ad39edec2f1389d1aa5bb6c09e4318b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636b55f518a2e724eabf31453aa89abe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a636b55f518a2e724eabf31453aa89abe">thread_members_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a636b55f518a2e724eabf31453aa89abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get members of a thread.  <a href="classdpp_1_1cluster.html#a636b55f518a2e724eabf31453aa89abe">More...</a><br /></td></tr>
<tr class="separator:a636b55f518a2e724eabf31453aa89abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6825c29651e995f251e01f5a1f20122d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6825c29651e995f251e01f5a1f20122d">threads_get_active</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a6825c29651e995f251e01f5a1f20122d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get active threads in a channel (Sorted by ID in descending order)  <a href="classdpp_1_1cluster.html#a6825c29651e995f251e01f5a1f20122d">More...</a><br /></td></tr>
<tr class="separator:a6825c29651e995f251e01f5a1f20122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b93e8be30c7e954c27e19d8b7fa8170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2b93e8be30c7e954c27e19d8b7fa8170">threads_get_public_archived</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, time_t before_timestamp, uint16_t limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a2b93e8be30c7e954c27e19d8b7fa8170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get public archived threads in a channel (Sorted by archive_timestamp in descending order)  <a href="classdpp_1_1cluster.html#a2b93e8be30c7e954c27e19d8b7fa8170">More...</a><br /></td></tr>
<tr class="separator:a2b93e8be30c7e954c27e19d8b7fa8170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8336e48eaabaeb8df4d69a087982e82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae8336e48eaabaeb8df4d69a087982e82">threads_get_private_archived</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, time_t before_timestamp, uint16_t limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ae8336e48eaabaeb8df4d69a087982e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get private archived threads in a channel (Sorted by archive_timestamp in descending order)  <a href="classdpp_1_1cluster.html#ae8336e48eaabaeb8df4d69a087982e82">More...</a><br /></td></tr>
<tr class="separator:ae8336e48eaabaeb8df4d69a087982e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0c3894cd560fa7871f22d7cfb8f591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0d0c3894cd560fa7871f22d7cfb8f591">threads_get_joined_private_archived</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> before_id, uint16_t limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a0d0c3894cd560fa7871f22d7cfb8f591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get private archived threads in a channel which current user has joined (Sorted by ID in descending order)  <a href="classdpp_1_1cluster.html#a0d0c3894cd560fa7871f22d7cfb8f591">More...</a><br /></td></tr>
<tr class="separator:a0d0c3894cd560fa7871f22d7cfb8f591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f31d36f327a74d24fb4075cec6c2400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7f31d36f327a74d24fb4075cec6c2400">guild_sticker_create</a> (<a class="el" href="structdpp_1_1sticker.html">sticker</a> &amp;s, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a7f31d36f327a74d24fb4075cec6c2400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sticker in a guild.  <a href="classdpp_1_1cluster.html#a7f31d36f327a74d24fb4075cec6c2400">More...</a><br /></td></tr>
<tr class="separator:a7f31d36f327a74d24fb4075cec6c2400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222a8cb4498fd65ae8bb3345b02d0f8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a222a8cb4498fd65ae8bb3345b02d0f8e">guild_sticker_modify</a> (<a class="el" href="structdpp_1_1sticker.html">sticker</a> &amp;s, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a222a8cb4498fd65ae8bb3345b02d0f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a sticker in a guild.  <a href="classdpp_1_1cluster.html#a222a8cb4498fd65ae8bb3345b02d0f8e">More...</a><br /></td></tr>
<tr class="separator:a222a8cb4498fd65ae8bb3345b02d0f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ed56cd299340bdf286bc3457225124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a08ed56cd299340bdf286bc3457225124">guild_sticker_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> sticker_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a08ed56cd299340bdf286bc3457225124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a sticker from a guild.  <a href="classdpp_1_1cluster.html#a08ed56cd299340bdf286bc3457225124">More...</a><br /></td></tr>
<tr class="separator:a08ed56cd299340bdf286bc3457225124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115a49075ceb1817f1e81fc9388bf65e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a115a49075ceb1817f1e81fc9388bf65e">nitro_sticker_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a115a49075ceb1817f1e81fc9388bf65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a nitro sticker.  <a href="classdpp_1_1cluster.html#a115a49075ceb1817f1e81fc9388bf65e">More...</a><br /></td></tr>
<tr class="separator:a115a49075ceb1817f1e81fc9388bf65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a2d335385b4689e7489d0eaf4475fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac7a2d335385b4689e7489d0eaf4475fe">guild_sticker_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ac7a2d335385b4689e7489d0eaf4475fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a guild sticker.  <a href="classdpp_1_1cluster.html#ac7a2d335385b4689e7489d0eaf4475fe">More...</a><br /></td></tr>
<tr class="separator:ac7a2d335385b4689e7489d0eaf4475fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccd1468d3f031c5bc786fdbd087d0a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#adccd1468d3f031c5bc786fdbd087d0a2">guild_stickers_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:adccd1468d3f031c5bc786fdbd087d0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all guild stickers.  <a href="classdpp_1_1cluster.html#adccd1468d3f031c5bc786fdbd087d0a2">More...</a><br /></td></tr>
<tr class="separator:adccd1468d3f031c5bc786fdbd087d0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64421a4b2402238feb0536639009c18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae64421a4b2402238feb0536639009c18">sticker_packs_get</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ae64421a4b2402238feb0536639009c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get sticker packs.  <a href="classdpp_1_1cluster.html#ae64421a4b2402238feb0536639009c18">More...</a><br /></td></tr>
<tr class="separator:ae64421a4b2402238feb0536639009c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe69055dc2ee16d08e693df11fec75a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5fe69055dc2ee16d08e693df11fec75a">stage_instance_create</a> (const <a class="el" href="structdpp_1_1stage__instance.html">stage_instance</a> &amp;instance, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a5fe69055dc2ee16d08e693df11fec75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stage instance on a stage channel.  <a href="classdpp_1_1cluster.html#a5fe69055dc2ee16d08e693df11fec75a">More...</a><br /></td></tr>
<tr class="separator:a5fe69055dc2ee16d08e693df11fec75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edd6ac5d8553b4823465bebadfaa9af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1edd6ac5d8553b4823465bebadfaa9af">stage_instance_get</a> (const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a1edd6ac5d8553b4823465bebadfaa9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stage instance associated with the channel id, if it exists.  <a href="classdpp_1_1cluster.html#a1edd6ac5d8553b4823465bebadfaa9af">More...</a><br /></td></tr>
<tr class="separator:a1edd6ac5d8553b4823465bebadfaa9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e1b1edb3094c7d220a3a80323bbe17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af4e1b1edb3094c7d220a3a80323bbe17">stage_instance_edit</a> (const <a class="el" href="structdpp_1_1stage__instance.html">stage_instance</a> &amp;instance, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:af4e1b1edb3094c7d220a3a80323bbe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a stage instance.  <a href="classdpp_1_1cluster.html#af4e1b1edb3094c7d220a3a80323bbe17">More...</a><br /></td></tr>
<tr class="separator:af4e1b1edb3094c7d220a3a80323bbe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8c2ba02d51ad166f90300ab5b53ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9f8c2ba02d51ad166f90300ab5b53ecb">stage_instance_delete</a> (const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a9f8c2ba02d51ad166f90300ab5b53ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a stage instance.  <a href="classdpp_1_1cluster.html#a9f8c2ba02d51ad166f90300ab5b53ecb">More...</a><br /></td></tr>
<tr class="separator:a9f8c2ba02d51ad166f90300ab5b53ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d45a29b3976f7b623d92e70ab9a1bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af6d45a29b3976f7b623d92e70ab9a1bc">get_voice_regions</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:af6d45a29b3976f7b623d92e70ab9a1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all voice regions.  <a href="classdpp_1_1cluster.html#af6d45a29b3976f7b623d92e70ab9a1bc">More...</a><br /></td></tr>
<tr class="separator:af6d45a29b3976f7b623d92e70ab9a1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f16d04f100a0159683cba96e8c0a6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a68f16d04f100a0159683cba96e8c0a6c">get_gateway_bot</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a68f16d04f100a0159683cba96e8c0a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gateway information for the bot using the token.  <a href="classdpp_1_1cluster.html#a68f16d04f100a0159683cba96e8c0a6c">More...</a><br /></td></tr>
<tr class="separator:a68f16d04f100a0159683cba96e8c0a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8554f93aed5fb84162af41c997fc1e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae8554f93aed5fb84162af41c997fc1e3">guild_events_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ae8554f93aed5fb84162af41c997fc1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all scheduled events for a guild.  <a href="classdpp_1_1cluster.html#ae8554f93aed5fb84162af41c997fc1e3">More...</a><br /></td></tr>
<tr class="separator:ae8554f93aed5fb84162af41c997fc1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f6a78b9b2ad6218ed1b8c7b044013a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a09f6a78b9b2ad6218ed1b8c7b044013a">guild_event_users_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> event_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback, uint8_t limit=100, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> before=0, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> after=0)</td></tr>
<tr class="memdesc:a09f6a78b9b2ad6218ed1b8c7b044013a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get users RSVP'd to an event.  <a href="classdpp_1_1cluster.html#a09f6a78b9b2ad6218ed1b8c7b044013a">More...</a><br /></td></tr>
<tr class="separator:a09f6a78b9b2ad6218ed1b8c7b044013a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dc202cee249447c1a135a80a852daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a04dc202cee249447c1a135a80a852daf">guild_event_create</a> (const <a class="el" href="structdpp_1_1scheduled__event.html">scheduled_event</a> &amp;event, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a04dc202cee249447c1a135a80a852daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scheduled event on a guild.  <a href="classdpp_1_1cluster.html#a04dc202cee249447c1a135a80a852daf">More...</a><br /></td></tr>
<tr class="separator:a04dc202cee249447c1a135a80a852daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bec34914c433a1105697dd5c24c7f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a17bec34914c433a1105697dd5c24c7f2">guild_event_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> event_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a17bec34914c433a1105697dd5c24c7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a scheduled event from a guild.  <a href="classdpp_1_1cluster.html#a17bec34914c433a1105697dd5c24c7f2">More...</a><br /></td></tr>
<tr class="separator:a17bec34914c433a1105697dd5c24c7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b82a96ca6b744388e9b290cbf775ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a36b82a96ca6b744388e9b290cbf775ff">guild_event_edit</a> (const <a class="el" href="structdpp_1_1scheduled__event.html">scheduled_event</a> &amp;event, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a36b82a96ca6b744388e9b290cbf775ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit/modify a scheduled event on a guild.  <a href="classdpp_1_1cluster.html#a36b82a96ca6b744388e9b290cbf775ff">More...</a><br /></td></tr>
<tr class="separator:a36b82a96ca6b744388e9b290cbf775ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8c168682519ee125ed0a48239c08ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5b8c168682519ee125ed0a48239c08ef">guild_event_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> event_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a5b8c168682519ee125ed0a48239c08ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a scheduled event for a guild.  <a href="classdpp_1_1cluster.html#a5b8c168682519ee125ed0a48239c08ef">More...</a><br /></td></tr>
<tr class="separator:a5b8c168682519ee125ed0a48239c08ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a644b186bc4b386a8313e3c5dce456c4e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a></td></tr>
<tr class="separator:a644b186bc4b386a8313e3c5dce456c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ce7fc13658a25e2faeadcd36282b0b"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a32ce7fc13658a25e2faeadcd36282b0b">last_identify</a></td></tr>
<tr class="separator:a32ce7fc13658a25e2faeadcd36282b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239af1e13449c85658fb37e6589745a0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a239af1e13449c85658fb37e6589745a0">intents</a></td></tr>
<tr class="separator:a239af1e13449c85658fb37e6589745a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7418aa521c49af80822039b013d8d004"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7418aa521c49af80822039b013d8d004">numshards</a></td></tr>
<tr class="separator:a7418aa521c49af80822039b013d8d004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5155862c1d7267c7f4ee8781ff3e8d7f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5155862c1d7267c7f4ee8781ff3e8d7f">cluster_id</a></td></tr>
<tr class="separator:a5155862c1d7267c7f4ee8781ff3e8d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80e4df300e69988d163d61c14e540ab"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad80e4df300e69988d163d61c14e540ab">maxclusters</a></td></tr>
<tr class="separator:ad80e4df300e69988d163d61c14e540ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6161f8d412b2e81a06594f727684a260"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6161f8d412b2e81a06594f727684a260">rest_ping</a></td></tr>
<tr class="separator:a6161f8d412b2e81a06594f727684a260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dfd048a845235dda924b989c1383f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1dispatcher.html">dpp::dispatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad7dfd048a845235dda924b989c1383f3">dispatch</a></td></tr>
<tr class="separator:ad7dfd048a845235dda924b989c1383f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31317a40181f6864646c8758871b495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1user.html">dpp::user</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad31317a40181f6864646c8758871b495">me</a></td></tr>
<tr class="memdesc:ad31317a40181f6864646c8758871b495"><td class="mdescLeft">&#160;</td><td class="mdescRight">The details of the bot user. This is assumed to be identical across all shards in the cluster. Each connecting shard updates this information.  <a href="classdpp_1_1cluster.html#ad31317a40181f6864646c8758871b495">More...</a><br /></td></tr>
<tr class="separator:ad31317a40181f6864646c8758871b495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae28f81712be86530fe3314d166ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdpp_1_1cache__policy__t.html">cache_policy_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9fae28f81712be86530fe3314d166ad3">cache_policy</a></td></tr>
<tr class="memdesc:a9fae28f81712be86530fe3314d166ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current cache policy for the cluster.  <a href="classdpp_1_1cluster.html#a9fae28f81712be86530fe3314d166ad3">More...</a><br /></td></tr>
<tr class="separator:a9fae28f81712be86530fe3314d166ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10466db79966215a799fc2a30010551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#af7cde3079d745428f44ef6231a2ac672">websocket_protocol_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae10466db79966215a799fc2a30010551">ws_mode</a></td></tr>
<tr class="memdesc:ae10466db79966215a799fc2a30010551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Websocket mode for all shards in the cluster, either ws_json or ws_etf. Production bots should use ETF, while development bots should use JSON.  <a href="classdpp_1_1cluster.html#ae10466db79966215a799fc2a30010551">More...</a><br /></td></tr>
<tr class="separator:ae10466db79966215a799fc2a30010551"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The cluster class represents a group of shards and a command queue for sending and receiving commands from discord via HTTP. You should usually instantiate a cluster object at the very least to make use of the library. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aac40e45e1ff8efb4e9ae75a7ecacc786" name="aac40e45e1ff8efb4e9ae75a7ecacc786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac40e45e1ff8efb4e9ae75a7ecacc786">&#9670;&nbsp;</a></span>cluster() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dpp::cluster::cluster </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intents</em> = <code><a class="el" href="namespacedpp.html#a0042c0fc8164da4239b977d5be8e2ef5a561a52b3c6883808735c41891351c68f">i_default_intents</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shards</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cluster_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxclusters</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdpp_1_1cache__policy__t.html">cache_policy_t</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code>{<a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>,&#160;<a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>,&#160;<a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for creating a cluster. All but the token are optional. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The bot token to use for all HTTP commands and websocket connections </td></tr>
    <tr><td class="paramname">intents</td><td>A bitmask of dpd::intents values for all shards on this cluster. This is required to be sent for all bots with over 100 servers. </td></tr>
    <tr><td class="paramname">shards</td><td>The total number of shards on this bot. If there are multiple clusters, then (shards / clusters) actual shards will run on this cluster. If you omit this value, the library will attempt to query the Discord API for the correct number of shards to start. </td></tr>
    <tr><td class="paramname">cluster_id</td><td>The ID of this cluster, should be between 0 and MAXCLUSTERS-1 </td></tr>
    <tr><td class="paramname">maxclusters</td><td>The total number of clusters that are active, which may be on separate processes or even separate machines. </td></tr>
    <tr><td class="paramname">compressed</td><td>Whether or not to use compression for shards on this cluster. Saves a ton of bandwidth at the cost of some CPU </td></tr>
    <tr><td class="paramname">policy</td><td>Set the user caching policy for the cluster, either lazy (only cache users/members when they message the bot) or aggressive (request whole member lists on seeing new guilds too) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdpp_1_1exception.html" title="The dpp::exception class derives from std::exception and supports some other ways of passing in error...">dpp::exception</a></td><td>Thrown on windows, if WinSock fails to initialise, or on any other system if a <a class="el" href="classdpp_1_1request__queue.html" title="The request_queue class manages rate limits and marshalls HTTP requests that have been built as http_...">dpp::request_queue</a> fails to construct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b0b523f89559b4ce204ca9ed9693d79" name="a6b0b523f89559b4ce204ca9ed9693d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0b523f89559b4ce204ca9ed9693d79">&#9670;&nbsp;</a></span>cluster() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dpp::cluster::cluster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classdpp_1_1cluster.html" title="The cluster class represents a group of shards and a command queue for sending and receiving commands...">dpp::cluster</a> is non-copyable </p>

</div>
</div>
<a id="a2d957f52245734f6d44444af8380c952" name="a2d957f52245734f6d44444af8380c952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d957f52245734f6d44444af8380c952">&#9670;&nbsp;</a></span>cluster() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dpp::cluster::cluster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classdpp_1_1cluster.html" title="The cluster class represents a group of shards and a command queue for sending and receiving commands...">dpp::cluster</a> is non-moveable </p>

</div>
</div>
<a id="a270be0ab59aff4f335ef3f4af7559d92" name="a270be0ab59aff4f335ef3f4af7559d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270be0ab59aff4f335ef3f4af7559d92">&#9670;&nbsp;</a></span>~cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dpp::cluster::~cluster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the cluster object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad73706406e2f99b9a580319e389777be" name="ad73706406e2f99b9a580319e389777be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73706406e2f99b9a580319e389777be">&#9670;&nbsp;</a></span>channel_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a channel. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1channel.html" title="A definition of a discord channel There are one of these for every channel type except threads....">dpp::channel</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3b00dafa69984d444422b500c3d18b3" name="ad3b00dafa69984d444422b500c3d18b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b00dafa69984d444422b500c3d18b3">&#9670;&nbsp;</a></span>channel_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a channel. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel id to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2fce9638b93c6b5d5d67f8bea9f8f6c" name="aa2fce9638b93c6b5d5d67f8bea9f8f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fce9638b93c6b5d5d67f8bea9f8f6c">&#9670;&nbsp;</a></span>channel_delete_permission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_delete_permission </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>overwrite_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a permission from a channel. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to remove permission from </td></tr>
    <tr><td class="paramname">overwrite_id</td><td>Overwrite to remove, user or channel ID </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5511e31156dd2508387b1ba5a1612c09" name="a5511e31156dd2508387b1ba5a1612c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5511e31156dd2508387b1ba5a1612c09">&#9670;&nbsp;</a></span>channel_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_edit </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a channel. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to edit/update </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1channel.html" title="A definition of a discord channel There are one of these for every channel type except threads....">dpp::channel</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfb4457e63c60500b44bfdee27d80c75" name="abfb4457e63c60500b44bfdee27d80c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb4457e63c60500b44bfdee27d80c75">&#9670;&nbsp;</a></span>channel_edit_permissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_edit_permissions </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>overwrite_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>allow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>deny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a channel's permissions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to set permissions for </td></tr>
    <tr><td class="paramname">overwrite_id</td><td>Overwrite to change (a user or channel ID) </td></tr>
    <tr><td class="paramname">allow</td><td>allow permissions </td></tr>
    <tr><td class="paramname">deny</td><td>deny permissions </td></tr>
    <tr><td class="paramname">member</td><td>true if the overwrite_id is a user id, false if it is a channel id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a391779232600ba3a6f57d678047761b0" name="a391779232600ba3a6f57d678047761b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391779232600ba3a6f57d678047761b0">&#9670;&nbsp;</a></span>channel_edit_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_edit_position </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a channel's position. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to change the position for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1channel.html" title="A definition of a discord channel There are one of these for every channel type except threads....">dpp::channel</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b7593e4ba82977bf3d8ad9052c9c565" name="a1b7593e4ba82977bf3d8ad9052c9c565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7593e4ba82977bf3d8ad9052c9c565">&#9670;&nbsp;</a></span>channel_follow_news()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_follow_news </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>target_channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Follow a news channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel id to follow </td></tr>
    <tr><td class="paramname">target_channel_id</td><td>Channel to subscribe the channel to </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a108f6f06b43709c8d47df5f94a3ca0a5" name="a108f6f06b43709c8d47df5f94a3ca0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108f6f06b43709c8d47df5f94a3ca0a5">&#9670;&nbsp;</a></span>channel_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel ID to retrieve </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1channel.html" title="A definition of a discord channel There are one of these for every channel type except threads....">dpp::channel</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07e66a7400101f466aab40ed58c67942" name="a07e66a7400101f466aab40ed58c67942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e66a7400101f466aab40ed58c67942">&#9670;&nbsp;</a></span>channel_invite_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_invite_create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1invite.html">invite</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create invite for a channel. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to create an invite on </td></tr>
    <tr><td class="paramname">i</td><td>Invite to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1invite.html" title="Represents an invite to a discord guild or channel.">dpp::invite</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa03a0da5c8e6801dc56bda258265da04" name="aa03a0da5c8e6801dc56bda258265da04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03a0da5c8e6801dc56bda258265da04">&#9670;&nbsp;</a></span>channel_invites_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_invites_get </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get invites for a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to get invites for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#aa85b043fd45cf24caa23ab6004a2415a">dpp::invite_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a553bfda3b4f1671e75c5713275b781bd" name="a553bfda3b4f1671e75c5713275b781bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553bfda3b4f1671e75c5713275b781bd">&#9670;&nbsp;</a></span>channel_pins_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_pins_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a channel's pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel ID to get pins for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a44d4dd39b5d7c24c5fe97a76a73cf708">dpp::message_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2caf58e161373fd3fa26172a4a78c835" name="a2caf58e161373fd3fa26172a4a78c835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caf58e161373fd3fa26172a4a78c835">&#9670;&nbsp;</a></span>channel_typing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_typing </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger channel typing indicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to set as typing on </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad80ac0e99c0a20c9c05678631189b8f3" name="ad80ac0e99c0a20c9c05678631189b8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80ac0e99c0a20c9c05678631189b8f3">&#9670;&nbsp;</a></span>channel_typing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_typing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger channel typing indicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>Channel ID to set as typing on </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24e67431b79cc2c3d0f12d59afd5a1c8" name="a24e67431b79cc2c3d0f12d59afd5a1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e67431b79cc2c3d0f12d59afd5a1c8">&#9670;&nbsp;</a></span>channels_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channels_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all channels for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to retrieve channels for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a7c77c4dd9434985643b2f1993b227f30" title="A group of channels.">dpp::channel_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1e3f0868ece15373e81844dff719aa0" name="af1e3f0868ece15373e81844dff719aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e3f0868ece15373e81844dff719aa0">&#9670;&nbsp;</a></span>clear_audit_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp; dpp::cluster::clear_audit_reason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the audit log reason for the next REST call to be made. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically. </p>
<p >Example: </p><div class="fragment"><div class="line">bot.set_audit_reason(<span class="stringliteral">&quot;Won&#39;t be sent&quot;</span>)</div>
<div class="line">   .clear_audit_reason()</div>
<div class="line">   .channel_delete(my_channel_id);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>cluster&amp; Reference to self for chaining. </dd></dl>

</div>
</div>
<a id="a55c6a9bb92a500aefc65a953e419c27f" name="a55c6a9bb92a500aefc65a953e419c27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c6a9bb92a500aefc65a953e419c27f">&#9670;&nbsp;</a></span>create_dm_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::create_dm_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dm channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_id</td><td>User ID to create DM channel with </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1channel.html" title="A definition of a discord channel There are one of these for every channel type except threads....">dpp::channel</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a627510bf4f4d1c3a999ccb506c75ec47" name="a627510bf4f4d1c3a999ccb506c75ec47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627510bf4f4d1c3a999ccb506c75ec47">&#9670;&nbsp;</a></span>create_webhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::create_webhook </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a webhook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Webhook to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1webhook.html" title="Represents a discord webhook.">dpp::webhook</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3dc39069aaaa492727f39b35edd957e" name="ac3dc39069aaaa492727f39b35edd957e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dc39069aaaa492727f39b35edd957e">&#9670;&nbsp;</a></span>current_application_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_application_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current (bot) application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1application.html" title="The application class represents details of a bot application.">dpp::application</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75e1e5dd813d36fffd6b532ed1b31178" name="a75e1e5dd813d36fffd6b532ed1b31178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e1e5dd813d36fffd6b532ed1b31178">&#9670;&nbsp;</a></span>current_user_connections_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_connections_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current user's connections (linked accounts, e.g. steam, xbox). This call requires the oauth2 <code>connections</code> scope and cannot be executed against a bot token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#ad5f78f7b7bca070ac34c0267ca49013a">dpp::connection_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a4db23ebdf9a8323bd54458dadecaed" name="a0a4db23ebdf9a8323bd54458dadecaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4db23ebdf9a8323bd54458dadecaed">&#9670;&nbsp;</a></span>current_user_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_edit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nickname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>image_blob</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a7d622bf5ff000e82a44af1a8ac794e83">image_type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespacedpp.html#a7d622bf5ff000e82a44af1a8ac794e83ace2c4de1f89397132561031f246f89f7">i_png</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit current (bot) user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nickname</td><td>Nickname to set </td></tr>
    <tr><td class="paramname">image_blob</td><td>Avatar data to upload (NOTE: Very heavily rate limited!) </td></tr>
    <tr><td class="paramname">type</td><td>Type of image for avatar </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1user.html" title="Represents a user on discord. May or may not be a member of a dpp::guild.">dpp::user</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdpp_1_1exception.html" title="The dpp::exception class derives from std::exception and supports some other ways of passing in error...">dpp::exception</a></td><td>Image data is larger than the maximum size of 256 kilobytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad927e85ed6b99e9b05f4190f1b19cae" name="aad927e85ed6b99e9b05f4190f1b19cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad927e85ed6b99e9b05f4190f1b19cae">&#9670;&nbsp;</a></span>current_user_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current (bot) user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">dpp::user_identified</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">user_identified</a> object is a subclass of <a class="el" href="classdpp_1_1user.html" title="Represents a user on discord. May or may not be a member of a dpp::guild.">dpp::user</a> which contains further details if you have the oauth2 identify or email scopes. If you do not have these scopes, these fields are empty. You can safely convert a <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">user_identified</a> to user with <code>dynamic_cast</code>. </dd></dl>

</div>
</div>
<a id="a662fc0a998c62395f166da5e4a2acaf3" name="a662fc0a998c62395f166da5e4a2acaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662fc0a998c62395f166da5e4a2acaf3">&#9670;&nbsp;</a></span>current_user_get_dms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_get_dms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current user DM channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a7c77c4dd9434985643b2f1993b227f30" title="A group of channels.">dpp::channel_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93c8fd5f22e0eae6bf357ad498b43f87" name="a93c8fd5f22e0eae6bf357ad498b43f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c8fd5f22e0eae6bf357ad498b43f87">&#9670;&nbsp;</a></span>current_user_get_guilds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_get_guilds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current (bot) user guilds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a0d9e1952e25391a3379ee3db2d930bf7">dpp::guild_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a485553dc602bb2a7ed3ca11057034221" name="a485553dc602bb2a7ed3ca11057034221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485553dc602bb2a7ed3ca11057034221">&#9670;&nbsp;</a></span>current_user_join_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_join_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread ID to join </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa20f6c8ef35465a17c9510fa8353ef3a" name="aa20f6c8ef35465a17c9510fa8353ef3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20f6c8ef35465a17c9510fa8353ef3a">&#9670;&nbsp;</a></span>current_user_leave_guild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_leave_guild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to leave </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13a819f21159771de3142d57eabfe306" name="a13a819f21159771de3142d57eabfe306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a819f21159771de3142d57eabfe306">&#9670;&nbsp;</a></span>current_user_leave_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_leave_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread ID to leave </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee76e0048ec1cd35420da1bfc5317646" name="aee76e0048ec1cd35420da1bfc5317646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee76e0048ec1cd35420da1bfc5317646">&#9670;&nbsp;</a></span>delete_webhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::delete_webhook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>webhook_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a webhook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">webhook_id</td><td>Webhook ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6e937f48e410469c90f37368afa4cbe" name="ae6e937f48e410469c90f37368afa4cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e937f48e410469c90f37368afa4cbe">&#9670;&nbsp;</a></span>delete_webhook_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::delete_webhook_message </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete webhook message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Webhook to delete message for </td></tr>
    <tr><td class="paramname">message_id</td><td>Message ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae790b70aaecd9c42fe8a64c4c71a3d0c" name="ae790b70aaecd9c42fe8a64c4c71a3d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae790b70aaecd9c42fe8a64c4c71a3d0c">&#9670;&nbsp;</a></span>delete_webhook_with_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::delete_webhook_with_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>webhook_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete webhook with token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">webhook_id</td><td>Webhook ID to delete </td></tr>
    <tr><td class="paramname">token</td><td>Token of webhook to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48fa8b2df61d6f2c2f8267525dcd7ace" name="a48fa8b2df61d6f2c2f8267525dcd7ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fa8b2df61d6f2c2f8267525dcd7ace">&#9670;&nbsp;</a></span>detach_application_command_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_application_command_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_application_command_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_application_command_create event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_application_command_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a5e4c89e99887415ff9309d704f2899ac" title="Called when a new application command (slash command) is registered.">dpp::cluster::on_application_command_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="adac82a31ffbc97b156cbbc48bf57326e" name="adac82a31ffbc97b156cbbc48bf57326e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac82a31ffbc97b156cbbc48bf57326e">&#9670;&nbsp;</a></span>detach_application_command_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_application_command_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_application_command_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_application_command_delete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_application_command_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a0f244bc712531ce761c51fdcc61d96a2" title="Called when an application command (slash command) is deleted.">dpp::cluster::on_application_command_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a16a7dba8a5219ab613bfebac352a8213" name="a16a7dba8a5219ab613bfebac352a8213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a7dba8a5219ab613bfebac352a8213">&#9670;&nbsp;</a></span>detach_application_command_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_application_command_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_application_command_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_application_command_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_application_command_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a2dbbc1e590a5c23311f2895db63d5d5f" title="Called when an application command (slash command) is updated. You will only receive this event for a...">dpp::cluster::on_application_command_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a886b16b2329d74ea1003507628d35b96" name="a886b16b2329d74ea1003507628d35b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886b16b2329d74ea1003507628d35b96">&#9670;&nbsp;</a></span>detach_autocomplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_autocomplete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_autocomplete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_autocomplete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_autocomplete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a3477074ee2798aecb28542ee5afc36f3" title="Called when an auto completed field needs suggestions to present to the user This is triggered by dis...">dpp::cluster::on_autocomplete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="af063fbe8c46e362c4e18cad517f743f8" name="af063fbe8c46e362c4e18cad517f743f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af063fbe8c46e362c4e18cad517f743f8">&#9670;&nbsp;</a></span>detach_button_click()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_button_click </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_button_click</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_button_click event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_button_click</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ad657d4be274b38e641db9bab63e8a420" title="Called when a button is clicked attached to a message. Button clicks are triggered by discord when bu...">dpp::cluster::on_button_click()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a632a552219431205d5e0b9ff2dc6abb7" name="a632a552219431205d5e0b9ff2dc6abb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632a552219431205d5e0b9ff2dc6abb7">&#9670;&nbsp;</a></span>detach_channel_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_channel_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_channel_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_channel_create event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a335adc4a68c5651dd5201642f54bc446" title="Called when a new channel is created on a guild.">dpp::cluster::on_channel_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a7e5cc859e68b5933ecf4069fc89a46b1" name="a7e5cc859e68b5933ecf4069fc89a46b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5cc859e68b5933ecf4069fc89a46b1">&#9670;&nbsp;</a></span>detach_channel_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_channel_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_channel_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_channel_delete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ad7d42302de6b917c75a7174c7e11f6e9" title="Called when a channel is deleted from a guild. The channel will still be temporarily avaialble in the...">dpp::cluster::on_channel_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a0548cce6c1916b6bc1335a0142c2f5fe" name="a0548cce6c1916b6bc1335a0142c2f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0548cce6c1916b6bc1335a0142c2f5fe">&#9670;&nbsp;</a></span>detach_channel_pins_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_channel_pins_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_channel_pins_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_channel_pins_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_pins_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a57fe59534c81060533f8b31865b3a23a" title="Called when a message is pinned. Note that the pinned message is not returned to this event,...">dpp::cluster::on_channel_pins_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="af27f3c53bcf391580003b2bf5eea2c17" name="af27f3c53bcf391580003b2bf5eea2c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27f3c53bcf391580003b2bf5eea2c17">&#9670;&nbsp;</a></span>detach_channel_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_channel_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_channel_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_channel_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ac318487605dd012335dd3787115f1ec2" title="Called when a channel is edited on a guild. The new channel details have already been applied to the ...">dpp::cluster::on_channel_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a87e32b89f223d3362c948c346c7fc1a0" name="a87e32b89f223d3362c948c346c7fc1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e32b89f223d3362c948c346c7fc1a0">&#9670;&nbsp;</a></span>detach_guild_ban_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_ban_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_ban_add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_ban_add event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_ban_add</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a425b60f353b4d7c48d870b850bff785e" title="Called when a ban is added to a guild.">dpp::cluster::on_guild_ban_add()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a9561236abcd3ca267caf6a17e6388a3f" name="a9561236abcd3ca267caf6a17e6388a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9561236abcd3ca267caf6a17e6388a3f">&#9670;&nbsp;</a></span>detach_guild_ban_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_ban_remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_ban_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_ban_remove event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_ban_remove</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#afcbd27652ac7192502d6da555e0dc6c9" title="Called when a ban is removed from a guild.">dpp::cluster::on_guild_ban_remove()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a4adcba64c577f2a617aa3436a5b52dd4" name="a4adcba64c577f2a617aa3436a5b52dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adcba64c577f2a617aa3436a5b52dd4">&#9670;&nbsp;</a></span>detach_guild_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_create event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a5164c0f1ebeb101c1fa80b03d6e09a4a" title="Called when a new guild is created. D++ will request members for the guild for its cache using guild_...">dpp::cluster::on_guild_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="aca51095bfb14b99a303405fb62677dd7" name="aca51095bfb14b99a303405fb62677dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca51095bfb14b99a303405fb62677dd7">&#9670;&nbsp;</a></span>detach_guild_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_delete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#abdd66b3f7268c8f7a6f7fb937bfd45d9" title="Called when a guild is deleted. A guild can be deleted via the bot being kicked, the bot leaving the ...">dpp::cluster::on_guild_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="aebe2b42f0103cdcf0e3dd91a1ae56367" name="aebe2b42f0103cdcf0e3dd91a1ae56367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe2b42f0103cdcf0e3dd91a1ae56367">&#9670;&nbsp;</a></span>detach_guild_emojis_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_emojis_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_emojis_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_emojis_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_emojis_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a0d2f6179869a30c910f1bef89c511d7c" title="Called when new emojis are added to a guild. The complete set of emojis is sent every time.">dpp::cluster::on_guild_emojis_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a69dd91d6f6b735b35ab3867e99507ef6" name="a69dd91d6f6b735b35ab3867e99507ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dd91d6f6b735b35ab3867e99507ef6">&#9670;&nbsp;</a></span>detach_guild_integrations_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_integrations_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_integrations_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_integrations_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_integrations_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a731cc99b15dd5f15568ee5856d8ceffa" title="Called when an integration is updated for a guild. This returns the complete list....">dpp::cluster::on_guild_integrations_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="aa40727e8a623206fd029688b61e5589f" name="aa40727e8a623206fd029688b61e5589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40727e8a623206fd029688b61e5589f">&#9670;&nbsp;</a></span>detach_guild_join_request_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_join_request_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_join_request_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_join_request_delete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_join_request_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a71993919fb741b379465c28e353c0b10" title="on guild join request delete. Triggered when a user declines the membership screening questionnaire f...">dpp::cluster::on_guild_join_request_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a4b4e5114eeaa38be6711200e65767fe8" name="a4b4e5114eeaa38be6711200e65767fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4e5114eeaa38be6711200e65767fe8">&#9670;&nbsp;</a></span>detach_guild_member_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_member_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_member_add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_member_add event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_member_add</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#aa77b960a3530d07e972e82d8fff5a8ae" title="Called when a new member joins a guild.">dpp::cluster::on_guild_member_add()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a6b6f3b5f210ea0d6b183005b51d0a9fd" name="a6b6f3b5f210ea0d6b183005b51d0a9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6f3b5f210ea0d6b183005b51d0a9fd">&#9670;&nbsp;</a></span>detach_guild_member_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_member_remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_member_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_member_remove event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_member_remove</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a4343a2d7352d93ba62405c82606df307" title="Called when a user leaves a guild (either through being kicked, or choosing to leave)">dpp::cluster::on_guild_member_remove()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="ad5489624b95b26f76e1cee48cef28bf6" name="ad5489624b95b26f76e1cee48cef28bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5489624b95b26f76e1cee48cef28bf6">&#9670;&nbsp;</a></span>detach_guild_member_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_member_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_member_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_member_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_member_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#aad3ffd9036946ac953be2e5f552e988c" title="Called when details of a guild member (e.g. their roles or nickname) are updated.">dpp::cluster::on_guild_member_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="ab8979f9fe0fb3aa5ee9a475832f30607" name="ab8979f9fe0fb3aa5ee9a475832f30607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8979f9fe0fb3aa5ee9a475832f30607">&#9670;&nbsp;</a></span>detach_guild_members_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_members_chunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_members_chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_members_chunk event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_members_chunk</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a8fffc28979d1ecb8c7d653501e31d04c" title="Called when a set of members is received for a guild. D++ will request these for all new guilds if ne...">dpp::cluster::on_guild_members_chunk()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="acf56d37e5d0634545687d74947366d3e" name="acf56d37e5d0634545687d74947366d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf56d37e5d0634545687d74947366d3e">&#9670;&nbsp;</a></span>detach_guild_role_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_role_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_role_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_role_create event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_role_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ab3449a9c5305ed837cd345d9cfe27692" title="Called when a new role is created on a guild.">dpp::cluster::on_guild_role_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a1be23b9b8849a4493338207e85a41033" name="a1be23b9b8849a4493338207e85a41033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be23b9b8849a4493338207e85a41033">&#9670;&nbsp;</a></span>detach_guild_role_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_role_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_role_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_role_delete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_role_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ae250fcc04d66b9fc2449b05e1fc04c7a" title="Called when a role is deleted in a guild.">dpp::cluster::on_guild_role_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a779ebb839d4467583ff65ae57b815e6a" name="a779ebb839d4467583ff65ae57b815e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779ebb839d4467583ff65ae57b815e6a">&#9670;&nbsp;</a></span>detach_guild_role_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_role_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_role_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_role_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_role_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#acbbf2f6a526453d97616d6c3fdf15cdd" title="Called when an existing role is updated on a guild.">dpp::cluster::on_guild_role_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a1d9a58f0e8f7dfcabec9ed86d494dac4" name="a1d9a58f0e8f7dfcabec9ed86d494dac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9a58f0e8f7dfcabec9ed86d494dac4">&#9670;&nbsp;</a></span>detach_guild_scheduled_event_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_scheduled_event_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_scheduled_event_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_scheduled_event_create. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#aac1d9a0fbc87cfd2312faf2ad2aab381" title="Called when a new scheduled event is created.">dpp::cluster::on_guild_scheduled_event_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a4988a9fa82fc1593a9f66627626f1e78" name="a4988a9fa82fc1593a9f66627626f1e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4988a9fa82fc1593a9f66627626f1e78">&#9670;&nbsp;</a></span>detach_guild_scheduled_event_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_scheduled_event_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_scheduled_event_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_scheduled_event_delete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a31f19dadb24daf8a92186fdea29a7599" title="Called when a new scheduled event is deleted.">dpp::cluster::on_guild_scheduled_event_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a8ee3b48a74d9243df3b160ec5d688335" name="a8ee3b48a74d9243df3b160ec5d688335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee3b48a74d9243df3b160ec5d688335">&#9670;&nbsp;</a></span>detach_guild_scheduled_event_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_scheduled_event_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_scheduled_event_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_scheduled_event_update. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#abdebff7b0db64e06bb8585193bd41a52" title="Called when a new scheduled event is updated.">dpp::cluster::on_guild_scheduled_event_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a6ae706fc7e036a45aa686ca1b88a4b88" name="a6ae706fc7e036a45aa686ca1b88a4b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae706fc7e036a45aa686ca1b88a4b88">&#9670;&nbsp;</a></span>detach_guild_scheduled_event_user_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_scheduled_event_user_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_scheduled_event_user_add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_scheduled_event_user_add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_user_add</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ad448883ec484005d51c98330c8fc26ce" title="Called when a user is added to a scheduled event.">dpp::cluster::on_guild_scheduled_event_user_add()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a4622b6cadc6edd6a6f067f5d811a32b1" name="a4622b6cadc6edd6a6f067f5d811a32b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4622b6cadc6edd6a6f067f5d811a32b1">&#9670;&nbsp;</a></span>detach_guild_scheduled_event_user_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_scheduled_event_user_remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_scheduled_event_user_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_scheduled_event_user_remove. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_user_remove</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a67a9b0e0f6e35314b91f5c765823b75f" title="Called when a user is removed to a scheduled event.">dpp::cluster::on_guild_scheduled_event_user_remove()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="ada013c47908344d05f0081a265b395c2" name="ada013c47908344d05f0081a265b395c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada013c47908344d05f0081a265b395c2">&#9670;&nbsp;</a></span>detach_guild_stickers_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_stickers_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_stickers_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_stickers_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_stickers_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a1a04d841ce5b7e6221e6da7da8b18a7a" title="Called when new stickers are added to a guild. The complete set of stickers is sent every time.">dpp::cluster::on_guild_stickers_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a3e352cbb7fce4d05df26e3dfd949dbc2" name="a3e352cbb7fce4d05df26e3dfd949dbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e352cbb7fce4d05df26e3dfd949dbc2">&#9670;&nbsp;</a></span>detach_guild_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_guild_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_guild_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_guild_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a0d1bc31f6ad73a63417020ae1ae40bb4" title="Called when details of a guild are updated.">dpp::cluster::on_guild_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="accde43676031714042f9f76fc81458be" name="accde43676031714042f9f76fc81458be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accde43676031714042f9f76fc81458be">&#9670;&nbsp;</a></span>detach_integration_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_integration_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_integration_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_integration_create event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_integration_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a0915881738f80397da118da81358022d" title="Called when a new intgration is attached to a guild by a user. An integration is a connection to a gu...">dpp::cluster::on_integration_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a78e49e860707d4fb023f0f94819e4f3a" name="a78e49e860707d4fb023f0f94819e4f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e49e860707d4fb023f0f94819e4f3a">&#9670;&nbsp;</a></span>detach_integration_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_integration_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_integration_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_integration_delete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_integration_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a62516361826a0f9256d2ff79b93b9f86" title="Called when an integration is removed by a user. An integration is a connection to a guild of a user&#39;...">dpp::cluster::on_integration_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="af78a659a6d62231f05d3ccb6c35bc0d3" name="af78a659a6d62231f05d3ccb6c35bc0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78a659a6d62231f05d3ccb6c35bc0d3">&#9670;&nbsp;</a></span>detach_integration_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_integration_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_integration_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_integration_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_integration_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a01a8130ec8031b283468705f82b940fa" title="Called when an integration is updated by a user. This returns details of just the single integration ...">dpp::cluster::on_integration_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a1fa6c9506b2f5688453f048d31358e86" name="a1fa6c9506b2f5688453f048d31358e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa6c9506b2f5688453f048d31358e86">&#9670;&nbsp;</a></span>detach_interaction_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_interaction_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_interaction_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_interaction_create event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_interaction_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a3287881d5f1aba46a7013c695b69a591" title="Called when a new interaction is created. Interactions are created by discord when commands you have ...">dpp::cluster::on_interaction_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a384e99ac71372c0031c88aa73aada59c" name="a384e99ac71372c0031c88aa73aada59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384e99ac71372c0031c88aa73aada59c">&#9670;&nbsp;</a></span>detach_invite_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_invite_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_invite_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_invite_create event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_invite_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a3b4128b323c8e48236da083841d9cfa8" title="Called when a new invite is created for a guild.">dpp::cluster::on_invite_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a0749d432ed12b5ad4e4a0afd89cfcc76" name="a0749d432ed12b5ad4e4a0afd89cfcc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0749d432ed12b5ad4e4a0afd89cfcc76">&#9670;&nbsp;</a></span>detach_invite_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_invite_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_invite_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_invite_delete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_invite_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a3283aad1e815362ff1e489af5e216da3" title="Called when an invite is deleted from a guild.">dpp::cluster::on_invite_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a02df9a1442cc4748228b5349bd1286ad" name="a02df9a1442cc4748228b5349bd1286ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02df9a1442cc4748228b5349bd1286ad">&#9670;&nbsp;</a></span>detach_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_log event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_log</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#adbab2120fd480aeaca4d76802708320e" title="Called when a log message is to be written to the log. You can attach any logging system here you wis...">dpp::cluster::on_log()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="af1e7c6138397c0507013a293d7c8dfb7" name="af1e7c6138397c0507013a293d7c8dfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e7c6138397c0507013a293d7c8dfb7">&#9670;&nbsp;</a></span>detach_message_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_message_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_message_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_message_create event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#aaaafcd2c26fe588021454ee3d0d0fec8" title="Called when a new message arrives from discord. Note that D++ does not cache messages....">dpp::cluster::on_message_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a6f052123a147c6713b736a2ef8b5b24f" name="a6f052123a147c6713b736a2ef8b5b24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f052123a147c6713b736a2ef8b5b24f">&#9670;&nbsp;</a></span>detach_message_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_message_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_message_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_message_delete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a874df5eb51a2ab5ce006687b449207ec" title="Called when a message is deleted. The message has already been deleted from Discord when you receive ...">dpp::cluster::on_message_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="ab2aeb6d3e1348d04389577fde4bebada" name="ab2aeb6d3e1348d04389577fde4bebada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2aeb6d3e1348d04389577fde4bebada">&#9670;&nbsp;</a></span>detach_message_delete_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_message_delete_bulk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_message_delete_bulk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_message_delete_bulk event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_delete_bulk</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ad9d201a0a872eb18d73abcad10b0ceec" title="Called when multiple messages are deleted from a channel or DM.">dpp::cluster::on_message_delete_bulk()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="afe425bc201ab9d3058fd8cf7ef3287f0" name="afe425bc201ab9d3058fd8cf7ef3287f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe425bc201ab9d3058fd8cf7ef3287f0">&#9670;&nbsp;</a></span>detach_message_reaction_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_message_reaction_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_message_reaction_add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_message_reaction_add event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_add</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a2b998c5d26840d75933c7c48613c2abe" title="Called when a new reaction is added to a message.">dpp::cluster::on_message_reaction_add()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a09075271f76213392f7bbc3f8ef19c6a" name="a09075271f76213392f7bbc3f8ef19c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09075271f76213392f7bbc3f8ef19c6a">&#9670;&nbsp;</a></span>detach_message_reaction_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_message_reaction_remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_message_reaction_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_message_reaction_remove event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_remove</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a0d39347e77d032a3bd9d11f29fc753f9" title="Called when a single reaction is removed from a message.">dpp::cluster::on_message_reaction_remove()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="addf9410441b0b0b525b46e5335b098dc" name="addf9410441b0b0b525b46e5335b098dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf9410441b0b0b525b46e5335b098dc">&#9670;&nbsp;</a></span>detach_message_reaction_remove_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_message_reaction_remove_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_message_reaction_remove_all</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_message_reaction_remove_all event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_remove_all</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a7ba2fda7d5eaf854e8b27083521738a5" title="Called when all reactions are removed from a message.">dpp::cluster::on_message_reaction_remove_all()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a0c9dd859d5054cba8e2e0d7eb3c8a34b" name="a0c9dd859d5054cba8e2e0d7eb3c8a34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9dd859d5054cba8e2e0d7eb3c8a34b">&#9670;&nbsp;</a></span>detach_message_reaction_remove_emoji()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_message_reaction_remove_emoji </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_message_reaction_remove_emoji</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_message_reaction_remove_emoji event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_remove_emoji</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a68da8c59d05684d232e60ef3ca068c47" title="Called when all reactions for a particular emoji are removed from a message.">dpp::cluster::on_message_reaction_remove_emoji()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a0c4188de5ccc26bf335f640772326fd6" name="a0c4188de5ccc26bf335f640772326fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4188de5ccc26bf335f640772326fd6">&#9670;&nbsp;</a></span>detach_message_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_message_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_message_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_message_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ad66873c7ab2b1d86a9a353d889484944" title="Called when a message is updated (edited).">dpp::cluster::on_message_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a222adf2230d34a2767bbc2d8309fe3a9" name="a222adf2230d34a2767bbc2d8309fe3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222adf2230d34a2767bbc2d8309fe3a9">&#9670;&nbsp;</a></span>detach_presence_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_presence_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_presence_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_presence_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_presence_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a8484375dcceebd05c115ff4dbe58cb5b" title="Called when a user&#39;s presence is updated. To receive these you will need the GUILD_PRESENCES privileg...">dpp::cluster::on_presence_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a062bc58abb7ddc45c6e545a0792b5665" name="a062bc58abb7ddc45c6e545a0792b5665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062bc58abb7ddc45c6e545a0792b5665">&#9670;&nbsp;</a></span>detach_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_ready </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_ready</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_ready event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ready</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a598c59a3848bf30d82938fdd7f5813a3" title="Called when a shard is connected and ready. A set of on_guild_create events will follow this event.">dpp::cluster::on_ready()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a7cf616451ceb2605d472997c17cabdfc" name="a7cf616451ceb2605d472997c17cabdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf616451ceb2605d472997c17cabdfc">&#9670;&nbsp;</a></span>detach_resumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_resumed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_resumed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_resumed event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_resumed</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ac92176f33b0b70ddfb3a57ce35847692" title="Called when a connection to a shard successfully resumes. A resumed session does not need to re-synch...">dpp::cluster::on_resumed()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="ae74bca8b1d4dc3f6a2d27d53e7d3509a" name="ae74bca8b1d4dc3f6a2d27d53e7d3509a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74bca8b1d4dc3f6a2d27d53e7d3509a">&#9670;&nbsp;</a></span>detach_select_click()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_select_click </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_select_click</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_select_click event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_select_click</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a2ca854b9de47fc5eae411d072f6acff4" title="Called when a select menu is clicked attached to a message. Select menu clicks are triggered by disco...">dpp::cluster::on_select_click()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a549c1e6b226996ce1b4fbd12bd369d18" name="a549c1e6b226996ce1b4fbd12bd369d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549c1e6b226996ce1b4fbd12bd369d18">&#9670;&nbsp;</a></span>detach_stage_instance_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_stage_instance_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_stage_instance_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_stage_instance_create event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_stage_instance_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a7d7a98c044ea5b84612453b60b0b3850" title="Called when a new stage instance is created on a stage channel.">dpp::cluster::on_stage_instance_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a8a9c5b7a912e92e4e4a6ad72df560625" name="a8a9c5b7a912e92e4e4a6ad72df560625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9c5b7a912e92e4e4a6ad72df560625">&#9670;&nbsp;</a></span>detach_stage_instance_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_stage_instance_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_stage_instance_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_stage_instance_delete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_stage_instance_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a1e70453187414601a4e3593f5b99810c" title="Called when an existing stage instance is deleted from a stage channel.">dpp::cluster::on_stage_instance_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a8a04dc288d0af562e7ce947df5877bce" name="a8a04dc288d0af562e7ce947df5877bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a04dc288d0af562e7ce947df5877bce">&#9670;&nbsp;</a></span>detach_stage_instance_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_stage_instance_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_stage_instance_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_stage_instance_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_stage_instance_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a670c983ad24021e64c3efda9e937dd07" title="Called when a stage instance is updated.">dpp::cluster::on_stage_instance_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="ab223fa13c5509258857caf06ea6f5d81" name="ab223fa13c5509258857caf06ea6f5d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab223fa13c5509258857caf06ea6f5d81">&#9670;&nbsp;</a></span>detach_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_thread_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_thread_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_thread_create event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_create</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a4e4a35dd08b7c9e90cc338de3105423c" title="Called when a thread is created Note: Threads are not cached by D++, but a list of thread IDs is acce...">dpp::cluster::on_thread_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="affa31e287f586783edc6d5844d4396cf" name="affa31e287f586783edc6d5844d4396cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa31e287f586783edc6d5844d4396cf">&#9670;&nbsp;</a></span>detach_thread_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_thread_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_thread_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_thread_delete event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_delete</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ab9a96cbbac9227e14a125c21bab9d8d7" title="Called when a thread is deleted.">dpp::cluster::on_thread_delete()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="aeaec9dce7a9f8f8619579c990bf714f5" name="aeaec9dce7a9f8f8619579c990bf714f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaec9dce7a9f8f8619579c990bf714f5">&#9670;&nbsp;</a></span>detach_thread_list_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_thread_list_sync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_thread_list_sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_thread_list_sync event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_list_sync</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a148422098b97980a26de5effb6fba208" title="Called when thread list is synced (upon gaining access to a channel) Note: Threads are not cached by ...">dpp::cluster::on_thread_list_sync()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a567b3f5bf160831373933f058bd177d2" name="a567b3f5bf160831373933f058bd177d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567b3f5bf160831373933f058bd177d2">&#9670;&nbsp;</a></span>detach_thread_member_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_thread_member_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_thread_member_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_thread_member_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_member_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ae40e5e964c728a7e56b7b0379ef699db" title="Called when current user&#39;s thread member object is updated.">dpp::cluster::on_thread_member_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a284102ffbb5953325e4b8fb36155a7f7" name="a284102ffbb5953325e4b8fb36155a7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284102ffbb5953325e4b8fb36155a7f7">&#9670;&nbsp;</a></span>detach_thread_members_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_thread_members_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_thread_members_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_thread_members_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_members_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#abe9e5c58c9fe8b5cb7f98e3aaf3944d3" title="Called when a thread&#39;s member list is updated (without GUILD_MEMBERS intent, is only called for curre...">dpp::cluster::on_thread_members_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="ac6b22493483a49de30065ed9bd90b666" name="ac6b22493483a49de30065ed9bd90b666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b22493483a49de30065ed9bd90b666">&#9670;&nbsp;</a></span>detach_thread_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_thread_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_thread_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_thread_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a5047e0ea3ee5f77b92e10fdd8e7f1bb8" title="Called when a thread is updated.">dpp::cluster::on_thread_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="aa5639b37b839c21b8a7ae4716e72d2b7" name="aa5639b37b839c21b8a7ae4716e72d2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5639b37b839c21b8a7ae4716e72d2b7">&#9670;&nbsp;</a></span>detach_typing_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_typing_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_typing_start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_typing_start event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_typing_start</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a2981966cc8349aed024d9f8aaf5882e8" title="Called when a user is typing on a channel.">dpp::cluster::on_typing_start()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a65e0e647a6620c6b3cbd74f97134f120" name="a65e0e647a6620c6b3cbd74f97134f120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e0e647a6620c6b3cbd74f97134f120">&#9670;&nbsp;</a></span>detach_user_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_user_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_user_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_user_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_user_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#afa293c651143a9ccffb6090830eed3e5" title="Called when a user is updated. This is separate to guild_member_update and includes things such as an...">dpp::cluster::on_user_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="ab8d89e1aeb06cfef9fe246fad880fb7c" name="ab8d89e1aeb06cfef9fe246fad880fb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d89e1aeb06cfef9fe246fad880fb7c">&#9670;&nbsp;</a></span>detach_voice_buffer_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_voice_buffer_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_voice_buffer_send</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_voice_buffer_send event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_buffer_send</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ae1c915eafbf888a369278f21989f8476" title="Called when packets are sent from the voice buffer. The voice buffer contains packets that are alread...">dpp::cluster::on_voice_buffer_send()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a8d6b912887c0a0ed75be521b39934611" name="a8d6b912887c0a0ed75be521b39934611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6b912887c0a0ed75be521b39934611">&#9670;&nbsp;</a></span>detach_voice_client_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_voice_client_disconnect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_voice_client_disconnect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_voice_client_disconnect event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_client_disconnect</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ab6f6e8daa30e7ed1ebb9f9547ef89206" title="on voice client disconnect event">dpp::cluster::on_voice_client_disconnect()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a1c2cf7f141061299f9226c5d16de7016" name="a1c2cf7f141061299f9226c5d16de7016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2cf7f141061299f9226c5d16de7016">&#9670;&nbsp;</a></span>detach_voice_client_speaking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_voice_client_speaking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_voice_client_speaking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_voice_client_speaking event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_client_speaking</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a818e39c9b8ada848f03cd873a1eaf424" title="on voice client speaking event">dpp::cluster::on_voice_client_speaking()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a2f71ab5f93e806992228a7c2461c65e1" name="a2f71ab5f93e806992228a7c2461c65e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f71ab5f93e806992228a7c2461c65e1">&#9670;&nbsp;</a></span>detach_voice_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_voice_ready </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_voice_ready</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_voice_ready event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_ready</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#ad350f1c81f3c81d5128fe5d03bbfa711" title="Called when a voice channel is connected and ready to send audio. Note that this is not directly atta...">dpp::cluster::on_voice_ready()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a2cb9547eb81c13acd4059dfb81b9d752" name="a2cb9547eb81c13acd4059dfb81b9d752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb9547eb81c13acd4059dfb81b9d752">&#9670;&nbsp;</a></span>detach_voice_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_voice_receive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_voice_receive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_voice_receive event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_receive</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a1667f6fda196df3bb7f858e690ff91f3" title="Called when new audio data is received. Each separate user&#39;s audio from the voice channel will arrive...">dpp::cluster::on_voice_receive()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="aa8894dbcd25a4e288c9bdbf116db4277" name="aa8894dbcd25a4e288c9bdbf116db4277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8894dbcd25a4e288c9bdbf116db4277">&#9670;&nbsp;</a></span>detach_voice_server_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_voice_server_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_voice_server_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_voice_server_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_server_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a52b48bed7a6a1e0d0f824e66c839a7d8" title="Called when we are told which voice server we can use. This will be sent either when we establish a n...">dpp::cluster::on_voice_server_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="aa959ff17934bc9f044abf70c20ce5dd7" name="aa959ff17934bc9f044abf70c20ce5dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa959ff17934bc9f044abf70c20ce5dd7">&#9670;&nbsp;</a></span>detach_voice_state_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_voice_state_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_voice_state_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_voice_state_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_state_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a130b16feb7cb7f79a30401e95888109d" title="on voice state update event">dpp::cluster::on_voice_state_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="ac46e5cf28809fb46b5e1468b4081377c" name="ac46e5cf28809fb46b5e1468b4081377c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46e5cf28809fb46b5e1468b4081377c">&#9670;&nbsp;</a></span>detach_voice_track_marker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_voice_track_marker </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_voice_track_marker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_voice_track_marker event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_track_marker</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#a0777f715bdfd39c897f7ef93d67427a1" title="Called when sending of audio passes over a track marker. Track markers are arbitrarily placed &quot;bookma...">dpp::cluster::on_voice_track_marker()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a42f35e4e2f509df9137c203569883744" name="a42f35e4e2f509df9137c203569883744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f35e4e2f509df9137c203569883744">&#9670;&nbsp;</a></span>detach_voice_user_talking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_voice_user_talking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_voice_user_talking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_voice_user_talking event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_user_talking</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#aaee7911f1695b3873d6963260264d8ef" title="Called when a user is talking on a voice channel.">dpp::cluster::on_voice_user_talking()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="a781737ff70ccc19ee517025a7131aaf7" name="a781737ff70ccc19ee517025a7131aaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781737ff70ccc19ee517025a7131aaf7">&#9670;&nbsp;</a></span>detach_webhooks_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::detach_webhooks_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a>&#160;</td>
          <td class="paramname"><em>_webhooks_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach listener from on_webhooks_update event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_webhooks_update</td><td>Handle to remove from event, previously returned by <a class="el" href="classdpp_1_1cluster.html#afcf720a6c565961648577ebfb46bd716" title="Called when the webhooks for a guild are updated.">dpp::cluster::on_webhooks_update()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful detach of listener </dd></dl>

</div>
</div>
<a id="ae3a5e7d9ba9dcbfc1e219eeb029f61ad" name="ae3a5e7d9ba9dcbfc1e219eeb029f61ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a5e7d9ba9dcbfc1e219eeb029f61ad">&#9670;&nbsp;</a></span>direct_message_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::direct_message_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a direct message, also create the channel for the direct message if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_id</td><td>User ID of user to send message to </td></tr>
    <tr><td class="paramname">m</td><td>Message object </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af319c151f1b9b2b578d9303bab7ce5d0" name="af319c151f1b9b2b578d9303bab7ce5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af319c151f1b9b2b578d9303bab7ce5d0">&#9670;&nbsp;</a></span>edit_webhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::edit_webhook </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit webhook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Webhook to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1webhook.html" title="Represents a discord webhook.">dpp::webhook</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a37684f9d12edd4ca7d00296a5443b" name="a86a37684f9d12edd4ca7d00296a5443b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a37684f9d12edd4ca7d00296a5443b">&#9670;&nbsp;</a></span>edit_webhook_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::edit_webhook_message </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit webhook message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Webhook to edit message for </td></tr>
    <tr><td class="paramname">m</td><td>New message </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bffc1fa43d6a78814f9ca0f378755c5" name="a2bffc1fa43d6a78814f9ca0f378755c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bffc1fa43d6a78814f9ca0f378755c5">&#9670;&nbsp;</a></span>edit_webhook_with_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::edit_webhook_with_token </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit webhook with token (token is encapsulated in the webhook object) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Wehook to edit (should include token) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1webhook.html" title="Represents a discord webhook.">dpp::webhook</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5e83314cede8b9277a01b7b173abbad" name="ad5e83314cede8b9277a01b7b173abbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e83314cede8b9277a01b7b173abbad">&#9670;&nbsp;</a></span>execute_webhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::execute_webhook </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute webhook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Webhook to execute </td></tr>
    <tr><td class="paramname">m</td><td>Message to send </td></tr>
    <tr><td class="paramname">wait</td><td>waits for server confirmation of message send before response, and returns the created message body </td></tr>
    <tr><td class="paramname">thread_id</td><td>Send a message to the specified thread within a webhook's channel. The thread will automatically be unarchived </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ad36637b9bb094d9f24d18f204138a3" name="a9ad36637b9bb094d9f24d18f204138a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad36637b9bb094d9f24d18f204138a3">&#9670;&nbsp;</a></span>gdm_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::gdm_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>access_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a recipient to a Group DM using their access token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel id to add group DM recipients to </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to add </td></tr>
    <tr><td class="paramname">access_token</td><td>Access token from OAuth2 </td></tr>
    <tr><td class="paramname">nick</td><td>Nickname of user to apply to the chat </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6be231a13131f6fae94f88ee6fcdc5f0" name="a6be231a13131f6fae94f88ee6fcdc5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be231a13131f6fae94f88ee6fcdc5f0">&#9670;&nbsp;</a></span>gdm_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::gdm_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a recipient from a Group DM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel ID of group DM </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to remove from group DM </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7a2958625740b4a6fde6643042c5f7e" name="ab7a2958625740b4a6fde6643042c5f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a2958625740b4a6fde6643042c5f7e">&#9670;&nbsp;</a></span>get_audit_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dpp::cluster::get_audit_reason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the audit reason set for the next REST call to be made on this thread. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically. </p>
<dl class="section note"><dt>Note</dt><dd>This method call clears the audit reason when it returns it.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The audit reason to be used. </dd></dl>

</div>
</div>
<a id="ae58b1f27711b42e9aa8a21e34147429f" name="ae58b1f27711b42e9aa8a21e34147429f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58b1f27711b42e9aa8a21e34147429f">&#9670;&nbsp;</a></span>get_channel_webhooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_channel_webhooks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get channel webhooks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel ID to get webhooks for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1cb0cc074a1653521bab47f83498e9ca" title="A group of webhooks.">dpp::webhook_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6164d5543b7594731a980da9b0b2088" name="ae6164d5543b7594731a980da9b0b2088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6164d5543b7594731a980da9b0b2088">&#9670;&nbsp;</a></span>get_dm_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> dpp::cluster::get_dm_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dm channel for a user id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_id</td><td>the user id to get the dm channel for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on failure </dd></dl>

</div>
</div>
<a id="a68f16d04f100a0159683cba96e8c0a6c" name="a68f16d04f100a0159683cba96e8c0a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f16d04f100a0159683cba96e8c0a6c">&#9670;&nbsp;</a></span>get_gateway_bot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_gateway_bot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the gateway information for the bot using the token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1gateway.html" title="Represents the various information from the &#39;get gateway bot&#39; api call.">dpp::gateway</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d352afcbc0430ca11576386278da7d0" name="a8d352afcbc0430ca11576386278da7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d352afcbc0430ca11576386278da7d0">&#9670;&nbsp;</a></span>get_guild_webhooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_guild_webhooks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild webhooks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get webhooks for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1cb0cc074a1653521bab47f83498e9ca" title="A group of webhooks.">dpp::webhook_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c677c0d5c059e87cc01ce598d49487d" name="a5c677c0d5c059e87cc01ce598d49487d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c677c0d5c059e87cc01ce598d49487d">&#9670;&nbsp;</a></span>get_shard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1discord__client.html">discord_client</a> * dpp::cluster::get_shard </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a shard by id, returning the <a class="el" href="classdpp_1_1discord__client.html" title="Implements a discord client. Each discord_client connects to one shard and derives from a websocket c...">discord_client</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Shard ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>discord_client* shard, or null </dd></dl>

</div>
</div>
<a id="af4d6195862e6d25c644902631a0b34d1" name="af4d6195862e6d25c644902631a0b34d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d6195862e6d25c644902631a0b34d1">&#9670;&nbsp;</a></span>get_shards()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedpp.html#a13c4d4e6238396245b349e6a637897e0">shard_list</a> &amp; dpp::cluster::get_shards </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of shards. </p>
<dl class="section return"><dt>Returns</dt><dd>shard_list&amp; Reference to map of shards for this cluster </dd></dl>

</div>
</div>
<a id="af6d45a29b3976f7b623d92e70ab9a1bc" name="af6d45a29b3976f7b623d92e70ab9a1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d45a29b3976f7b623d92e70ab9a1bc">&#9670;&nbsp;</a></span>get_voice_regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_voice_regions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all voice regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#ae90871830444cab0316109a1824fc0b8" title="A group of voice regions.">dpp::voiceregion_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40e140f1e2eda9632828bce461bc7338" name="a40e140f1e2eda9632828bce461bc7338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e140f1e2eda9632828bce461bc7338">&#9670;&nbsp;</a></span>get_webhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_webhook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>webhook_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get webhook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">webhook_id</td><td>Webhook ID to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1webhook.html" title="Represents a discord webhook.">dpp::webhook</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8685b3bd821ab87342670d730689191e" name="a8685b3bd821ab87342670d730689191e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8685b3bd821ab87342670d730689191e">&#9670;&nbsp;</a></span>get_webhook_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_webhook_message </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get webhook message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Webhook to get the original message for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a770526895ed13e2dfb746decc3f0be67" name="a770526895ed13e2dfb746decc3f0be67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770526895ed13e2dfb746decc3f0be67">&#9670;&nbsp;</a></span>get_webhook_with_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_webhook_with_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>webhook_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get webhook using token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">webhook_id</td><td>Webhook ID to retrieve </td></tr>
    <tr><td class="paramname">token</td><td>Token of webhook </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1webhook.html" title="Represents a discord webhook.">dpp::webhook</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2319ca200dcd5cce1b9b6696946ece22" name="a2319ca200dcd5cce1b9b6696946ece22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2319ca200dcd5cce1b9b6696946ece22">&#9670;&nbsp;</a></span>global_bulk_command_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::global_bulk_command_create </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create/overwrite global slash commands. Any existing global slash commands will be deletd and replaced with these. </p>
<dl class="section note"><dt>Note</dt><dd>Global commands are cached by discord server-side and can take up to an hour to be visible. For testing, you should use <a class="el" href="classdpp_1_1cluster.html#aa7aad2d123fe4d13cb880ff59d8048f5" title="Create/overwrite guild slash commands. Any existing guild slash commands on this guild will be delete...">cluster::guild_bulk_command_create</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commands</td><td>Vector of slash commands to create/update. overwriting existing commands that are registered globally for this application. Updates will be available in all guilds after 1 hour. Commands that do not already exist will count toward daily application command create limits. </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a list of dpp::slashcommmand object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a124b1a52ca2f5ae298f1bb99ca964dcb" name="a124b1a52ca2f5ae298f1bb99ca964dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124b1a52ca2f5ae298f1bb99ca964dcb">&#9670;&nbsp;</a></span>global_command_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::global_command_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global slash command (a bot can have a maximum of 100 of these). </p>
<dl class="section note"><dt>Note</dt><dd>Global commands are cached by discord server-side and can take up to an hour to be visible. For testing, you should use <a class="el" href="classdpp_1_1cluster.html#a4c0ce1ad5256a252ab0ce43923a07ae3" title="Create a slash command local to a guild.">cluster::guild_command_create</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Slash command to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a dpp::slashcommmand object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cb7e2a8ddcb41a39d989802853a8605" name="a7cb7e2a8ddcb41a39d989802853a8605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb7e2a8ddcb41a39d989802853a8605">&#9670;&nbsp;</a></span>global_command_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::global_command_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a global slash command (a bot can have a maximum of 100 of these) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Slash command to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef037a47fee2efddedfe78ba4bf0467c" name="aef037a47fee2efddedfe78ba4bf0467c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef037a47fee2efddedfe78ba4bf0467c">&#9670;&nbsp;</a></span>global_command_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::global_command_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a global slash command (a bot can have a maximum of 100 of these) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Slash command to change </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a8cadcdde42fcfa8d29c0c4fd0bec5b" name="a8a8cadcdde42fcfa8d29c0c4fd0bec5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8cadcdde42fcfa8d29c0c4fd0bec5b">&#9670;&nbsp;</a></span>global_commands_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::global_commands_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the application's global slash commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#adfefe335636cdf5dbbba145a3828c554" title="A group of application slash commands.">dpp::slashcommand_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2937f10828bc3fbdeff87fc6b4463cc" name="aa2937f10828bc3fbdeff87fc6b4463cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2937f10828bc3fbdeff87fc6b4463cc">&#9670;&nbsp;</a></span>guild_add_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_add_member </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1guild__member.html">guild_member</a> &amp;&#160;</td>
          <td class="paramname"><em>gm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>access_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add guild member. Needs a specific oauth2 scope, from which you get the access_token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gm</td><td>Guild member to add </td></tr>
    <tr><td class="paramname">access_token</td><td>Access token from Oauth2 scope </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__member.html" title="Represents dpp::user membership upon a dpp::guild. This contains the user&#39;s nickname,...">dpp::guild_member</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74a61aa62ddf9207c197bfd496ae6ade" name="a74a61aa62ddf9207c197bfd496ae6ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a61aa62ddf9207c197bfd496ae6ade">&#9670;&nbsp;</a></span>guild_auditlog_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_auditlog_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the audit log for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to get the audit log of </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1auditlog.html" title="The auditlog class represents the audit log entry of a guild.">dpp::auditlog</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2273fdee237880d5e6b948198ffae52" name="ad2273fdee237880d5e6b948198ffae52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2273fdee237880d5e6b948198ffae52">&#9670;&nbsp;</a></span>guild_ban_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_ban_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delete_message_days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add guild ban. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to add ban to </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to ban </td></tr>
    <tr><td class="paramname">delete_message_days</td><td>How many days of ther user's messages to also delete </td></tr>
    <tr><td class="paramname">reason</td><td>Reason for ban </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1ban.html" title="The ban class represents a ban on a guild.">dpp::ban</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18f31527cd6b99cf2757e6c14dac5e5b" name="a18f31527cd6b99cf2757e6c14dac5e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f31527cd6b99cf2757e6c14dac5e5b">&#9670;&nbsp;</a></span>guild_ban_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_ban_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete guild ban. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to delete ban from </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to delete ban for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2102835f11fabbc2cd2e6b41155783f6" name="a2102835f11fabbc2cd2e6b41155783f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2102835f11fabbc2cd2e6b41155783f6">&#9670;&nbsp;</a></span>guild_begin_prune()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_begin_prune </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1prune.html">prune</a> &amp;&#160;</td>
          <td class="paramname"><em>pruneinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin guild prune. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to prune </td></tr>
    <tr><td class="paramname">pruneinfo</td><td>Pruning info </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1prune.html" title="Defines a request to count prunable users, or start a prune operation.">dpp::prune</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7aad2d123fe4d13cb880ff59d8048f5" name="aa7aad2d123fe4d13cb880ff59d8048f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7aad2d123fe4d13cb880ff59d8048f5">&#9670;&nbsp;</a></span>guild_bulk_command_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_bulk_command_create </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create/overwrite guild slash commands. Any existing guild slash commands on this guild will be deleted and replaced with these. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commands</td><td>Vector of slash commands to create/update. New guild commands will be available in the guild immediately. If the command did not already exist, it will count toward daily application command create limits. </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID to create/update the slash commands in </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a list of dpp::slashcommmand object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0ce1ad5256a252ab0ce43923a07ae3" name="a4c0ce1ad5256a252ab0ce43923a07ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0ce1ad5256a252ab0ce43923a07ae3">&#9670;&nbsp;</a></span>guild_command_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_command_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a slash command local to a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Slash command to create </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID to create the slash command in </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a dpp::slashcommmand object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b4a91a572c4e33ae60a3b09041ae3c2" name="a5b4a91a572c4e33ae60a3b09041ae3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4a91a572c4e33ae60a3b09041ae3c2">&#9670;&nbsp;</a></span>guild_command_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_command_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a slash command local to a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Slash command to delete </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID to delete the slash command in </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d555ccc3e69298ccac9d160ce3a71bf" name="a4d555ccc3e69298ccac9d160ce3a71bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d555ccc3e69298ccac9d160ce3a71bf">&#9670;&nbsp;</a></span>guild_command_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_command_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a slash command local to a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Slash command to edit </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID to edit the slash command in </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ebb701d07c25d3667f0e1640670bbc1" name="a4ebb701d07c25d3667f0e1640670bbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebb701d07c25d3667f0e1640670bbc1">&#9670;&nbsp;</a></span>guild_command_edit_permissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_command_edit_permissions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit slash command permissions local to a guild, permissions are read from s.permissions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Slash command to edit </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID to edit the slash command in </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01623d7535dc359905990e710ae3b5e9" name="a01623d7535dc359905990e710ae3b5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01623d7535dc359905990e710ae3b5e9">&#9670;&nbsp;</a></span>guild_commands_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_commands_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the application's slash commands for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get the slash commands for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#adfefe335636cdf5dbbba145a3828c554" title="A group of application slash commands.">dpp::slashcommand_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af327d6e65c703ce001d666ef2adc4b25" name="af327d6e65c703ce001d666ef2adc4b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af327d6e65c703ce001d666ef2adc4b25">&#9670;&nbsp;</a></span>guild_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1guild.html">guild</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Guild to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad277277c10ccdaecc3869a23d9ecb94b" name="ad277277c10ccdaecc3869a23d9ecb94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad277277c10ccdaecc3869a23d9ecb94b">&#9670;&nbsp;</a></span>guild_create_from_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_create_from_template </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new guild based on a template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Template code to create guild from </td></tr>
    <tr><td class="paramname">name</td><td>Guild name to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a78935110be8ea8bf5fdc4f0734fd28" name="a8a78935110be8ea8bf5fdc4f0734fd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a78935110be8ea8bf5fdc4f0734fd28">&#9670;&nbsp;</a></span>guild_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0db4a48d1ebc2133c30963a995e156e1" name="a0db4a48d1ebc2133c30963a995e156e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db4a48d1ebc2133c30963a995e156e1">&#9670;&nbsp;</a></span>guild_delete_integration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_delete_integration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>integration_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete guild integration. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to delete integration for </td></tr>
    <tr><td class="paramname">integration_id</td><td>Integration ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b0ce3857773519ca2ed62b49c04f267" name="a5b0ce3857773519ca2ed62b49c04f267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0ce3857773519ca2ed62b49c04f267">&#9670;&nbsp;</a></span>guild_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_edit </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1guild.html">guild</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Guild to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57a1957b81c9606850e730c477dd44aa" name="a57a1957b81c9606850e730c477dd44aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a1957b81c9606850e730c477dd44aa">&#9670;&nbsp;</a></span>guild_edit_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_edit_member </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1guild__member.html">guild_member</a> &amp;&#160;</td>
          <td class="paramname"><em>gm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit the properties of an existing guild member. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gm</td><td>Guild member to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__member.html" title="Represents dpp::user membership upon a dpp::guild. This contains the user&#39;s nickname,...">dpp::guild_member</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb37eaa792a69f43171f580695fd4520" name="afb37eaa792a69f43171f580695fd4520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb37eaa792a69f43171f580695fd4520">&#9670;&nbsp;</a></span>guild_edit_widget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_edit_widget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1guild__widget.html">guild_widget</a> &amp;&#160;</td>
          <td class="paramname"><em>gw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit guild widget. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to edit widget for </td></tr>
    <tr><td class="paramname">gw</td><td>New guild widget information </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__widget.html" title="Represents a guild widget, simple web widget of member list.">dpp::guild_widget</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f6d9dbdb2009bdea2fad46e93813af5" name="a5f6d9dbdb2009bdea2fad46e93813af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6d9dbdb2009bdea2fad46e93813af5">&#9670;&nbsp;</a></span>guild_emoji_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_emoji_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1emoji.html">emoji</a> &amp;&#160;</td>
          <td class="paramname"><em>newemoji</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create single emoji. You must ensure that the emoji passed contained image data using the <a class="el" href="classdpp_1_1emoji.html#a33694c119238d58da105c55fdf9dbcd9" title="Load an image into the object as base64.">emoji::load_image()</a> method. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to create emoji om </td></tr>
    <tr><td class="paramname">newemoji</td><td>Emoji to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1emoji.html" title="Represents an emoji for a dpp::guild.">dpp::emoji</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9c8f4357998bc8a77e8561edcb738c3" name="af9c8f4357998bc8a77e8561edcb738c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c8f4357998bc8a77e8561edcb738c3">&#9670;&nbsp;</a></span>guild_emoji_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_emoji_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>emoji_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a guild emoji. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to delete emoji on </td></tr>
    <tr><td class="paramname">emoji_id</td><td>Emoji ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c4bf8c1767b71ed06bfa407341096d4" name="a2c4bf8c1767b71ed06bfa407341096d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4bf8c1767b71ed06bfa407341096d4">&#9670;&nbsp;</a></span>guild_emoji_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_emoji_edit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1emoji.html">emoji</a> &amp;&#160;</td>
          <td class="paramname"><em>newemoji</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a single emoji. You must ensure that the emoji passed contained image data using the <a class="el" href="classdpp_1_1emoji.html#a33694c119238d58da105c55fdf9dbcd9" title="Load an image into the object as base64.">emoji::load_image()</a> method. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to edit emoji on </td></tr>
    <tr><td class="paramname">newemoji</td><td>Emoji to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1emoji.html" title="Represents an emoji for a dpp::guild.">dpp::emoji</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada721a222fb3a42a1a1bb6d93dfcc745" name="ada721a222fb3a42a1a1bb6d93dfcc745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada721a222fb3a42a1a1bb6d93dfcc745">&#9670;&nbsp;</a></span>guild_emoji_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_emoji_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>emoji_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a single emoji. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get emoji for </td></tr>
    <tr><td class="paramname">emoji_id</td><td>Emoji ID to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1emoji.html" title="Represents an emoji for a dpp::guild.">dpp::emoji</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad66ab98a72eb1ba8d2686fcaa1eb49db" name="ad66ab98a72eb1ba8d2686fcaa1eb49db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66ab98a72eb1ba8d2686fcaa1eb49db">&#9670;&nbsp;</a></span>guild_emojis_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_emojis_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all emojis for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get emojis for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a58e2720e1ccc11d2b3b1be2e18df79d9" title="Group of emojis.">dpp::emoji_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04dc202cee249447c1a135a80a852daf" name="a04dc202cee249447c1a135a80a852daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dc202cee249447c1a135a80a852daf">&#9670;&nbsp;</a></span>guild_event_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_event_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1scheduled__event.html">scheduled_event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scheduled event on a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to create (guild ID must be populated) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1d8eeeaca0cdc14125cbf2f4f0722781" title="A group of scheduled events.">dpp::scheduled_event_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17bec34914c433a1105697dd5c24c7f2" name="a17bec34914c433a1105697dd5c24c7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bec34914c433a1105697dd5c24c7f2">&#9670;&nbsp;</a></span>guild_event_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_event_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>event_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a scheduled event from a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>Event ID to delete </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID of event to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36b82a96ca6b744388e9b290cbf775ff" name="a36b82a96ca6b744388e9b290cbf775ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b82a96ca6b744388e9b290cbf775ff">&#9670;&nbsp;</a></span>guild_event_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_event_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1scheduled__event.html">scheduled_event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit/modify a scheduled event on a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to create (event ID and guild ID must be populated) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1d8eeeaca0cdc14125cbf2f4f0722781" title="A group of scheduled events.">dpp::scheduled_event_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b8c168682519ee125ed0a48239c08ef" name="a5b8c168682519ee125ed0a48239c08ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8c168682519ee125ed0a48239c08ef">&#9670;&nbsp;</a></span>guild_event_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_event_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>event_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a scheduled event for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to get event for </td></tr>
    <tr><td class="paramname">event_id</td><td>Event ID to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1scheduled__event.html" title="A scheduled event.">dpp::scheduled_event</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09f6a78b9b2ad6218ed1b8c7b044013a" name="a09f6a78b9b2ad6218ed1b8c7b044013a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f6a78b9b2ad6218ed1b8c7b044013a">&#9670;&nbsp;</a></span>guild_event_users_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_event_users_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>event_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>before</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>after</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get users RSVP'd to an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to get user list for </td></tr>
    <tr><td class="paramname">event_id</td><td>Guild to get user list for </td></tr>
    <tr><td class="paramname">limit</td><td>Maximum number of results to return </td></tr>
    <tr><td class="paramname">before</td><td>Return user IDs that fall before this ID, if provided </td></tr>
    <tr><td class="paramname">after</td><td>Return user IDs that fall after this ID, if provided </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1c4073c92e19579c06591033a4a234e1">dpp::user_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8554f93aed5fb84162af41c997fc1e3" name="ae8554f93aed5fb84162af41c997fc1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8554f93aed5fb84162af41c997fc1e3">&#9670;&nbsp;</a></span>guild_events_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_events_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all scheduled events for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to get events for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1d8eeeaca0cdc14125cbf2f4f0722781" title="A group of scheduled events.">dpp::scheduled_event_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a003669770549d25a951810bff0153e" name="a6a003669770549d25a951810bff0153e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a003669770549d25a951810bff0153e">&#9670;&nbsp;</a></span>guild_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Guild ID to retrieve </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad871d30ed11d0799da4a831ede8a7d95" name="ad871d30ed11d0799da4a831ede8a7d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad871d30ed11d0799da4a831ede8a7d95">&#9670;&nbsp;</a></span>guild_get_ban()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_ban </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get single guild ban. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get ban for </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID of ban to retrieve </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1ban.html" title="The ban class represents a ban on a guild.">dpp::ban</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9fffa4f080e0b5abab1417fa8eb1b0f" name="af9fffa4f080e0b5abab1417fa8eb1b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fffa4f080e0b5abab1417fa8eb1b0f">&#9670;&nbsp;</a></span>guild_get_bans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_bans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild ban list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get bans for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a52b195380df96e9c43f35fa2da82db14">dpp::ban_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43cba3bd187f9b28dcaed5b4f4ed5bda" name="a43cba3bd187f9b28dcaed5b4f4ed5bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cba3bd187f9b28dcaed5b4f4ed5bda">&#9670;&nbsp;</a></span>guild_get_integrations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_integrations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild itegrations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get integrations for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#aa13e2c5898009fad42ebe12fd5641d8a">dpp::integration_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93c0e07243611419141305da123c859a" name="a93c0e07243611419141305da123c859a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c0e07243611419141305da123c859a">&#9670;&nbsp;</a></span>guild_get_invites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_invites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild invites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get invites for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#aa85b043fd45cf24caa23ab6004a2415a">dpp::invite_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99e8227f11ef33cd2d9cc3abef46adfd" name="a99e8227f11ef33cd2d9cc3abef46adfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e8227f11ef33cd2d9cc3abef46adfd">&#9670;&nbsp;</a></span>guild_get_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_member </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a guild member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get member for </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID of member to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__member.html" title="Represents dpp::user membership upon a dpp::guild. This contains the user&#39;s nickname,...">dpp::guild_member</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b24baba4de9d38f7d9a7cea2f71a545" name="a6b24baba4de9d38f7d9a7cea2f71a545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b24baba4de9d38f7d9a7cea2f71a545">&#9670;&nbsp;</a></span>guild_get_members()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_members </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all guild members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get all members for </td></tr>
    <tr><td class="paramname">limit</td><td>max number of members to return (1-1000) </td></tr>
    <tr><td class="paramname">after</td><td>the highest user id in the previous page </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a219aedbe5bf37835c4a65115fccba278">dpp::guild_member_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ecd82c6169107c9c944356f19abba9e" name="a3ecd82c6169107c9c944356f19abba9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecd82c6169107c9c944356f19abba9e">&#9670;&nbsp;</a></span>guild_get_preview()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_preview </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a guild preview. Returns a guild object but only a subset of the fields will be populated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Guild ID to retrieve </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad296f07bd5b9f900dcedbf88c464e09" name="aad296f07bd5b9f900dcedbf88c464e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad296f07bd5b9f900dcedbf88c464e09">&#9670;&nbsp;</a></span>guild_get_prune_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_prune_counts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1prune.html">prune</a> &amp;&#160;</td>
          <td class="paramname"><em>pruneinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get prune counts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to count for pruning </td></tr>
    <tr><td class="paramname">pruneinfo</td><td>Pruning info </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1prune.html" title="Defines a request to count prunable users, or start a prune operation.">dpp::prune</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1332e45cc89e871009e840c25145df5" name="ad1332e45cc89e871009e840c25145df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1332e45cc89e871009e840c25145df5">&#9670;&nbsp;</a></span>guild_get_vanity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_vanity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild vanity url, if enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to get vanity URL for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1invite.html" title="Represents an invite to a discord guild or channel.">dpp::invite</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a> filled to match the vanity url. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5556385a69a408a268332f774ba6c3c" name="ae5556385a69a408a268332f774ba6c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5556385a69a408a268332f774ba6c3c">&#9670;&nbsp;</a></span>guild_get_voice_regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_voice_regions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild voice regions. Voice regions per guild are somewhat deprecated in preference of per-channel voice regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get voice regions for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#ae90871830444cab0316109a1824fc0b8" title="A group of voice regions.">dpp::voiceregion_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57626c7a0e06aee1c362b986e44030c2" name="a57626c7a0e06aee1c362b986e44030c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57626c7a0e06aee1c362b986e44030c2">&#9670;&nbsp;</a></span>guild_get_widget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_widget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild widget. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get widget for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__widget.html" title="Represents a guild widget, simple web widget of member list.">dpp::guild_widget</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9dcac8996e5eaad9b1eed9983ecefef" name="aa9dcac8996e5eaad9b1eed9983ecefef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9dcac8996e5eaad9b1eed9983ecefef">&#9670;&nbsp;</a></span>guild_member_add_role()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_member_add_role </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>role_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add role to guild member. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to add a role to </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to add role to </td></tr>
    <tr><td class="paramname">role_id</td><td>Role ID to add to the user </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58be46d2934738b32229d984c266a4b7" name="a58be46d2934738b32229d984c266a4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58be46d2934738b32229d984c266a4b7">&#9670;&nbsp;</a></span>guild_member_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_member_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove (kick) a guild member. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to kick member from </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to kick </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0289849ef90572a331e68fc84075cb2" name="af0289849ef90572a331e68fc84075cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0289849ef90572a331e68fc84075cb2">&#9670;&nbsp;</a></span>guild_member_delete_role()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_member_delete_role </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>role_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove role from guild member. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to remove role from user on </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to remove role from </td></tr>
    <tr><td class="paramname">role_id</td><td>Role to remove </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40665f55528cfc1077b8adcae2d49086" name="a40665f55528cfc1077b8adcae2d49086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40665f55528cfc1077b8adcae2d49086">&#9670;&nbsp;</a></span>guild_member_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_member_move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the guild member to a other voice channel, if member is connected to one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Id of the channel to which the user is used </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild id to which the user is connected </td></tr>
    <tr><td class="paramname">user_id</td><td>User id, who should be moved </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__member.html" title="Represents dpp::user membership upon a dpp::guild. This contains the user&#39;s nickname,...">dpp::guild_member</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb07fc90589ee936f73da5551cff1255" name="afb07fc90589ee936f73da5551cff1255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb07fc90589ee936f73da5551cff1255">&#9670;&nbsp;</a></span>guild_modify_integration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_modify_integration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1integration.html">integration</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify guild integration. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to modify integration for </td></tr>
    <tr><td class="paramname">i</td><td>Integration to modify </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1integration.html" title="Represents an integration on a guild, e.g. a connection to twitch.">dpp::integration</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52cc92ce052d063854e0372539e4d9ee" name="a52cc92ce052d063854e0372539e4d9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52cc92ce052d063854e0372539e4d9ee">&#9670;&nbsp;</a></span>guild_search_members()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_search_members </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for guild members based on whether their username or nickname starts with the given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to search in </td></tr>
    <tr><td class="paramname">query</td><td>Query string to match username(s) and nickname(s) against </td></tr>
    <tr><td class="paramname">limit</td><td>max number of members to return (1-1000) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a219aedbe5bf37835c4a65115fccba278">dpp::guild_member_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa30ff4f80815720bafab51f9bc86b089" name="aa30ff4f80815720bafab51f9bc86b089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30ff4f80815720bafab51f9bc86b089">&#9670;&nbsp;</a></span>guild_set_nickname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_set_nickname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nickname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change current user nickname. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to change nickanem on </td></tr>
    <tr><td class="paramname">nickname</td><td>New nickname, or empty string to clear nickname </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f31d36f327a74d24fb4075cec6c2400" name="a7f31d36f327a74d24fb4075cec6c2400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f31d36f327a74d24fb4075cec6c2400">&#9670;&nbsp;</a></span>guild_sticker_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_sticker_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdpp_1_1sticker.html">sticker</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sticker in a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Sticker to create. Must have its guild ID set. </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08ed56cd299340bdf286bc3457225124" name="a08ed56cd299340bdf286bc3457225124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ed56cd299340bdf286bc3457225124">&#9670;&nbsp;</a></span>guild_sticker_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_sticker_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>sticker_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a sticker from a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sticker_id</td><td>sticker ID to delete </td></tr>
    <tr><td class="paramname">guild_id</td><td>guild ID to delete from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7a2d335385b4689e7489d0eaf4475fe" name="ac7a2d335385b4689e7489d0eaf4475fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2d335385b4689e7489d0eaf4475fe">&#9670;&nbsp;</a></span>guild_sticker_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_sticker_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a guild sticker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of sticker to get. </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID of the guild where the sticker is </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a222a8cb4498fd65ae8bb3345b02d0f8e" name="a222a8cb4498fd65ae8bb3345b02d0f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222a8cb4498fd65ae8bb3345b02d0f8e">&#9670;&nbsp;</a></span>guild_sticker_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_sticker_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdpp_1_1sticker.html">sticker</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a sticker in a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Sticker to modify. Must have its guild ID and sticker ID set. </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adccd1468d3f031c5bc786fdbd087d0a2" name="adccd1468d3f031c5bc786fdbd087d0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccd1468d3f031c5bc786fdbd087d0a2">&#9670;&nbsp;</a></span>guild_stickers_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_stickers_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all guild stickers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID of the guild where the sticker is </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58d976f9d101225e05482db7b739f986" name="a58d976f9d101225e05482db7b739f986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d976f9d101225e05482db7b739f986">&#9670;&nbsp;</a></span>guild_sync_integration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_sync_integration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>integration_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sync guild integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to sync integration on </td></tr>
    <tr><td class="paramname">integration_id</td><td>Integration ID to synchronise </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38db2ce96431b742e98cabf8170a84d7" name="a38db2ce96431b742e98cabf8170a84d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38db2ce96431b742e98cabf8170a84d7">&#9670;&nbsp;</a></span>guild_template_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_template_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a template for the guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to create template from </td></tr>
    <tr><td class="paramname">name</td><td>Template name to create </td></tr>
    <tr><td class="paramname">description</td><td>Description of template to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91791a9d280c0973834223df37d39ac8" name="a91791a9d280c0973834223df37d39ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91791a9d280c0973834223df37d39ac8">&#9670;&nbsp;</a></span>guild_template_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_template_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID of template to delete </td></tr>
    <tr><td class="paramname">code</td><td>Template code to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22f9702b44025f54cf03920d3a3e554b" name="a22f9702b44025f54cf03920d3a3e554b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f9702b44025f54cf03920d3a3e554b">&#9670;&nbsp;</a></span>guild_template_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_template_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the template's metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID of template to modify </td></tr>
    <tr><td class="paramname">code</td><td>Template code to modify </td></tr>
    <tr><td class="paramname">name</td><td>New name of template </td></tr>
    <tr><td class="paramname">description</td><td>New description of template </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fc2ed8ec7e7550daa418f693ade1016" name="a3fc2ed8ec7e7550daa418f693ade1016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc2ed8ec7e7550daa418f693ade1016">&#9670;&nbsp;</a></span>guild_template_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_template_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syncs the template to the guild's current state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to synchronise template for </td></tr>
    <tr><td class="paramname">code</td><td>Code of template to synchronise </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1faa321ede15b209c789ea1155a3d356" name="a1faa321ede15b209c789ea1155a3d356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faa321ede15b209c789ea1155a3d356">&#9670;&nbsp;</a></span>guild_templates_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_templates_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild templates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get templates for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a0d9e1952e25391a3379ee3db2d930bf7">dpp::guild_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c92a68228fe9dcb96b1c7cb6b8ae795" name="a4c92a68228fe9dcb96b1c7cb6b8ae795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c92a68228fe9dcb96b1c7cb6b8ae795">&#9670;&nbsp;</a></span>interaction_response_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::interaction_response_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>interaction_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1interaction__response.html">interaction_response</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Respond to a slash command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interaction_id</td><td>Interaction id to respond to </td></tr>
    <tr><td class="paramname">token</td><td>Token for the interaction webhook </td></tr>
    <tr><td class="paramname">r</td><td>Response to send </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41c9c18dd9185dfc2cc61b463ad7cf0f" name="a41c9c18dd9185dfc2cc61b463ad7cf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c9c18dd9185dfc2cc61b463ad7cf0f">&#9670;&nbsp;</a></span>interaction_response_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::interaction_response_edit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Respond to a slash command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Token for the interaction webhook </td></tr>
    <tr><td class="paramname">r</td><td>Message to send </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c22698fbbb32edebd9824309015a017" name="a4c22698fbbb32edebd9824309015a017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c22698fbbb32edebd9824309015a017">&#9670;&nbsp;</a></span>invite_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::invite_delete </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>invite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an invite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invite</td><td>Invite code to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a4d4220a93d6ba8c72d5472fd6718d0" name="a4a4d4220a93d6ba8c72d5472fd6718d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4d4220a93d6ba8c72d5472fd6718d0">&#9670;&nbsp;</a></span>invite_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::invite_get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>invite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get details about an invite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invite</td><td>Invite code to get information on </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1invite.html" title="Represents an invite to a discord guild or channel.">dpp::invite</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13689440c9cc80279d415c563a6363c0" name="a13689440c9cc80279d415c563a6363c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13689440c9cc80279d415c563a6363c0">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a7d48d478ccc3bffb34637bdb48f629c2">dpp::loglevel</a>&#160;</td>
          <td class="paramname"><em>severity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log a message to whatever log the user is using. The logged message is passed up the chain to the on_log event in user code which can then do whatever it wants to do with it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">severity</td><td>The log level from <a class="el" href="namespacedpp.html#a7d48d478ccc3bffb34637bdb48f629c2" title="Log levels.">dpp::loglevel</a> </td></tr>
    <tr><td class="paramname">msg</td><td>The log message to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08eb4e0352a29a92587d677d4b5fd6a7" name="a08eb4e0352a29a92587d677d4b5fd6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eb4e0352a29a92587d677d4b5fd6a7">&#9670;&nbsp;</a></span>message_add_reaction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_add_reaction </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a reaction to a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to add a reaction to </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to add. Emojis should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c38aa5a7737577fbafcd67a783c60d1" name="a8c38aa5a7737577fbafcd67a783c60d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c38aa5a7737577fbafcd67a783c60d1">&#9670;&nbsp;</a></span>message_add_reaction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_add_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a reaction to a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to add reactions to </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to add reactions to </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to add. Emojis should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a080a8cefc6ceb0b882fdb6fe70c078a6" name="a080a8cefc6ceb0b882fdb6fe70c078a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080a8cefc6ceb0b882fdb6fe70c078a6">&#9670;&nbsp;</a></span>message_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_create </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to a channel. The callback function is called when the message has been sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to send </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cdf2c55ac48902e7b194ab8e651d869" name="a8cdf2c55ac48902e7b194ab8e651d869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdf2c55ac48902e7b194ab8e651d869">&#9670;&nbsp;</a></span>message_crosspost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_crosspost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crosspost a message. The callback function is called when the message has been sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to crosspost </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel ID to crosspost from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb75919ec5abd5b510255692ef439f97" name="abb75919ec5abd5b510255692ef439f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb75919ec5abd5b510255692ef439f97">&#9670;&nbsp;</a></span>message_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a message from a channel. The callback function is called when the message has been edited. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message ID to delete </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13ae40b4389928ce8e6f8d9b47512291" name="a13ae40b4389928ce8e6f8d9b47512291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ae40b4389928ce8e6f8d9b47512291">&#9670;&nbsp;</a></span>message_delete_all_reactions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_all_reactions </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all reactions on a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a253f894d05325a56d85663a4759288a2" name="a253f894d05325a56d85663a4759288a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253f894d05325a56d85663a4759288a2">&#9670;&nbsp;</a></span>message_delete_all_reactions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_all_reactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all reactions on a message by id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete reactions from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4534c2c87bf45c326b126ef0a00ee80" name="ab4534c2c87bf45c326b126ef0a00ee80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4534c2c87bf45c326b126ef0a00ee80">&#9670;&nbsp;</a></span>message_delete_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_bulk </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>message_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk delete messages from a channel. The callback function is called when the message has been edited. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_ids</td><td>List of message IDs to delete (maximum of 100 message IDs) </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba9abca51107d5aed147fa9b0aa8d675" name="aba9abca51107d5aed147fa9b0aa8d675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9abca51107d5aed147fa9b0aa8d675">&#9670;&nbsp;</a></span>message_delete_own_reaction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_own_reaction </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete own reaction from a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to delete own reaction from </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to delete. The reaction should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b18295b9fc438b84c21cc5dd60db8db" name="a3b18295b9fc438b84c21cc5dd60db8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b18295b9fc438b84c21cc5dd60db8db">&#9670;&nbsp;</a></span>message_delete_own_reaction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_own_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete own reaction from a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete reactions from </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to delete. The reaction should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72b04160e95d808013fe222a9b690dae" name="a72b04160e95d808013fe222a9b690dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b04160e95d808013fe222a9b690dae">&#9670;&nbsp;</a></span>message_delete_reaction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_reaction </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a user's reaction from a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to delete a user's reaction from </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID who's reaction you want to remove </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to remove. Reactions should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b157698d6c65e96a6a96ef93fee9f56" name="a0b157698d6c65e96a6a96ef93fee9f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b157698d6c65e96a6a96ef93fee9f56">&#9670;&nbsp;</a></span>message_delete_reaction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a user's reaction from a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete reactions from </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID who's reaction you want to remove </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to remove. Reactions should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a1478ca3f0fb3c645a34474099e4e04" name="a6a1478ca3f0fb3c645a34474099e4e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1478ca3f0fb3c645a34474099e4e04">&#9670;&nbsp;</a></span>message_delete_reaction_emoji() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_reaction_emoji </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all reactions on a message using a particular emoji. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to delete, in the form emojiname:id or a unicode character </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a144ffe65c0dda699e586f78c61649bf5" name="a144ffe65c0dda699e586f78c61649bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144ffe65c0dda699e586f78c61649bf5">&#9670;&nbsp;</a></span>message_delete_reaction_emoji() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_reaction_emoji </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all reactions on a message using a particular emoji by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete reactions from </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to delete, in the form emojiname:id or a unicode character </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a754206a7e97f1aaab4ab83ed53e4f351" name="a754206a7e97f1aaab4ab83ed53e4f351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754206a7e97f1aaab4ab83ed53e4f351">&#9670;&nbsp;</a></span>message_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_edit </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a message on a channel. The callback function is called when the message has been edited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d3b0f7c3dae4ecb1980cabe8f10ccd7" name="a9d3b0f7c3dae4ecb1980cabe8f10ccd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3b0f7c3dae4ecb1980cabe8f10ccd7">&#9670;&nbsp;</a></span>message_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message ID </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel ID </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab05fea3d6c298d5f2371704084383f8f" name="ab05fea3d6c298d5f2371704084383f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05fea3d6c298d5f2371704084383f8f">&#9670;&nbsp;</a></span>message_get_reactions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_get_reactions </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get reactions on a message for a particular emoji. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to get reactions for </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction should be in the form emojiname:id or a unicode character </td></tr>
    <tr><td class="paramname">before</td><td>Reactions before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">after</td><td>Reactions before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">limit</td><td>This number of reactions maximum should be returned </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1c4073c92e19579c06591033a4a234e1">dpp::user_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06083a6cacaf7c4e41884cfb2a1078ab" name="a06083a6cacaf7c4e41884cfb2a1078ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06083a6cacaf7c4e41884cfb2a1078ab">&#9670;&nbsp;</a></span>message_get_reactions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_get_reactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get reactions on a message for a particular emoji by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to get reactions for </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to get reactions for </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction should be in the form emojiname:id or a unicode character </td></tr>
    <tr><td class="paramname">before</td><td>Reactions before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">after</td><td>Reactions before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">limit</td><td>This number of reactions maximum should be returned </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1c4073c92e19579c06591033a4a234e1">dpp::user_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa140a11ab0b2feede600761aaee2483b" name="aa140a11ab0b2feede600761aaee2483b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa140a11ab0b2feede600761aaee2483b">&#9670;&nbsp;</a></span>message_pin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_pin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pin a message. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel id to pin message on </td></tr>
    <tr><td class="paramname">message_id</td><td>Message id to pin message on </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a454e53cea10416ca9d299855dbb08e0b" name="a454e53cea10416ca9d299855dbb08e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454e53cea10416ca9d299855dbb08e0b">&#9670;&nbsp;</a></span>message_unpin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_unpin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpin a message. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel id to unpin message on </td></tr>
    <tr><td class="paramname">message_id</td><td>Message id to unpin message on </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a630d744322d1f570a63f33ae10b23ae9" name="a630d744322d1f570a63f33ae10b23ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630d744322d1f570a63f33ae10b23ae9">&#9670;&nbsp;</a></span>messages_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::messages_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>around</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get multiple messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel ID to retrieve messages for </td></tr>
    <tr><td class="paramname">around</td><td>Messages should be retrieved around this ID if this is set to non-zero </td></tr>
    <tr><td class="paramname">before</td><td>Messages before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">after</td><td>Messages before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">limit</td><td>This number of messages maximum should be returned </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a44d4dd39b5d7c24c5fe97a76a73cf708">dpp::message_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a115a49075ceb1817f1e81fc9388bf65e" name="a115a49075ceb1817f1e81fc9388bf65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115a49075ceb1817f1e81fc9388bf65e">&#9670;&nbsp;</a></span>nitro_sticker_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::nitro_sticker_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a nitro sticker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of sticker to get. </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e4c89e99887415ff9309d704f2899ac" name="a5e4c89e99887415ff9309d704f2899ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4c89e99887415ff9309d704f2899ac">&#9670;&nbsp;</a></span>on_application_command_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_application_command_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1application__command__create__t.html">application_command_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_application_command_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new application command (slash command) is registered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_application_command_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1application__command__create__t.html" title="Create application slash command.">dpp::application_command_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0f244bc712531ce761c51fdcc61d96a2" name="a0f244bc712531ce761c51fdcc61d96a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f244bc712531ce761c51fdcc61d96a2">&#9670;&nbsp;</a></span>on_application_command_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_application_command_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1application__command__delete__t.html">application_command_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_application_command_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an application command (slash command) is deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_application_command_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1application__command__delete__t.html" title="Application slash command deleted.">dpp::application_command_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a2dbbc1e590a5c23311f2895db63d5d5f" name="a2dbbc1e590a5c23311f2895db63d5d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbbc1e590a5c23311f2895db63d5d5f">&#9670;&nbsp;</a></span>on_application_command_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_application_command_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1application__command__update__t.html">application_command_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_application_command_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an application command (slash command) is updated. You will only receive this event for application commands that belong to your bot/application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_application_command_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1application__command__update__t.html" title="Update application slash command.">dpp::application_command_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a3477074ee2798aecb28542ee5afc36f3" name="a3477074ee2798aecb28542ee5afc36f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3477074ee2798aecb28542ee5afc36f3">&#9670;&nbsp;</a></span>on_autocomplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_autocomplete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1autocomplete__t.html">autocomplete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_autocomplete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an auto completed field needs suggestions to present to the user This is triggered by discord when option choices have auto completion enabled which you have associated with a <a class="el" href="classdpp_1_1slashcommand.html" title="Represents an application command, created by your bot either globally, or on a guild.">dpp::slashcommand</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_autocomplete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1autocomplete__t.html" title="Discord requests that we fill a list of auto completion choices for a command option.">dpp::autocomplete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad657d4be274b38e641db9bab63e8a420" name="ad657d4be274b38e641db9bab63e8a420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad657d4be274b38e641db9bab63e8a420">&#9670;&nbsp;</a></span>on_button_click()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_button_click </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1button__click__t.html">button_click_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_button_click</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a button is clicked attached to a message. Button clicks are triggered by discord when buttons are clicked which you have associated with a message using <a class="el" href="classdpp_1_1component.html" title="Represents the component object. A component is a clickable button or drop down list within a discord...">dpp::component</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_button_click</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1button__click__t.html" title="Click on button.">dpp::button_click_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a335adc4a68c5651dd5201642f54bc446" name="a335adc4a68c5651dd5201642f54bc446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335adc4a68c5651dd5201642f54bc446">&#9670;&nbsp;</a></span>on_channel_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_channel_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1channel__create__t.html">channel_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_channel_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new channel is created on a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1channel__create__t.html" title="Create channel.">dpp::channel_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad7d42302de6b917c75a7174c7e11f6e9" name="ad7d42302de6b917c75a7174c7e11f6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d42302de6b917c75a7174c7e11f6e9">&#9670;&nbsp;</a></span>on_channel_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_channel_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1channel__delete__t.html">channel_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_channel_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a channel is deleted from a guild. The channel will still be temporarily avaialble in the cache. Pointers to the channel should not be retained long-term as they will be deleted by the garbage collector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1channel__delete__t.html" title="Delete channel.">dpp::channel_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a57fe59534c81060533f8b31865b3a23a" name="a57fe59534c81060533f8b31865b3a23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fe59534c81060533f8b31865b3a23a">&#9670;&nbsp;</a></span>on_channel_pins_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_channel_pins_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1channel__pins__update__t.html">channel_pins_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_channel_pins_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a message is pinned. Note that the pinned message is not returned to this event, just the timestamp of the last pinned message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_pins_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1channel__pins__update__t.html" title="Channel pins update.">dpp::channel_pins_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ac318487605dd012335dd3787115f1ec2" name="ac318487605dd012335dd3787115f1ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac318487605dd012335dd3787115f1ec2">&#9670;&nbsp;</a></span>on_channel_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_channel_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1channel__update__t.html">channel_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_channel_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a channel is edited on a guild. The new channel details have already been applied to the guild when you receive this event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1channel__update__t.html" title="Update channel.">dpp::channel_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a425b60f353b4d7c48d870b850bff785e" name="a425b60f353b4d7c48d870b850bff785e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425b60f353b4d7c48d870b850bff785e">&#9670;&nbsp;</a></span>on_guild_ban_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_ban_add </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__ban__add__t.html">guild_ban_add_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_ban_add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a ban is added to a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_ban_add</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__ban__add__t.html" title="Guild ban add.">dpp::guild_ban_add_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="afcbd27652ac7192502d6da555e0dc6c9" name="afcbd27652ac7192502d6da555e0dc6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbd27652ac7192502d6da555e0dc6c9">&#9670;&nbsp;</a></span>on_guild_ban_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_ban_remove </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__ban__remove__t.html">guild_ban_remove_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_ban_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a ban is removed from a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_ban_remove</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__ban__remove__t.html" title="Guild ban remove.">dpp::guild_ban_remove_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a5164c0f1ebeb101c1fa80b03d6e09a4a" name="a5164c0f1ebeb101c1fa80b03d6e09a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5164c0f1ebeb101c1fa80b03d6e09a4a">&#9670;&nbsp;</a></span>on_guild_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__create__t.html">guild_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new guild is created. D++ will request members for the guild for its cache using guild_members_chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__create__t.html" title="Create guild.">dpp::guild_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="abdd66b3f7268c8f7a6f7fb937bfd45d9" name="abdd66b3f7268c8f7a6f7fb937bfd45d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd66b3f7268c8f7a6f7fb937bfd45d9">&#9670;&nbsp;</a></span>on_guild_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__delete__t.html">guild_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a guild is deleted. A guild can be deleted via the bot being kicked, the bot leaving the guild explicitly with dpp::guild_delete, or via the guild being unavaialble due to an outage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__delete__t.html" title="Delete guild.">dpp::guild_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0d2f6179869a30c910f1bef89c511d7c" name="a0d2f6179869a30c910f1bef89c511d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2f6179869a30c910f1bef89c511d7c">&#9670;&nbsp;</a></span>on_guild_emojis_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_emojis_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__emojis__update__t.html">guild_emojis_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_emojis_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new emojis are added to a guild. The complete set of emojis is sent every time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_emojis_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__emojis__update__t.html" title="Guild emojis update.">dpp::guild_emojis_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a731cc99b15dd5f15568ee5856d8ceffa" name="a731cc99b15dd5f15568ee5856d8ceffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731cc99b15dd5f15568ee5856d8ceffa">&#9670;&nbsp;</a></span>on_guild_integrations_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_integrations_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__integrations__update__t.html">guild_integrations_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_integrations_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an integration is updated for a guild. This returns the complete list. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_integrations_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__integrations__update__t.html" title="Guild integrations update.">dpp::guild_integrations_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a71993919fb741b379465c28e353c0b10" name="a71993919fb741b379465c28e353c0b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71993919fb741b379465c28e353c0b10">&#9670;&nbsp;</a></span>on_guild_join_request_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_join_request_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__join__request__delete__t.html">guild_join_request_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_join_request_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on guild join request delete. Triggered when a user declines the membership screening questionnaire for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_join_request_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__join__request__delete__t.html" title="Guild join request delete (user declined membership screening)">dpp::guild_join_request_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aa77b960a3530d07e972e82d8fff5a8ae" name="aa77b960a3530d07e972e82d8fff5a8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77b960a3530d07e972e82d8fff5a8ae">&#9670;&nbsp;</a></span>on_guild_member_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_member_add </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__member__add__t.html">guild_member_add_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_member_add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new member joins a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_member_add</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__member__add__t.html" title="Guild member add.">dpp::guild_member_add_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a4343a2d7352d93ba62405c82606df307" name="a4343a2d7352d93ba62405c82606df307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4343a2d7352d93ba62405c82606df307">&#9670;&nbsp;</a></span>on_guild_member_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_member_remove </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__member__remove__t.html">guild_member_remove_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_member_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user leaves a guild (either through being kicked, or choosing to leave) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_member_remove</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__member__remove__t.html" title="Guild member remove.">dpp::guild_member_remove_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aad3ffd9036946ac953be2e5f552e988c" name="aad3ffd9036946ac953be2e5f552e988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3ffd9036946ac953be2e5f552e988c">&#9670;&nbsp;</a></span>on_guild_member_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_member_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__member__update__t.html">guild_member_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_member_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when details of a guild member (e.g. their roles or nickname) are updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_member_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__member__update__t.html" title="Guild member update.">dpp::guild_member_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a8fffc28979d1ecb8c7d653501e31d04c" name="a8fffc28979d1ecb8c7d653501e31d04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fffc28979d1ecb8c7d653501e31d04c">&#9670;&nbsp;</a></span>on_guild_members_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_members_chunk </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__members__chunk__t.html">guild_members_chunk_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_members_chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a set of members is received for a guild. D++ will request these for all new guilds if needed, after the on_guild_create events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_members_chunk</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__members__chunk__t.html" title="Guild members chunk.">dpp::guild_members_chunk_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ab3449a9c5305ed837cd345d9cfe27692" name="ab3449a9c5305ed837cd345d9cfe27692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3449a9c5305ed837cd345d9cfe27692">&#9670;&nbsp;</a></span>on_guild_role_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_role_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__role__create__t.html">guild_role_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_role_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new role is created on a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_role_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__role__create__t.html" title="Guild role create.">dpp::guild_role_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ae250fcc04d66b9fc2449b05e1fc04c7a" name="ae250fcc04d66b9fc2449b05e1fc04c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae250fcc04d66b9fc2449b05e1fc04c7a">&#9670;&nbsp;</a></span>on_guild_role_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_role_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__role__delete__t.html">guild_role_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_role_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a role is deleted in a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_role_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__role__delete__t.html" title="Guild role delete.">dpp::guild_role_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="acbbf2f6a526453d97616d6c3fdf15cdd" name="acbbf2f6a526453d97616d6c3fdf15cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbf2f6a526453d97616d6c3fdf15cdd">&#9670;&nbsp;</a></span>on_guild_role_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_role_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__role__update__t.html">guild_role_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_role_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an existing role is updated on a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_role_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__role__update__t.html" title="Guild role update.">dpp::guild_role_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aac1d9a0fbc87cfd2312faf2ad2aab381" name="aac1d9a0fbc87cfd2312faf2ad2aab381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1d9a0fbc87cfd2312faf2ad2aab381">&#9670;&nbsp;</a></span>on_guild_scheduled_event_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_scheduled_event_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__create__t.html">guild_scheduled_event_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_scheduled_event_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new scheduled event is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__scheduled__event__create__t.html" title="Create scheduled event.">dpp::guild_scheduled_event_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a31f19dadb24daf8a92186fdea29a7599" name="a31f19dadb24daf8a92186fdea29a7599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f19dadb24daf8a92186fdea29a7599">&#9670;&nbsp;</a></span>on_guild_scheduled_event_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_scheduled_event_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__delete__t.html">guild_scheduled_event_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_scheduled_event_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new scheduled event is deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__scheduled__event__delete__t.html" title="Delete scheduled event.">dpp::guild_scheduled_event_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="abdebff7b0db64e06bb8585193bd41a52" name="abdebff7b0db64e06bb8585193bd41a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdebff7b0db64e06bb8585193bd41a52">&#9670;&nbsp;</a></span>on_guild_scheduled_event_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_scheduled_event_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__update__t.html">guild_scheduled_event_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_scheduled_event_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new scheduled event is updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__scheduled__event__update__t.html" title="Create scheduled event.">dpp::guild_scheduled_event_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad448883ec484005d51c98330c8fc26ce" name="ad448883ec484005d51c98330c8fc26ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad448883ec484005d51c98330c8fc26ce">&#9670;&nbsp;</a></span>on_guild_scheduled_event_user_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_scheduled_event_user_add </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__user__add__t.html">guild_scheduled_event_user_add_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_scheduled_event_user_add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user is added to a scheduled event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_user_add</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__scheduled__event__user__add__t.html" title="Add user to scheduled event.">dpp::guild_scheduled_event_user_add_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a67a9b0e0f6e35314b91f5c765823b75f" name="a67a9b0e0f6e35314b91f5c765823b75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a9b0e0f6e35314b91f5c765823b75f">&#9670;&nbsp;</a></span>on_guild_scheduled_event_user_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_scheduled_event_user_remove </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__user__remove__t.html">guild_scheduled_event_user_remove_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_scheduled_event_user_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user is removed to a scheduled event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_user_remove</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__scheduled__event__user__remove__t.html" title="Delete user from scheduled event.">dpp::guild_scheduled_event_user_remove_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a1a04d841ce5b7e6221e6da7da8b18a7a" name="a1a04d841ce5b7e6221e6da7da8b18a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a04d841ce5b7e6221e6da7da8b18a7a">&#9670;&nbsp;</a></span>on_guild_stickers_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_stickers_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__stickers__update__t.html">guild_stickers_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_stickers_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new stickers are added to a guild. The complete set of stickers is sent every time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_stickers_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__stickers__update__t.html" title="Update guild stickers.">dpp::guild_stickers_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0d1bc31f6ad73a63417020ae1ae40bb4" name="a0d1bc31f6ad73a63417020ae1ae40bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1bc31f6ad73a63417020ae1ae40bb4">&#9670;&nbsp;</a></span>on_guild_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_guild_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1guild__update__t.html">guild_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_guild_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when details of a guild are updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__update__t.html" title="Guild update.">dpp::guild_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0915881738f80397da118da81358022d" name="a0915881738f80397da118da81358022d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0915881738f80397da118da81358022d">&#9670;&nbsp;</a></span>on_integration_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_integration_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1integration__create__t.html">integration_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_integration_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new intgration is attached to a guild by a user. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_integration_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1integration__create__t.html" title="Integration create.">dpp::integration_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a62516361826a0f9256d2ff79b93b9f86" name="a62516361826a0f9256d2ff79b93b9f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62516361826a0f9256d2ff79b93b9f86">&#9670;&nbsp;</a></span>on_integration_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_integration_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1integration__delete__t.html">integration_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_integration_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an integration is removed by a user. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_integration_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1integration__delete__t.html" title="Integration delete.">dpp::integration_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a01a8130ec8031b283468705f82b940fa" name="a01a8130ec8031b283468705f82b940fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a8130ec8031b283468705f82b940fa">&#9670;&nbsp;</a></span>on_integration_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_integration_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1integration__update__t.html">integration_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_integration_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an integration is updated by a user. This returns details of just the single integration that has changed. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_integration_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1integration__update__t.html" title="Integration update.">dpp::integration_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a3287881d5f1aba46a7013c695b69a591" name="a3287881d5f1aba46a7013c695b69a591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3287881d5f1aba46a7013c695b69a591">&#9670;&nbsp;</a></span>on_interaction_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_interaction_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1interaction__create__t.html">interaction_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_interaction_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new interaction is created. Interactions are created by discord when commands you have registered are issued by a user. For an example of this in action please see <a class="el" href="slashcommands.html">Using Slash Commands and Interactions</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_interaction_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1interaction__create__t.html" title="Create interaction.">dpp::interaction_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a3b4128b323c8e48236da083841d9cfa8" name="a3b4128b323c8e48236da083841d9cfa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4128b323c8e48236da083841d9cfa8">&#9670;&nbsp;</a></span>on_invite_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_invite_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1invite__create__t.html">invite_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_invite_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new invite is created for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_invite_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1invite__create__t.html" title="Invite create.">dpp::invite_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a3283aad1e815362ff1e489af5e216da3" name="a3283aad1e815362ff1e489af5e216da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3283aad1e815362ff1e489af5e216da3">&#9670;&nbsp;</a></span>on_invite_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_invite_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1invite__delete__t.html">invite_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_invite_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an invite is deleted from a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_invite_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1invite__delete__t.html" title="Invite delete.">dpp::invite_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="adbab2120fd480aeaca4d76802708320e" name="adbab2120fd480aeaca4d76802708320e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbab2120fd480aeaca4d76802708320e">&#9670;&nbsp;</a></span>on_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_log </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1log__t.html">log_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a log message is to be written to the log. You can attach any logging system here you wish, e.g. spdlog, or even just a simple use of std::cout or printf. If nothing attaches this log event, then the library will be silent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_log</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1log__t.html" title="Log messages.">dpp::log_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aaaafcd2c26fe588021454ee3d0d0fec8" name="aaaafcd2c26fe588021454ee3d0d0fec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaafcd2c26fe588021454ee3d0d0fec8">&#9670;&nbsp;</a></span>on_message_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_message_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1message__create__t.html">message_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_message_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new message arrives from discord. Note that D++ does not cache messages. If you want to cache these objects you should create something yourself within your bot. Caching of messages is not on the roadmap to be supported as it consumes excessive amounts of RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__create__t.html" title="Create message.">dpp::message_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a874df5eb51a2ab5ce006687b449207ec" name="a874df5eb51a2ab5ce006687b449207ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874df5eb51a2ab5ce006687b449207ec">&#9670;&nbsp;</a></span>on_message_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_message_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1message__delete__t.html">message_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_message_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a message is deleted. The message has already been deleted from Discord when you receive this event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__delete__t.html" title="Message Deleted.">dpp::message_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad9d201a0a872eb18d73abcad10b0ceec" name="ad9d201a0a872eb18d73abcad10b0ceec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d201a0a872eb18d73abcad10b0ceec">&#9670;&nbsp;</a></span>on_message_delete_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_message_delete_bulk </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1message__delete__bulk__t.html">message_delete_bulk_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_message_delete_bulk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when multiple messages are deleted from a channel or DM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_delete_bulk</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__delete__bulk__t.html" title="Message delete bulk.">dpp::message_delete_bulk_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a2b998c5d26840d75933c7c48613c2abe" name="a2b998c5d26840d75933c7c48613c2abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b998c5d26840d75933c7c48613c2abe">&#9670;&nbsp;</a></span>on_message_reaction_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_message_reaction_add </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__add__t.html">message_reaction_add_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_message_reaction_add</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new reaction is added to a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_add</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__reaction__add__t.html" title="Message reaction add.">dpp::message_reaction_add_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0d39347e77d032a3bd9d11f29fc753f9" name="a0d39347e77d032a3bd9d11f29fc753f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d39347e77d032a3bd9d11f29fc753f9">&#9670;&nbsp;</a></span>on_message_reaction_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_message_reaction_remove </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__remove__t.html">message_reaction_remove_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_message_reaction_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a single reaction is removed from a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_remove</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__reaction__remove__t.html" title="Message reaction remove.">dpp::message_reaction_remove_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a7ba2fda7d5eaf854e8b27083521738a5" name="a7ba2fda7d5eaf854e8b27083521738a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba2fda7d5eaf854e8b27083521738a5">&#9670;&nbsp;</a></span>on_message_reaction_remove_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_message_reaction_remove_all </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__remove__all__t.html">message_reaction_remove_all_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_message_reaction_remove_all</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when all reactions are removed from a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_remove_all</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__reaction__remove__all__t.html" title="Message remove all reactions.">dpp::message_reaction_remove_all_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a68da8c59d05684d232e60ef3ca068c47" name="a68da8c59d05684d232e60ef3ca068c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68da8c59d05684d232e60ef3ca068c47">&#9670;&nbsp;</a></span>on_message_reaction_remove_emoji()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_message_reaction_remove_emoji </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__remove__emoji__t.html">message_reaction_remove_emoji_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_message_reaction_remove_emoji</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when all reactions for a particular emoji are removed from a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_remove_emoji</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__reaction__remove__emoji__t.html" title="Message remove emoji.">dpp::message_reaction_remove_emoji_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad66873c7ab2b1d86a9a353d889484944" name="ad66873c7ab2b1d86a9a353d889484944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66873c7ab2b1d86a9a353d889484944">&#9670;&nbsp;</a></span>on_message_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_message_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1message__update__t.html">message_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_message_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a message is updated (edited). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__update__t.html" title="Message update.">dpp::message_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a8484375dcceebd05c115ff4dbe58cb5b" name="a8484375dcceebd05c115ff4dbe58cb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8484375dcceebd05c115ff4dbe58cb5b">&#9670;&nbsp;</a></span>on_presence_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_presence_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1presence__update__t.html">presence_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_presence_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user's presence is updated. To receive these you will need the GUILD_PRESENCES privileged intent. You will receive many of these, very often, and receiving them will significantly increase your bot's CPU usage. If you don't need them it is recommended to not ask for them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_presence_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1presence__update__t.html" title="Presence update.">dpp::presence_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a598c59a3848bf30d82938fdd7f5813a3" name="a598c59a3848bf30d82938fdd7f5813a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598c59a3848bf30d82938fdd7f5813a3">&#9670;&nbsp;</a></span>on_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_ready </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1ready__t.html">ready_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_ready</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a shard is connected and ready. A set of on_guild_create events will follow this event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ready</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1ready__t.html" title="Session ready.">dpp::ready_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ac92176f33b0b70ddfb3a57ce35847692" name="ac92176f33b0b70ddfb3a57ce35847692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92176f33b0b70ddfb3a57ce35847692">&#9670;&nbsp;</a></span>on_resumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_resumed </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1resumed__t.html">resumed_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_resumed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a connection to a shard successfully resumes. A resumed session does not need to re-synchronise guilds, members, etc. This is generally non-fatal and informational only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_resumed</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1resumed__t.html" title="Session resumed.">dpp::resumed_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a2ca854b9de47fc5eae411d072f6acff4" name="a2ca854b9de47fc5eae411d072f6acff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca854b9de47fc5eae411d072f6acff4">&#9670;&nbsp;</a></span>on_select_click()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_select_click </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1select__click__t.html">select_click_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_select_click</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a select menu is clicked attached to a message. Select menu clicks are triggered by discord when select menus are clicked which you have associated with a message using <a class="el" href="classdpp_1_1component.html" title="Represents the component object. A component is a clickable button or drop down list within a discord...">dpp::component</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_select_click</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1select__click__t.html" title="Click on select.">dpp::select_click_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a7d7a98c044ea5b84612453b60b0b3850" name="a7d7a98c044ea5b84612453b60b0b3850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7a98c044ea5b84612453b60b0b3850">&#9670;&nbsp;</a></span>on_stage_instance_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_stage_instance_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1stage__instance__create__t.html">stage_instance_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_stage_instance_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new stage instance is created on a stage channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_stage_instance_create</td><td>User function to attach to event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a1e70453187414601a4e3593f5b99810c" name="a1e70453187414601a4e3593f5b99810c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e70453187414601a4e3593f5b99810c">&#9670;&nbsp;</a></span>on_stage_instance_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_stage_instance_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1stage__instance__delete__t.html">stage_instance_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_stage_instance_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an existing stage instance is deleted from a stage channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_stage_instance_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1stage__instance__delete__t.html" title="Delete stage instance.">dpp::stage_instance_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a670c983ad24021e64c3efda9e937dd07" name="a670c983ad24021e64c3efda9e937dd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670c983ad24021e64c3efda9e937dd07">&#9670;&nbsp;</a></span>on_stage_instance_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_stage_instance_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1stage__instance__update__t.html">stage_instance_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_stage_instance_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a stage instance is updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_stage_instance_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1stage__instance__update__t.html" title="Update stage instance.">dpp::stage_instance_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a4e4a35dd08b7c9e90cc338de3105423c" name="a4e4a35dd08b7c9e90cc338de3105423c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4a35dd08b7c9e90cc338de3105423c">&#9670;&nbsp;</a></span>on_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_thread_create </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1thread__create__t.html">thread_create_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_thread_create</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a thread is created Note: Threads are not cached by D++, but a list of thread IDs is accessible in a guild object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__create__t.html" title="Thread Create.">dpp::thread_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ab9a96cbbac9227e14a125c21bab9d8d7" name="ab9a96cbbac9227e14a125c21bab9d8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a96cbbac9227e14a125c21bab9d8d7">&#9670;&nbsp;</a></span>on_thread_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_thread_delete </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1thread__delete__t.html">thread_delete_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_thread_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a thread is deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__delete__t.html" title="Thread Delete.">dpp::thread_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a148422098b97980a26de5effb6fba208" name="a148422098b97980a26de5effb6fba208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148422098b97980a26de5effb6fba208">&#9670;&nbsp;</a></span>on_thread_list_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_thread_list_sync </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1thread__list__sync__t.html">thread_list_sync_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_thread_list_sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when thread list is synced (upon gaining access to a channel) Note: Threads are not cached by D++, but a list of thread IDs is accessible in a guild object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_list_sync</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__list__sync__t.html" title="Thread List Sync.">dpp::thread_list_sync_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ae40e5e964c728a7e56b7b0379ef699db" name="ae40e5e964c728a7e56b7b0379ef699db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40e5e964c728a7e56b7b0379ef699db">&#9670;&nbsp;</a></span>on_thread_member_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_thread_member_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1thread__member__update__t.html">thread_member_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_thread_member_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when current user's thread member object is updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_member_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__member__update__t.html" title="Thread Member Update.">dpp::thread_member_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="abe9e5c58c9fe8b5cb7f98e3aaf3944d3" name="abe9e5c58c9fe8b5cb7f98e3aaf3944d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9e5c58c9fe8b5cb7f98e3aaf3944d3">&#9670;&nbsp;</a></span>on_thread_members_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_thread_members_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1thread__members__update__t.html">thread_members_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_thread_members_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a thread's member list is updated (without GUILD_MEMBERS intent, is only called for current user) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_members_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__members__update__t.html" title="Thread Members Update.">dpp::thread_members_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a5047e0ea3ee5f77b92e10fdd8e7f1bb8" name="a5047e0ea3ee5f77b92e10fdd8e7f1bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5047e0ea3ee5f77b92e10fdd8e7f1bb8">&#9670;&nbsp;</a></span>on_thread_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_thread_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1thread__update__t.html">thread_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_thread_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a thread is updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__update__t.html" title="Thread Update.">dpp::thread_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a2981966cc8349aed024d9f8aaf5882e8" name="a2981966cc8349aed024d9f8aaf5882e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2981966cc8349aed024d9f8aaf5882e8">&#9670;&nbsp;</a></span>on_typing_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_typing_start </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1typing__start__t.html">typing_start_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_typing_start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user is typing on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_typing_start</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1typing__start__t.html" title="Typing start.">dpp::typing_start_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="afa293c651143a9ccffb6090830eed3e5" name="afa293c651143a9ccffb6090830eed3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa293c651143a9ccffb6090830eed3e5">&#9670;&nbsp;</a></span>on_user_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_user_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1user__update__t.html">user_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_user_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user is updated. This is separate to guild_member_update and includes things such as an avatar change, username change, discriminator change or change in subscription status for nitro. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_user_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1user__update__t.html" title="User update.">dpp::user_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ae1c915eafbf888a369278f21989f8476" name="ae1c915eafbf888a369278f21989f8476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c915eafbf888a369278f21989f8476">&#9670;&nbsp;</a></span>on_voice_buffer_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_voice_buffer_send </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1voice__buffer__send__t.html">voice_buffer_send_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_voice_buffer_send</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when packets are sent from the voice buffer. The voice buffer contains packets that are already encoded with Opus and encrypted with Sodium, and merged into packets by the repacketizer, which is done in the dpp::discord_voice_client::send_audio method. You should use the buffer size properties of <a class="el" href="structdpp_1_1voice__buffer__send__t.html" title="voice buffer send">dpp::voice_buffer_send_t</a> to determine if you should fill the buffer with more content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_buffer_send</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__buffer__send__t.html" title="voice buffer send">dpp::voice_buffer_send_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ab6f6e8daa30e7ed1ebb9f9547ef89206" name="ab6f6e8daa30e7ed1ebb9f9547ef89206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f6e8daa30e7ed1ebb9f9547ef89206">&#9670;&nbsp;</a></span>on_voice_client_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_voice_client_disconnect </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1voice__client__disconnect__t.html">voice_client_disconnect_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_voice_client_disconnect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on voice client disconnect event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_client_disconnect</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__client__disconnect__t.html" title="voice client disconnect event">dpp::voice_client_disconnect_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a818e39c9b8ada848f03cd873a1eaf424" name="a818e39c9b8ada848f03cd873a1eaf424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818e39c9b8ada848f03cd873a1eaf424">&#9670;&nbsp;</a></span>on_voice_client_speaking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_voice_client_speaking </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1voice__client__speaking__t.html">voice_client_speaking_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_voice_client_speaking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on voice client speaking event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_client_speaking</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__client__speaking__t.html" title="voice client speaking event">dpp::voice_client_speaking_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad350f1c81f3c81d5128fe5d03bbfa711" name="ad350f1c81f3c81d5128fe5d03bbfa711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad350f1c81f3c81d5128fe5d03bbfa711">&#9670;&nbsp;</a></span>on_voice_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_voice_ready </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1voice__ready__t.html">voice_ready_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_voice_ready</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a voice channel is connected and ready to send audio. Note that this is not directly attached to the READY event of the websocket, as there is further connection that needs to be done before audio is ready to send. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_ready</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__ready__t.html" title="voice user talking">dpp::voice_ready_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a1667f6fda196df3bb7f858e690ff91f3" name="a1667f6fda196df3bb7f858e690ff91f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1667f6fda196df3bb7f858e690ff91f3">&#9670;&nbsp;</a></span>on_voice_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_voice_receive </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1voice__receive__t.html">voice_receive_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_voice_receive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new audio data is received. Each separate user's audio from the voice channel will arrive tagged with their user id in the event, if a user can be attributed to the received audio. </p>
<dl class="section note"><dt>Note</dt><dd>Receiveing audio for bots is not officially supported by discord.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_receive</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__receive__t.html" title="voice receive packet">dpp::voice_receive_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a52b48bed7a6a1e0d0f824e66c839a7d8" name="a52b48bed7a6a1e0d0f824e66c839a7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b48bed7a6a1e0d0f824e66c839a7d8">&#9670;&nbsp;</a></span>on_voice_server_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_voice_server_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1voice__server__update__t.html">voice_server_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_voice_server_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when we are told which voice server we can use. This will be sent either when we establish a new voice channel connection, or as discord rearrange their infrastructure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_server_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__server__update__t.html" title="Voice server update.">dpp::voice_server_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a130b16feb7cb7f79a30401e95888109d" name="a130b16feb7cb7f79a30401e95888109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130b16feb7cb7f79a30401e95888109d">&#9670;&nbsp;</a></span>on_voice_state_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_voice_state_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1voice__state__update__t.html">voice_state_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_voice_state_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on voice state update event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_state_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__state__update__t.html" title="Voice state update.">dpp::voice_state_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0777f715bdfd39c897f7ef93d67427a1" name="a0777f715bdfd39c897f7ef93d67427a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0777f715bdfd39c897f7ef93d67427a1">&#9670;&nbsp;</a></span>on_voice_track_marker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_voice_track_marker </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1voice__track__marker__t.html">voice_track_marker_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_voice_track_marker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when sending of audio passes over a track marker. Track markers are arbitrarily placed "bookmarks" in the audio buffer, placed by the bot developer. Each track marker can have a string value associated with it which is specified in <a class="el" href="classdpp_1_1discord__voice__client.html#a84fc0cb1aaf9691aed818e18daea1b84" title="Insert a track marker into the audio output buffer. A track marker is an arbitrary flag in the buffer...">dpp::discord_voice_client::insert_marker</a> and returned to this event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_track_marker</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__track__marker__t.html" title="Voice state update.">dpp::voice_track_marker_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aaee7911f1695b3873d6963260264d8ef" name="aaee7911f1695b3873d6963260264d8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee7911f1695b3873d6963260264d8ef">&#9670;&nbsp;</a></span>on_voice_user_talking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_voice_user_talking </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1voice__user__talking__t.html">voice_user_talking_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_voice_user_talking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user is talking on a voice channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_user_talking</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__user__talking__t.html" title="voice user talking">dpp::voice_user_talking_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="afcf720a6c565961648577ebfb46bd716" name="afcf720a6c565961648577ebfb46bd716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf720a6c565961648577ebfb46bd716">&#9670;&nbsp;</a></span>on_webhooks_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a4641626be7775de0b8b63a6e68d0934e">event_handle</a> dpp::cluster::on_webhooks_update </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structdpp_1_1webhooks__update__t.html">webhooks_update_t</a> &amp;_event)&gt;&#160;</td>
          <td class="paramname"><em>_webhooks_update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when the webhooks for a guild are updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_webhooks_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1webhooks__update__t.html" title="Webhooks update.">dpp::webhooks_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a62b83ee3be02df68eb5e697ddc5efc0a" name="a62b83ee3be02df68eb5e697ddc5efc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b83ee3be02df68eb5e697ddc5efc0a">&#9670;&nbsp;</a></span>post_rest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::post_rest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>major_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a805ef1feb2862a208ec0e9d1be005c88">http_method</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#aafc7fb6792b12d92c4e77b46d20924ee">json_encode_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filecontent</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a REST request. Where possible use a helper method instead like message_create. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to post to, e.g. /api/guilds </td></tr>
    <tr><td class="paramname">major_parameters</td><td>Major parameters for the endpoint e.g. a guild id </td></tr>
    <tr><td class="paramname">parameters</td><td>Minor parameters for the API request </td></tr>
    <tr><td class="paramname">method</td><td>Method, e.g. GET, POST </td></tr>
    <tr><td class="paramname">postdata</td><td>Post data (usually JSON encoded) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the HTTP call completes. The callback parameter will contain amongst other things, the decoded json. </td></tr>
    <tr><td class="paramname">filename</td><td>Filename to post for POST requests (for uploading files) </td></tr>
    <tr><td class="paramname">filecontent</td><td>File content to post for POST requests (for uploading files) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a156fe68358c421111e690f553c4e4f52" name="a156fe68358c421111e690f553c4e4f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156fe68358c421111e690f553c4e4f52">&#9670;&nbsp;</a></span>request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::request </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a805ef1feb2862a208ec0e9d1be005c88">http_method</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#ae3249e99494d04bb4be50341f474621e">http_completion_event</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postdata</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mimetype</em> = <code>&quot;text/plain&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::multimap&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>headers</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a HTTP(S) request. For use when wanting asnyncronous access to HTTP APIs outside of Discord. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Endpoint to post to, e.g. /api/guilds </td></tr>
    <tr><td class="paramname">method</td><td>Method, e.g. GET, POST </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the HTTP call completes. No processing is done on the returned data. </td></tr>
    <tr><td class="paramname">postdata</td><td>POST data </td></tr>
    <tr><td class="paramname">mimetype</td><td>MIME type of POST data </td></tr>
    <tr><td class="paramname">headers</td><td>Headers to send with the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab912eb28e9bb4df46954c7a9b93b283d" name="ab912eb28e9bb4df46954c7a9b93b283d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab912eb28e9bb4df46954c7a9b93b283d">&#9670;&nbsp;</a></span>role_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::role_create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a role on a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Role to create (guild ID is encapsulated in the role object) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1role.html" title="Represents a role within a dpp::guild. Roles are combined via logical OR of the permission bitmasks,...">dpp::role</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45414d0d189edd147c3d76b4480ec0b8" name="a45414d0d189edd147c3d76b4480ec0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45414d0d189edd147c3d76b4480ec0b8">&#9670;&nbsp;</a></span>role_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::role_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>role_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a role. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to delete the role on </td></tr>
    <tr><td class="paramname">role_id</td><td>Role ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24cc5286955e6641d574d232d8b47f55" name="a24cc5286955e6641d574d232d8b47f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cc5286955e6641d574d232d8b47f55">&#9670;&nbsp;</a></span>role_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::role_edit </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a role on a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Role to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1role.html" title="Represents a role within a dpp::guild. Roles are combined via logical OR of the permission bitmasks,...">dpp::role</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac77932ee797aeb44098c2013811b2887" name="ac77932ee797aeb44098c2013811b2887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77932ee797aeb44098c2013811b2887">&#9670;&nbsp;</a></span>role_edit_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::role_edit_position </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a role's position in a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Role to change position of </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1role.html" title="Represents a role within a dpp::guild. Roles are combined via logical OR of the permission bitmasks,...">dpp::role</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a884dbb70619fcf92b06577dea8093219" name="a884dbb70619fcf92b06577dea8093219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884dbb70619fcf92b06577dea8093219">&#9670;&nbsp;</a></span>roles_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::roles_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a role for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get role for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#adb1c0770936ed4ac64158cf9523e638b">dpp::role_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbcc02c388c197cf7050551ef89aeefe" name="adbcc02c388c197cf7050551ef89aeefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcc02c388c197cf7050551ef89aeefe">&#9670;&nbsp;</a></span>set_audit_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp; dpp::cluster::set_audit_reason </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the audit log reason for the next REST call to be made. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically. </p>
<p >Example: </p><div class="fragment"><div class="line">bot.set_audit_reason(<span class="stringliteral">&quot;Too much abusive content&quot;</span>)</div>
<div class="line">   .channel_delete(my_channel_id);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>The reason to set for the next REST call on this thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cluster&amp; Reference to self for chaining. </dd></dl>

</div>
</div>
<a id="a3fc501cc0ebb334d09a7f4bb1ea6b3e6" name="a3fc501cc0ebb334d09a7f4bb1ea6b3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc501cc0ebb334d09a7f4bb1ea6b3e6">&#9670;&nbsp;</a></span>set_dm_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::set_dm_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the dm channel id for a user id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_id</td><td>user id to set the dm channel for </td></tr>
    <tr><td class="paramname">channel_id</td><td>dm channel to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b67c9455ac0378712e4c0fd0ba7f2a9" name="a9b67c9455ac0378712e4c0fd0ba7f2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b67c9455ac0378712e4c0fd0ba7f2a9">&#9670;&nbsp;</a></span>set_presence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::set_presence </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1presence.html">dpp::presence</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the presence for all shards on the cluster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The presence to set. Only the online status and the first activity are sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a056e4191c03dd210c2a410b6599a0bf9" name="a056e4191c03dd210c2a410b6599a0bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056e4191c03dd210c2a410b6599a0bf9">&#9670;&nbsp;</a></span>set_websocket_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp; dpp::cluster::set_websocket_protocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#af7cde3079d745428f44ef6231a2ac672">websocket_protocol_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the websocket protocol for all shards on this cluster. You should call this method before <a class="el" href="classdpp_1_1cluster.html#a40e99d13e1380eccd30d13123014594f" title="Start the cluster, connecting all its shards. Returns once all shards are connected.">cluster::start</a>. Generally ws_etf is faster, but provides less facilities for debugging should something go wrong. It is recommended to use ETF in production and JSON in development. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>websocket protocol to use, either ws_json or ws_etf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cluster&amp; Reference to self for chaining. </dd></dl>

</div>
</div>
<a id="a5fe69055dc2ee16d08e693df11fec75a" name="a5fe69055dc2ee16d08e693df11fec75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe69055dc2ee16d08e693df11fec75a">&#9670;&nbsp;</a></span>stage_instance_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::stage_instance_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1stage__instance.html">stage_instance</a> &amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stage instance on a stage channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Stage instance to create </td></tr>
    <tr><td class="paramname">callback</td><td>User function to execute when the api call completes On success the callback will contain a <a class="el" href="structdpp_1_1stage__instance.html" title="A stage instance. Stage instances are like a conference facility, with moderators/speakers and listen...">dpp::stage_instance</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method. </dd></dl>

</div>
</div>
<a id="a9f8c2ba02d51ad166f90300ab5b53ecb" name="a9f8c2ba02d51ad166f90300ab5b53ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8c2ba02d51ad166f90300ab5b53ecb">&#9670;&nbsp;</a></span>stage_instance_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::stage_instance_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a stage instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>ID of the associated channel </td></tr>
    <tr><td class="paramname">callback</td><td>User function to execute when the api call completes On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method. </dd></dl>

</div>
</div>
<a id="af4e1b1edb3094c7d220a3a80323bbe17" name="af4e1b1edb3094c7d220a3a80323bbe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e1b1edb3094c7d220a3a80323bbe17">&#9670;&nbsp;</a></span>stage_instance_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::stage_instance_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1stage__instance.html">stage_instance</a> &amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a stage instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Stage instance to edit </td></tr>
    <tr><td class="paramname">callback</td><td>User function to execute when the api call completes On success the callback will contain a <a class="el" href="structdpp_1_1stage__instance.html" title="A stage instance. Stage instances are like a conference facility, with moderators/speakers and listen...">dpp::stage_instance</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method. </dd></dl>

</div>
</div>
<a id="a1edd6ac5d8553b4823465bebadfaa9af" name="a1edd6ac5d8553b4823465bebadfaa9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edd6ac5d8553b4823465bebadfaa9af">&#9670;&nbsp;</a></span>stage_instance_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::stage_instance_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the stage instance associated with the channel id, if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>ID of the associated channel </td></tr>
    <tr><td class="paramname">callback</td><td>User function to execute when the api call completes On success the callback will contain a <a class="el" href="structdpp_1_1stage__instance.html" title="A stage instance. Stage instances are like a conference facility, with moderators/speakers and listen...">dpp::stage_instance</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40e99d13e1380eccd30d13123014594f" name="a40e99d13e1380eccd30d13123014594f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e99d13e1380eccd30d13123014594f">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::start </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_after</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the cluster, connecting all its shards. Returns once all shards are connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">return_after</td><td>If true the bot will return to your program after starting shards, if false this function will never return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae64421a4b2402238feb0536639009c18" name="ae64421a4b2402238feb0536639009c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64421a4b2402238feb0536639009c18">&#9670;&nbsp;</a></span>sticker_packs_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::sticker_packs_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get sticker packs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52366e37144b166c6a2c773e14992b21" name="a52366e37144b166c6a2c773e14992b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52366e37144b166c6a2c773e14992b21">&#9670;&nbsp;</a></span>template_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::template_get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Template code </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62fc5594e7d2dabcc03e9ef031a361db" name="a62fc5594e7d2dabcc03e9ef031a361db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62fc5594e7d2dabcc03e9ef031a361db">&#9670;&nbsp;</a></span>thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>thread_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>auto_archive_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a8af3a726df107c304139477dbfa42092">channel_type</a>&#160;</td>
          <td class="paramname"><em>thread_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invitable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rate_limit_per_user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_name</td><td>Name of the thread </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel in which thread to create </td></tr>
    <tr><td class="paramname">auto_archive_duration</td><td>Duration after which thread auto-archives. Can be set to - 60, 1440 (for boosted guilds can also be: 4320, 10080) </td></tr>
    <tr><td class="paramname">thread_type</td><td>Type of thread - GUILD_PUBLIC_THREAD, GUILD_NEWS_THREAD, GUILD_PRIVATE_THREAD </td></tr>
    <tr><td class="paramname">invitable</td><td>whether non-moderators can add other non-moderators to a thread; only available when creating a private thread </td></tr>
    <tr><td class="paramname">rate_limit_per_user</td><td>amount of seconds a user has to wait before sending another message (0-21600); bots, as well as users with the permission manage_messages, manage_thread, or manage_channel, are unaffected </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1thread.html" title="A definition of a discord thread. A thread is a superset of a channel. Not to be confused with std::t...">dpp::thread</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacc314e4918852cc217b473ff9d95ddc" name="aacc314e4918852cc217b473ff9d95ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc314e4918852cc217b473ff9d95ddc">&#9670;&nbsp;</a></span>thread_create_with_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_create_with_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>thread_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>auto_archive_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rate_limit_per_user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread with a message (Discord: ID of a thread is same as message ID) </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_name</td><td>Name of the thread </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel in which thread to create </td></tr>
    <tr><td class="paramname">message_id</td><td>message to start thread with </td></tr>
    <tr><td class="paramname">auto_archive_duration</td><td>Duration after which thread auto-archives. Can be set to - 60, 1440 (for boosted guilds can also be: 4320, 10080) </td></tr>
    <tr><td class="paramname">rate_limit_per_user</td><td>amount of seconds a user has to wait before sending another message (0-21600); bots, as well as users with the permission manage_messages, manage_thread, or manage_channel, are unaffected </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1thread.html" title="A definition of a discord thread. A thread is a superset of a channel. Not to be confused with std::t...">dpp::thread</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a066a4a71deac82b823757c2c80479a5d" name="a066a4a71deac82b823757c2c80479a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066a4a71deac82b823757c2c80479a5d">&#9670;&nbsp;</a></span>thread_member_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_member_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a member to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread ID to add to </td></tr>
    <tr><td class="paramname">user_id</td><td>Member ID to add </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad39edec2f1389d1aa5bb6c09e4318b6a" name="ad39edec2f1389d1aa5bb6c09e4318b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39edec2f1389d1aa5bb6c09e4318b6a">&#9670;&nbsp;</a></span>thread_member_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_member_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a thread member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread to get member for </td></tr>
    <tr><td class="paramname">user_id</td><td>ID of the user to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="structdpp_1_1thread__member.html" title="represents membership of a user with a thread">dpp::thread_member</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad253c2a68c5a1e78b880da7252a15814" name="ad253c2a68c5a1e78b880da7252a15814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad253c2a68c5a1e78b880da7252a15814">&#9670;&nbsp;</a></span>thread_member_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_member_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a member from a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread ID to remove from </td></tr>
    <tr><td class="paramname">user_id</td><td>Member ID to remove </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a636b55f518a2e724eabf31453aa89abe" name="a636b55f518a2e724eabf31453aa89abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636b55f518a2e724eabf31453aa89abe">&#9670;&nbsp;</a></span>thread_members_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_members_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get members of a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread to get members for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="namespacedpp.html#a57e84724c41fed341bee0d653a06076a" title="A group of thread member objects.">dpp::thread_member_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6825c29651e995f251e01f5a1f20122d" name="a6825c29651e995f251e01f5a1f20122d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6825c29651e995f251e01f5a1f20122d">&#9670;&nbsp;</a></span>threads_get_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::threads_get_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get active threads in a channel (Sorted by ID in descending order) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to get active threads for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="namespacedpp.html#afb8eae726b5ea68baff8c48d7fb835af" title="A group of threads.">dpp::thread_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d0c3894cd560fa7871f22d7cfb8f591" name="a0d0c3894cd560fa7871f22d7cfb8f591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0c3894cd560fa7871f22d7cfb8f591">&#9670;&nbsp;</a></span>threads_get_joined_private_archived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::threads_get_joined_private_archived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>before_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get private archived threads in a channel which current user has joined (Sorted by ID in descending order) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to get public archived threads for </td></tr>
    <tr><td class="paramname">before_id</td><td>Get threads before this id </td></tr>
    <tr><td class="paramname">limit</td><td>Number of threads to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="namespacedpp.html#afb8eae726b5ea68baff8c48d7fb835af" title="A group of threads.">dpp::thread_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8336e48eaabaeb8df4d69a087982e82" name="ae8336e48eaabaeb8df4d69a087982e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8336e48eaabaeb8df4d69a087982e82">&#9670;&nbsp;</a></span>threads_get_private_archived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::threads_get_private_archived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>before_timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get private archived threads in a channel (Sorted by archive_timestamp in descending order) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to get public archived threads for </td></tr>
    <tr><td class="paramname">before_timestamp</td><td>Get threads before this timestamp </td></tr>
    <tr><td class="paramname">limit</td><td>Number of threads to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="namespacedpp.html#afb8eae726b5ea68baff8c48d7fb835af" title="A group of threads.">dpp::thread_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b93e8be30c7e954c27e19d8b7fa8170" name="a2b93e8be30c7e954c27e19d8b7fa8170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b93e8be30c7e954c27e19d8b7fa8170">&#9670;&nbsp;</a></span>threads_get_public_archived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::threads_get_public_archived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>before_timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get public archived threads in a channel (Sorted by archive_timestamp in descending order) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to get public archived threads for </td></tr>
    <tr><td class="paramname">before_timestamp</td><td>Get threads before this timestamp </td></tr>
    <tr><td class="paramname">limit</td><td>Number of threads to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="namespacedpp.html#afb8eae726b5ea68baff8c48d7fb835af" title="A group of threads.">dpp::thread_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af12b5b33ea156bde9977796858066a6b" name="af12b5b33ea156bde9977796858066a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12b5b33ea156bde9977796858066a6b">&#9670;&nbsp;</a></span>uptime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdpp_1_1utility_1_1uptime.html">dpp::utility::uptime</a> dpp::cluster::uptime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uptime of the cluster. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdpp_1_1utility_1_1uptime.html" title="A class used to represent an uptime in hours, minutes, seconds and days, with helper functions to con...">dpp::utility::uptime</a> The uptime of the cluster </dd></dl>

</div>
</div>
<a id="a73483dbeb0f1946dc18b1d0a5331b0d0" name="a73483dbeb0f1946dc18b1d0a5331b0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73483dbeb0f1946dc18b1d0a5331b0d0">&#9670;&nbsp;</a></span>user_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::user_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a user by id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_id</td><td>User ID to retrieve </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">dpp::user_identified</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">user_identified</a> object is a subclass of <a class="el" href="classdpp_1_1user.html" title="Represents a user on discord. May or may not be a member of a dpp::guild.">dpp::user</a> which contains further details if you have the oauth2 identify or email scopes. If you do not have these scopes, these fields are empty. You can safely convert a <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">user_identified</a> to user with <code>dynamic_cast</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9fae28f81712be86530fe3314d166ad3" name="a9fae28f81712be86530fe3314d166ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fae28f81712be86530fe3314d166ad3">&#9670;&nbsp;</a></span>cache_policy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdpp_1_1cache__policy__t.html">cache_policy_t</a> dpp::cluster::cache_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current cache policy for the cluster. </p>

</div>
</div>
<a id="a5155862c1d7267c7f4ee8781ff3e8d7f" name="a5155862c1d7267c7f4ee8781ff3e8d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5155862c1d7267c7f4ee8781ff3e8d7f">&#9670;&nbsp;</a></span>cluster_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dpp::cluster::cluster_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ID of this cluster, between 0 and MAXCLUSTERS-1 inclusive </p>

</div>
</div>
<a id="ad7dfd048a845235dda924b989c1383f3" name="ad7dfd048a845235dda924b989c1383f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7dfd048a845235dda924b989c1383f3">&#9670;&nbsp;</a></span>dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1dispatcher.html">dpp::dispatcher</a> dpp::cluster::dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Routes events from Discord back to user program code via std::functions </p>

</div>
</div>
<a id="a239af1e13449c85658fb37e6589745a0" name="a239af1e13449c85658fb37e6589745a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239af1e13449c85658fb37e6589745a0">&#9670;&nbsp;</a></span>intents</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dpp::cluster::intents</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Current bitmask of gateway intents </p>

</div>
</div>
<a id="a32ce7fc13658a25e2faeadcd36282b0b" name="a32ce7fc13658a25e2faeadcd36282b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ce7fc13658a25e2faeadcd36282b0b">&#9670;&nbsp;</a></span>last_identify</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t dpp::cluster::last_identify</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad80e4df300e69988d163d61c14e540ab" name="ad80e4df300e69988d163d61c14e540ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80e4df300e69988d163d61c14e540ab">&#9670;&nbsp;</a></span>maxclusters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dpp::cluster::maxclusters</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Total number of clusters that are active </p>

</div>
</div>
<a id="ad31317a40181f6864646c8758871b495" name="ad31317a40181f6864646c8758871b495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31317a40181f6864646c8758871b495">&#9670;&nbsp;</a></span>me</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1user.html">dpp::user</a> dpp::cluster::me</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The details of the bot user. This is assumed to be identical across all shards in the cluster. Each connecting shard updates this information. </p>

</div>
</div>
<a id="a7418aa521c49af80822039b013d8d004" name="a7418aa521c49af80822039b013d8d004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7418aa521c49af80822039b013d8d004">&#9670;&nbsp;</a></span>numshards</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dpp::cluster::numshards</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Total number of shards across all clusters </p>

</div>
</div>
<a id="a6161f8d412b2e81a06594f727684a260" name="a6161f8d412b2e81a06594f727684a260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6161f8d412b2e81a06594f727684a260">&#9670;&nbsp;</a></span>rest_ping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dpp::cluster::rest_ping</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >REST latency (HTTPS ping) </p>

</div>
</div>
<a id="a644b186bc4b386a8313e3c5dce456c4e" name="a644b186bc4b386a8313e3c5dce456c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644b186bc4b386a8313e3c5dce456c4e">&#9670;&nbsp;</a></span>token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dpp::cluster::token</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Current bot token for all shards on this cluster and all commands sent via HTTP </p>

</div>
</div>
<a id="ae10466db79966215a799fc2a30010551" name="ae10466db79966215a799fc2a30010551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10466db79966215a799fc2a30010551">&#9670;&nbsp;</a></span>ws_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#af7cde3079d745428f44ef6231a2ac672">websocket_protocol_t</a> dpp::cluster::ws_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Websocket mode for all shards in the cluster, either ws_json or ws_etf. Production bots should use ETF, while development bots should use JSON. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedpp.html">dpp</a></li><li class="navelem"><a class="el" href="classdpp_1_1cluster.html">cluster</a></li>
  </ul>
</div>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-QTH6YHBNG5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
        gtag('config', 'G-QTH6YHBNG5');
</script>
<div style="z-index: -9999; position: absolute; right: 0; top: 0; font-size: 0.0001rem;color:transparent;background:none">
	<!-- For crawlability of past versions -->
	<a href='/10.0.3/'>D++ Library version 10.0.3</a><a href='/10.0.2/'>D++ Library version 10.0.2</a><a href='/10.0.1/'>D++ Library version 10.0.1</a><a href='/10.0.0/'>D++ Library version 10.0.0</a><a href='/9.0.19/'>D++ Library version 9.0.19</a><a href='/9.0.18/'>D++ Library version 9.0.18</a><a href='/9.0.17/'>D++ Library version 9.0.17</a><a href='/9.0.16/'>D++ Library version 9.0.16</a><a href='/9.0.15/'>D++ Library version 9.0.15</a><a href='/9.0.14/'>D++ Library version 9.0.14</a><a href='/9.0.13/'>D++ Library version 9.0.13</a><a href='/9.0.12/'>D++ Library version 9.0.12</a><a href='/9.0.11/'>D++ Library version 9.0.11</a><a href='/9.0.10/'>D++ Library version 9.0.10</a><a href='/9.0.9/'>D++ Library version 9.0.9</a><a href='/9.0.8/'>D++ Library version 9.0.8</a><a href='/9.0.7/'>D++ Library version 9.0.7</a><a href='/9.0.6/'>D++ Library version 9.0.6</a><a href='/9.0.5/'>D++ Library version 9.0.5</a><a href='/9.0.4/'>D++ Library version 9.0.4</a><a href='/9.0.3/'>D++ Library version 9.0.3</a><a href='/9.0.2/'>D++ Library version 9.0.2</a><a href='/9.0.1/'>D++ Library version 9.0.1</a><a href='/9.0.0/'>D++ Library version 9.0.0</a><a href='/1.0.2/'>D++ Library version 1.0.2</a><a href='/1.0.1/'>D++ Library version 1.0.1</a><a href='/1.0.0/'>D++ Library version 1.0.0</a>
</div>
</body>
</html>
