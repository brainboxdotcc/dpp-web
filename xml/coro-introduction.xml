<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="coro-introduction" kind="page">
    <compoundname>coro-introduction</compoundname>
    <title>Introduction to coroutines</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Introduced in C++20, coroutines are the solution to the impracticality of callbacks. In short, a coroutine is a function that can be paused and resumed later. They are an extremely powerful alternative to callbacks for asynchronous APIs in particular, as the function can be paused when waiting for an API response, and resumed when it is received.</para>
<para>Let&apos;s revisit <ref refid="attach-file" kindref="compound">attaching a downloaded file</ref>, but this time with a coroutine:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;dpp/dpp.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classdpp_1_1cluster" kindref="compound">dpp::cluster</ref><sp/>bot(</highlight><highlight class="stringliteral">&quot;token&quot;</highlight><highlight class="normal">,<sp/><ref refid="namespacedpp_1a0042c0fc8164da4239b977d5be8e2ef5a561a52b3c6883808735c41891351c68f" kindref="member">dpp::i_default_intents</ref><sp/>|<sp/><ref refid="namespacedpp_1a0042c0fc8164da4239b977d5be8e2ef5a27810e825c157ded5d59df6dede23414" kindref="member">dpp::i_message_content</ref>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bot.on_log(<ref refid="namespacedpp_1_1utility_1a8c2cc04bb80ffd287b376d5977899277" kindref="member">dpp::utility::cout_logger</ref>());</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Message<sp/>handler<sp/>to<sp/>look<sp/>for<sp/>a<sp/>command<sp/>called<sp/>!file<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Make<sp/>note<sp/>of<sp/>passing<sp/>the<sp/>event<sp/>by<sp/>value,<sp/>this<sp/>is<sp/>important<sp/>(explained<sp/>below)<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bot.on_message_create([](<ref refid="structdpp_1_1message__create__t" kindref="compound">dpp::message_create_t</ref><sp/>event)<sp/>-&gt;<sp/><ref refid="structdpp_1_1job" kindref="compound">dpp::job</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classdpp_1_1cluster" kindref="compound">dpp::cluster</ref><sp/>*cluster<sp/>=<sp/></highlight><highlight class="keyword">event</highlight><highlight class="normal">.from-&gt;creator;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(event.<ref refid="structdpp_1_1message__create__t_1a02298492087c0ba68eeb4ea8e42833b4" kindref="member">msg</ref>.<ref refid="structdpp_1_1message_1acb17877db423d2ac4b103a67e1ae2ff6" kindref="member">content</ref><sp/>==<sp/></highlight><highlight class="stringliteral">&quot;!file&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>request<sp/>an<sp/>image<sp/>and<sp/>co_await<sp/>the<sp/>response</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dpp::http_request_completion_t<sp/>result<sp/>=<sp/>co_await<sp/>cluster-&gt;co_request(</highlight><highlight class="stringliteral">&quot;https://dpp.dev/DPP-Logo.png&quot;</highlight><highlight class="normal">,<sp/>dpp::m_get);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>message</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dpp::message<sp/>msg(event.msg.channel_id,<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>my<sp/>new<sp/>attachment:&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>attach<sp/>the<sp/>image<sp/>on<sp/>success</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(result.status<sp/>==<sp/>200)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>msg.add_file(</highlight><highlight class="stringliteral">&quot;logo.png&quot;</highlight><highlight class="normal">,<sp/>result.body);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>send<sp/>the<sp/>message</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cluster-&gt;<ref refid="classdpp_1_1cluster_1aa6ae3dc32ebc2dd14264962710d35af7" kindref="member">message_create</ref>(msg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bot.start(<ref refid="namespacedpp_1af447e04d0490cd4a9de085e4a758faa4a155f7db65696b4c09b5fcc41787e4726" kindref="member">dpp::st_wait</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Coroutines can make commands simpler by eliminating callbacks, which can be very handy in the case of complex commands that rely on a lot of different data or steps.</para>
<para>In order to be a coroutine, a function has to return a special type with special functions; D++ offers <ref refid="structdpp_1_1job" kindref="compound">dpp::job</ref>, <ref refid="classdpp_1_1task" kindref="compound">dpp::task</ref>, and <ref refid="classdpp_1_1coroutine" kindref="compound">dpp::coroutine</ref>, which are designed to work seamlessly with asynchronous calls through <ref refid="classdpp_1_1async" kindref="compound">dpp::async</ref>, which all the functions starting with <computeroutput>co_</computeroutput> such as <ref refid="classdpp_1_1cluster_1ab9ad0d98f81e30ba95dd39729a2ce818" kindref="member">dpp::cluster::co_message_create</ref> return. Event routers can have a <ref refid="structdpp_1_1job" kindref="compound">dpp::job</ref> attached to them, as this object allows to create coroutines that can execute on their own, asynchronously. More on that and the difference between it and the other two types later. To turn a function into a coroutine, simply make it return <ref refid="structdpp_1_1job" kindref="compound">dpp::job</ref> as seen in the example at line 10, then use <computeroutput>co_await</computeroutput> on awaitable types or <computeroutput>co_return</computeroutput>. The moment the execution encounters one of these two keywords, the function is transformed into a coroutine. Coroutines that use <ref refid="structdpp_1_1job" kindref="compound">dpp::job</ref> can be used for event handlers, they can be attached to an event router just the same way as regular event handlers.</para>
<para>When using a <computeroutput>co_*</computeroutput> function such as <computeroutput>co_message_create</computeroutput>, the request is sent immediately and the returned <ref refid="classdpp_1_1async" kindref="compound">dpp::async</ref> can be <computeroutput>co_await</computeroutput>-ed, at which point the coroutine suspends (pauses) and returns back to its caller; in other words, the program is free to go and do other things while the data is being retrieved and D++ will resume your coroutine when it has the data you need, which will be returned from the <computeroutput>co_await</computeroutput> expression.</para>
<para><simplesect kind="warning"><para>As a rule of thumb when making coroutines, <bold>always prefer taking parameters by value and avoid lambda capture</bold>! See below for an explanation.</para>
</simplesect>
You may hear that coroutines are &quot;writing async code as if it was sync&quot;, while this is sort of correct, it may limit your understanding and especially the dangers of coroutines. I find <bold>they are best thought of as a shortcut for a state machine</bold>, if you&apos;ve ever written one, you know what this means. Think of the lambda as <emphasis>its constructor</emphasis>, in which captures are variable parameters. Think of the parameters passed to your lambda as data members in your state machine. When you <computeroutput>co_await</computeroutput> something, the state machine&apos;s function exits, the program goes back to the caller, at this point the calling function may return. References are kept as references in the state machine, which means by the time the state machine is resumed, the reference may be dangling: <ref refid="lambdas-and-locals" kindref="compound">this is not good</ref>!</para>
<para>Another way to think of them is just like callbacks but keeping the current scope intact. In fact this is exactly what it is, the co_* functions call the normal API calls, with a callback that resumes the coroutine, <emphasis>in the callback thread</emphasis>. This means you cannot rely on thread_local variables and need to keep in mind concurrency issues with global states, as your coroutine will be resumed in another thread than the one it started on. </para>
    </detaileddescription>
    <location file="docpages/example_programs/using_coroutines/coro_introduction.md"/>
  </compounddef>
</doxygen>
