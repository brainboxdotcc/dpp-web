<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="classdpp_1_1event__router__t" kind="class" language="C++" prot="public">
    <compoundname>dpp::event_router_t</compoundname>
    <includes local="no">cluster.h</includes>
    <templateparamlist>
      <param>
        <type>class F</type>
      </param>
    </templateparamlist>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classdpp_1_1event__router__t_1a2381af20978dee7aa87dc071ae315e96" prot="private" static="no" mutable="no">
        <type><ref refid="namespacedpp_1a4641626be7775de0b8b63a6e68d0934e" kindref="member">event_handle</ref></type>
        <definition>event_handle dpp::event_router_t&lt; F &gt;::next_handle</definition>
        <argsstring></argsstring>
        <name>next_handle</name>
        <briefdescription>
<para>Next handle to be given out for this router. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dpp/cluster.h" line="275" column="14" bodyfile="include/dpp/cluster.h" bodystart="275" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdpp_1_1event__router__t_1ab411d5bebc0257b649925399320fe39f" prot="private" static="no" mutable="no">
        <type>std::map&lt; <ref refid="namespacedpp_1a4641626be7775de0b8b63a6e68d0934e" kindref="member">event_handle</ref>, F &gt;</type>
        <definition>std::map&lt;event_handle, F&gt; dpp::event_router_t&lt; F &gt;::dispatch_container</definition>
        <argsstring></argsstring>
        <name>dispatch_container</name>
        <briefdescription>
<para>Container of event listeners keyed by handle, as handles are handed out sequentially they will always be called in they order they are bound to the event as std::map is an ordered container. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dpp/cluster.h" line="282" column="10" bodyfile="include/dpp/cluster.h" bodystart="282" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classdpp_1_1event__router__t_1a55ef09dc1ef7fa2f1e66589cb7153f72" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>dpp::event_router_t&lt; F &gt;::event_router_t</definition>
        <argsstring>()</argsstring>
        <name>event_router_t</name>
        <briefdescription>
<para>Construct a new <ref refid="classdpp_1_1event__router__t" kindref="compound">event_router_t</ref> object. Note: Starts handle at 1. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dpp/cluster.h" line="288" column="1" bodyfile="include/dpp/cluster.h" bodystart="288" bodyend="289"/>
      </memberdef>
      <memberdef kind="function" id="classdpp_1_1event__router__t_1a6e94644732d2785dde4fea7a42330f26" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class E</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void dpp::event_router_t&lt; F &gt;::call</definition>
        <argsstring>(const E &amp;event) const</argsstring>
        <name>call</name>
        <param>
          <type>const E &amp;</type>
          <declname>event</declname>
        </param>
        <briefdescription>
<para>Call all attached listeners. Listenrs may cancel, by calling the event.cancel method. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>class type to pass as parameter to all listeners. This class must be derived from <ref refid="structdpp_1_1event__dispatch__t" kindref="compound">event_dispatch_t</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>event</parametername>
</parameternamelist>
<parameterdescription>
<para>Class to pass as parameter to all listeners. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dpp/cluster.h" line="299" column="17" bodyfile="include/dpp/cluster.h" bodystart="299" bodyend="305"/>
      </memberdef>
      <memberdef kind="function" id="classdpp_1_1event__router__t_1ae0c04d0d1c7488aabff0a5eac7b09dd7" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool dpp::event_router_t&lt; F &gt;::empty</definition>
        <argsstring>() const</argsstring>
        <name>empty</name>
        <briefdescription>
<para>Returns true if the container of listeners is empty, i.e. there is nothing listening for this event right now. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>true if there are no listeners </para>
</simplesect>
<simplesect kind="return"><para>false if there are some listeners </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dpp/cluster.h" line="314" column="6" bodyfile="include/dpp/cluster.h" bodystart="314" bodyend="316"/>
      </memberdef>
      <memberdef kind="function" id="classdpp_1_1event__router__t_1a2be8b888d8117d62fa903439e24bf367" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespacedpp_1a4641626be7775de0b8b63a6e68d0934e" kindref="member">event_handle</ref></type>
        <definition>event_handle dpp::event_router_t&lt; F &gt;::operator()</definition>
        <argsstring>(F func)</argsstring>
        <name>operator()</name>
        <param>
          <type>F</type>
          <declname>func</declname>
        </param>
        <briefdescription>
<para>Attach a lambda to the event, adding a listener. The lambda should follow the signature specified when declaring the event object and should take exactly one parameter derived from <ref refid="structdpp_1_1event__dispatch__t" kindref="compound">event_dispatch_t</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>Function lambda to attach to event </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>event_handle An event handle unique to this event, used to detach the listener from the event later if neccessary. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dpp/cluster.h" line="328" column="14" bodyfile="include/dpp/cluster.h" bodystart="328" bodyend="332"/>
      </memberdef>
      <memberdef kind="function" id="classdpp_1_1event__router__t_1ae4a92aefb81f9c04ab314f5bc248aedf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool dpp::event_router_t&lt; F &gt;::detach</definition>
        <argsstring>(const event_handle handle)</argsstring>
        <name>detach</name>
        <param>
          <type>const <ref refid="namespacedpp_1a4641626be7775de0b8b63a6e68d0934e" kindref="member">event_handle</ref></type>
          <declname>handle</declname>
        </param>
        <briefdescription>
<para>Detach a listener from the event using a previously obtained ID. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>handle</parametername>
</parameternamelist>
<parameterdescription>
<para>An ID obtained from event_router_t::operator() </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true The event was successfully detached </para>
</simplesect>
<simplesect kind="return"><para>false The ID is invalid (possibly already detached, or does not exist) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dpp/cluster.h" line="341" column="6" bodyfile="include/dpp/cluster.h" bodystart="341" bodyend="348"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Handles routing of an event to multiple listeners. Multiple listeners may attach to the <ref refid="classdpp_1_1event__router__t" kindref="compound">event_router_t</ref> by means of operator(). Passing a lambda into operator() attaches to the event. Dispatchers of the event may call the <ref refid="classdpp_1_1event__router__t_1a6e94644732d2785dde4fea7a42330f26" kindref="member">event_router_t::call()</ref> method to cause all listeners to receive the event. The <ref refid="classdpp_1_1event__router__t_1ae0c04d0d1c7488aabff0a5eac7b09dd7" kindref="member">event_router_t::empty()</ref> method will return true if there are no listeners attached to the <ref refid="classdpp_1_1event__router__t" kindref="compound">event_router_t</ref> (this can be used to save time by not constructing objects that nobody will ever see). The <ref refid="classdpp_1_1event__router__t_1ae4a92aefb81f9c04ab314f5bc248aedf" kindref="member">event_router_t::detach()</ref> method removes an existing listener from the event, using the event_handle ID returned by operator(). </para>
    </briefdescription>
    <detaileddescription>
<para>This class is used by the library to route all websocket events to listening code.</para>
<para>Example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Declare<sp/>an<sp/>event<sp/>that<sp/>takes<sp/>log_t<sp/>as<sp/>its<sp/>parameter</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classdpp_1_1event__router__t_1a55ef09dc1ef7fa2f1e66589cb7153f72" kindref="member">event_router_t</ref>&lt;<sp/>std::function&lt;void(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>log_t&amp;<sp/>event)&gt;<sp/>&gt;<sp/>my_event;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Attach<sp/>a<sp/>listener<sp/>to<sp/>the<sp/>event</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacedpp_1a4641626be7775de0b8b63a6e68d0934e" kindref="member">event_handle</ref><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>my_event([&amp;](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>log_t&amp;<sp/>cc)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>cc.message<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Construct<sp/>a<sp/>log_t<sp/>and<sp/>call<sp/>the<sp/>event<sp/>(listeners<sp/>will<sp/>receive<sp/>the<sp/>log_t<sp/>object)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">log_t<sp/>lt;</highlight></codeline>
<codeline><highlight class="normal">lt.message<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;foo&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">my_event.call(lt);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Detach<sp/>from<sp/>an<sp/>event<sp/>using<sp/>the<sp/>handle<sp/>returned<sp/>by<sp/>operator()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">my_event.detach(</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>std::function template for the listener lambda </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
    </detaileddescription>
    <location file="include/dpp/cluster.h" line="270" column="11" bodyfile="include/dpp/cluster.h" bodystart="270" bodyend="349"/>
    <listofallmembers>
      <member refid="classdpp_1_1event__router__t_1a6e94644732d2785dde4fea7a42330f26" prot="public" virt="non-virtual"><scope>dpp::event_router_t</scope><name>call</name></member>
      <member refid="classdpp_1_1event__router__t_1ae4a92aefb81f9c04ab314f5bc248aedf" prot="public" virt="non-virtual"><scope>dpp::event_router_t</scope><name>detach</name></member>
      <member refid="classdpp_1_1event__router__t_1ab411d5bebc0257b649925399320fe39f" prot="private" virt="non-virtual"><scope>dpp::event_router_t</scope><name>dispatch_container</name></member>
      <member refid="classdpp_1_1event__router__t_1ae0c04d0d1c7488aabff0a5eac7b09dd7" prot="public" virt="non-virtual"><scope>dpp::event_router_t</scope><name>empty</name></member>
      <member refid="classdpp_1_1event__router__t_1a55ef09dc1ef7fa2f1e66589cb7153f72" prot="public" virt="non-virtual"><scope>dpp::event_router_t</scope><name>event_router_t</name></member>
      <member refid="classdpp_1_1event__router__t_1a2381af20978dee7aa87dc071ae315e96" prot="private" virt="non-virtual"><scope>dpp::event_router_t</scope><name>next_handle</name></member>
      <member refid="classdpp_1_1event__router__t_1a2be8b888d8117d62fa903439e24bf367" prot="public" virt="non-virtual"><scope>dpp::event_router_t</scope><name>operator()</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
