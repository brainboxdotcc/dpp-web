<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="utf-8">
<meta property="og:title" content="dpp::cluster Class Reference - D++ - The lightweight C++ Discord API Library">
<meta property="og:description" content="A lightweight C++ Discord API library supporting the entire Discord API, including Slash Commands, Voice/Audio, Sharding, Clustering and more!">
<meta name="description" content="dpp::cluster Class Reference - D++ - A lightweight C++ Discord API library supporting the entire Discord API, including Slash Commands, Voice/Audio, Sharding, Clustering and more!">
<meta property="og:image" content="https://dpp.dev/DPP-Logo.png">
<meta property="og:url" content="https://dpp.dev/">
<meta property="og:type" content="website">
<meta property="twitter:title" content="dpp::cluster Class Reference - D++ - The lightweight C++ Discord API Library">
<title>dpp::cluster Class Reference - D++ - The lightweight C++ Discord API Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<script>
	setTimeout(function() {
		$("#main-menu").html($("#main-menu").html() + "<li><select name='vsv' onchange='window.location.href=this.options[this.selectedIndex].value'><option value='/'>master</option><option value='/9.0.13/'>9.0.13</option><option value='/9.0.12/'>9.0.12</option><option value='/9.0.11/'>9.0.11</option><option value='/9.0.10/'>9.0.10</option><option value='/9.0.9/'>9.0.9</option><option value='/9.0.8/'>9.0.8</option><option value='/9.0.7/'>9.0.7</option><option value='/9.0.6/'>9.0.6</option><option value='/9.0.5/'>9.0.5</option><option value='/9.0.4/'>9.0.4</option><option value='/9.0.3/'>9.0.3</option><option value='/9.0.2/'>9.0.2</option><option value='/9.0.1/'>9.0.1</option><option value='/9.0.0/'>9.0.0</option><option value='/1.0.2/'>1.0.2</option><option value='/1.0.1/'>1.0.1</option><option value='/1.0.0/'>1.0.0</option></select></li>");
	}, 500);
</script>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td id="projectlogo"><img alt="Logo" src="DPP-Logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">D++ (DPP)
   </div>
   <div id="projectbrief">A Lightweight C++ library for Discord</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<label for="MSearchField" style="display: none">Search</label>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classdpp_1_1cluster.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdpp_1_1cluster-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">dpp::cluster Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The cluster class represents a group of shards and a command queue for sending and receiving commands from discord via HTTP. You should usually instantiate a cluster object at the very least to make use of the library.  
 <a href="classdpp_1_1cluster.html#details">More...</a></p>

<p><code>#include &lt;cluster.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for dpp::cluster:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classdpp_1_1cluster__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac40e45e1ff8efb4e9ae75a7ecacc786"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aac40e45e1ff8efb4e9ae75a7ecacc786">cluster</a> (const std::string &amp;<a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a>, uint32_t <a class="el" href="namespacedpp.html#a0042c0fc8164da4239b977d5be8e2ef5">intents</a>=<a class="el" href="namespacedpp.html#a0042c0fc8164da4239b977d5be8e2ef5a561a52b3c6883808735c41891351c68f">i_default_intents</a>, uint32_t shards=0, uint32_t <a class="el" href="classdpp_1_1cluster.html#a5155862c1d7267c7f4ee8781ff3e8d7f">cluster_id</a>=0, uint32_t <a class="el" href="classdpp_1_1cluster.html#ad80e4df300e69988d163d61c14e540ab">maxclusters</a>=1, bool compressed=true, <a class="el" href="structdpp_1_1cache__policy__t.html">cache_policy_t</a> policy={<a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>, <a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>, <a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>})</td></tr>
<tr class="memdesc:aac40e45e1ff8efb4e9ae75a7ecacc786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating a cluster. All but the token are optional.  <a href="classdpp_1_1cluster.html#aac40e45e1ff8efb4e9ae75a7ecacc786">More...</a><br /></td></tr>
<tr class="separator:aac40e45e1ff8efb4e9ae75a7ecacc786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0b523f89559b4ce204ca9ed9693d79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6b0b523f89559b4ce204ca9ed9693d79">cluster</a> (const <a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6b0b523f89559b4ce204ca9ed9693d79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdpp_1_1cluster.html" title="The cluster class represents a group of shards and a command queue for sending and receiving commands...">dpp::cluster</a> is non-copyable  <a href="classdpp_1_1cluster.html#a6b0b523f89559b4ce204ca9ed9693d79">More...</a><br /></td></tr>
<tr class="separator:a6b0b523f89559b4ce204ca9ed9693d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d957f52245734f6d44444af8380c952"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2d957f52245734f6d44444af8380c952">cluster</a> (const <a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a2d957f52245734f6d44444af8380c952"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdpp_1_1cluster.html" title="The cluster class represents a group of shards and a command queue for sending and receiving commands...">dpp::cluster</a> is non-moveable  <a href="classdpp_1_1cluster.html#a2d957f52245734f6d44444af8380c952">More...</a><br /></td></tr>
<tr class="separator:a2d957f52245734f6d44444af8380c952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270be0ab59aff4f335ef3f4af7559d92"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a270be0ab59aff4f335ef3f4af7559d92">~cluster</a> ()</td></tr>
<tr class="memdesc:a270be0ab59aff4f335ef3f4af7559d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the cluster object.  <a href="classdpp_1_1cluster.html#a270be0ab59aff4f335ef3f4af7559d92">More...</a><br /></td></tr>
<tr class="separator:a270be0ab59aff4f335ef3f4af7559d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056e4191c03dd210c2a410b6599a0bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a056e4191c03dd210c2a410b6599a0bf9">set_websocket_protocol</a> (<a class="el" href="namespacedpp.html#af7cde3079d745428f44ef6231a2ac672">websocket_protocol_t</a> mode)</td></tr>
<tr class="memdesc:a056e4191c03dd210c2a410b6599a0bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the websocket protocol for all shards on this cluster. You should call this method before <a class="el" href="classdpp_1_1cluster.html#a40e99d13e1380eccd30d13123014594f" title="Start the cluster, connecting all its shards. Returns once all shards are connected.">cluster::start</a>. Generally ws_etf is faster, but provides less facilities for debugging should something go wrong. It is recommended to use ETF in production and JSON in development.  <a href="classdpp_1_1cluster.html#a056e4191c03dd210c2a410b6599a0bf9">More...</a><br /></td></tr>
<tr class="separator:a056e4191c03dd210c2a410b6599a0bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcc02c388c197cf7050551ef89aeefe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe">set_audit_reason</a> (const std::string &amp;reason)</td></tr>
<tr class="memdesc:adbcc02c388c197cf7050551ef89aeefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the audit log reason for the next REST call to be made. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically.  <a href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe">More...</a><br /></td></tr>
<tr class="separator:adbcc02c388c197cf7050551ef89aeefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e3f0868ece15373e81844dff719aa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af1e3f0868ece15373e81844dff719aa0">clear_audit_reason</a> ()</td></tr>
<tr class="memdesc:af1e3f0868ece15373e81844dff719aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the audit log reason for the next REST call to be made. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically.  <a href="classdpp_1_1cluster.html#af1e3f0868ece15373e81844dff719aa0">More...</a><br /></td></tr>
<tr class="separator:af1e3f0868ece15373e81844dff719aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a2958625740b4a6fde6643042c5f7e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab7a2958625740b4a6fde6643042c5f7e">get_audit_reason</a> ()</td></tr>
<tr class="memdesc:ab7a2958625740b4a6fde6643042c5f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the audit reason set for the next REST call to be made on this thread. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically.  <a href="classdpp_1_1cluster.html#ab7a2958625740b4a6fde6643042c5f7e">More...</a><br /></td></tr>
<tr class="separator:ab7a2958625740b4a6fde6643042c5f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13689440c9cc80279d415c563a6363c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a13689440c9cc80279d415c563a6363c0">log</a> (<a class="el" href="namespacedpp.html#a7d48d478ccc3bffb34637bdb48f629c2">dpp::loglevel</a> severity, const std::string &amp;msg) const</td></tr>
<tr class="memdesc:a13689440c9cc80279d415c563a6363c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log a message to whatever log the user is using. The logged message is passed up the chain to the on_log event in user code which can then do whatever it wants to do with it.  <a href="classdpp_1_1cluster.html#a13689440c9cc80279d415c563a6363c0">More...</a><br /></td></tr>
<tr class="separator:a13689440c9cc80279d415c563a6363c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a87a674519512fbf96b59f9b9cb8bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a8b9ab0b8cf29978147a7df3947cd8f30">timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2a87a674519512fbf96b59f9b9cb8bb5">start_timer</a> (<a class="el" href="namespacedpp.html#a13d8465c3c643fdd87405fd115cd4964">timer_callback_t</a> on_tick, uint64_t frequency, <a class="el" href="namespacedpp.html#a13d8465c3c643fdd87405fd115cd4964">timer_callback_t</a> on_stop={})</td></tr>
<tr class="memdesc:a2a87a674519512fbf96b59f9b9cb8bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a timer. Every <code>frequency</code> seconds, the callback is called.  <a href="classdpp_1_1cluster.html#a2a87a674519512fbf96b59f9b9cb8bb5">More...</a><br /></td></tr>
<tr class="separator:a2a87a674519512fbf96b59f9b9cb8bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065dbc305d760d94f4ce0867f64777a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a065dbc305d760d94f4ce0867f64777a3">stop_timer</a> (<a class="el" href="namespacedpp.html#a8b9ab0b8cf29978147a7df3947cd8f30">timer</a> t)</td></tr>
<tr class="memdesc:a065dbc305d760d94f4ce0867f64777a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a ticking timer.  <a href="classdpp_1_1cluster.html#a065dbc305d760d94f4ce0867f64777a3">More...</a><br /></td></tr>
<tr class="separator:a065dbc305d760d94f4ce0867f64777a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6164d5543b7594731a980da9b0b2088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae6164d5543b7594731a980da9b0b2088">get_dm_channel</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id)</td></tr>
<tr class="memdesc:ae6164d5543b7594731a980da9b0b2088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dm channel for a user id.  <a href="classdpp_1_1cluster.html#ae6164d5543b7594731a980da9b0b2088">More...</a><br /></td></tr>
<tr class="separator:ae6164d5543b7594731a980da9b0b2088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc501cc0ebb334d09a7f4bb1ea6b3e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3fc501cc0ebb334d09a7f4bb1ea6b3e6">set_dm_channel</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id)</td></tr>
<tr class="memdesc:a3fc501cc0ebb334d09a7f4bb1ea6b3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dm channel id for a user id.  <a href="classdpp_1_1cluster.html#a3fc501cc0ebb334d09a7f4bb1ea6b3e6">More...</a><br /></td></tr>
<tr class="separator:a3fc501cc0ebb334d09a7f4bb1ea6b3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12b5b33ea156bde9977796858066a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdpp_1_1utility_1_1uptime.html">dpp::utility::uptime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af12b5b33ea156bde9977796858066a6b">uptime</a> ()</td></tr>
<tr class="memdesc:af12b5b33ea156bde9977796858066a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uptime of the cluster.  <a href="classdpp_1_1cluster.html#af12b5b33ea156bde9977796858066a6b">More...</a><br /></td></tr>
<tr class="separator:af12b5b33ea156bde9977796858066a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e99d13e1380eccd30d13123014594f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a40e99d13e1380eccd30d13123014594f">start</a> (bool return_after=true)</td></tr>
<tr class="memdesc:a40e99d13e1380eccd30d13123014594f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the cluster, connecting all its shards. Returns once all shards are connected.  <a href="classdpp_1_1cluster.html#a40e99d13e1380eccd30d13123014594f">More...</a><br /></td></tr>
<tr class="separator:a40e99d13e1380eccd30d13123014594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b67c9455ac0378712e4c0fd0ba7f2a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9b67c9455ac0378712e4c0fd0ba7f2a9">set_presence</a> (const class <a class="el" href="classdpp_1_1presence.html">dpp::presence</a> &amp;p)</td></tr>
<tr class="memdesc:a9b67c9455ac0378712e4c0fd0ba7f2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the presence for all shards on the cluster.  <a href="classdpp_1_1cluster.html#a9b67c9455ac0378712e4c0fd0ba7f2a9">More...</a><br /></td></tr>
<tr class="separator:a9b67c9455ac0378712e4c0fd0ba7f2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c677c0d5c059e87cc01ce598d49487d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1discord__client.html">discord_client</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5c677c0d5c059e87cc01ce598d49487d">get_shard</a> (uint32_t id)</td></tr>
<tr class="memdesc:a5c677c0d5c059e87cc01ce598d49487d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shard by id, returning the <a class="el" href="classdpp_1_1discord__client.html" title="Implements a discord client. Each discord_client connects to one shard and derives from a websocket c...">discord_client</a>.  <a href="classdpp_1_1cluster.html#a5c677c0d5c059e87cc01ce598d49487d">More...</a><br /></td></tr>
<tr class="separator:a5c677c0d5c059e87cc01ce598d49487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d6195862e6d25c644902631a0b34d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedpp.html#a13c4d4e6238396245b349e6a637897e0">shard_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af4d6195862e6d25c644902631a0b34d1">get_shards</a> ()</td></tr>
<tr class="memdesc:af4d6195862e6d25c644902631a0b34d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of shards.  <a href="classdpp_1_1cluster.html#af4d6195862e6d25c644902631a0b34d1">More...</a><br /></td></tr>
<tr class="separator:af4d6195862e6d25c644902631a0b34d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b83ee3be02df68eb5e697ddc5efc0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a62b83ee3be02df68eb5e697ddc5efc0a">post_rest</a> (const std::string &amp;endpoint, const std::string &amp;major_parameters, const std::string &amp;parameters, <a class="el" href="namespacedpp.html#a805ef1feb2862a208ec0e9d1be005c88">http_method</a> method, const std::string &amp;postdata, <a class="el" href="namespacedpp.html#aafc7fb6792b12d92c4e77b46d20924ee">json_encode_t</a> callback, const std::string &amp;filename=&quot;&quot;, const std::string &amp;filecontent=&quot;&quot;)</td></tr>
<tr class="memdesc:a62b83ee3be02df68eb5e697ddc5efc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a REST request. Where possible use a helper method instead like message_create.  <a href="classdpp_1_1cluster.html#a62b83ee3be02df68eb5e697ddc5efc0a">More...</a><br /></td></tr>
<tr class="separator:a62b83ee3be02df68eb5e697ddc5efc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156fe68358c421111e690f553c4e4f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a156fe68358c421111e690f553c4e4f52">request</a> (const std::string &amp;url, <a class="el" href="namespacedpp.html#a805ef1feb2862a208ec0e9d1be005c88">http_method</a> method, <a class="el" href="namespacedpp.html#ae3249e99494d04bb4be50341f474621e">http_completion_event</a> callback, const std::string &amp;postdata=&quot;&quot;, const std::string &amp;mimetype=&quot;text/plain&quot;, const std::multimap&lt; std::string, std::string &gt; &amp;headers={})</td></tr>
<tr class="memdesc:a156fe68358c421111e690f553c4e4f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a HTTP(S) request. For use when wanting asnyncronous access to HTTP APIs outside of Discord.  <a href="classdpp_1_1cluster.html#a156fe68358c421111e690f553c4e4f52">More...</a><br /></td></tr>
<tr class="separator:a156fe68358c421111e690f553c4e4f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c92a68228fe9dcb96b1c7cb6b8ae795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4c92a68228fe9dcb96b1c7cb6b8ae795">interaction_response_create</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> interaction_id, const std::string &amp;<a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a>, const <a class="el" href="structdpp_1_1interaction__response.html">interaction_response</a> &amp;r, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a4c92a68228fe9dcb96b1c7cb6b8ae795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Respond to a slash command.  <a href="classdpp_1_1cluster.html#a4c92a68228fe9dcb96b1c7cb6b8ae795">More...</a><br /></td></tr>
<tr class="separator:a4c92a68228fe9dcb96b1c7cb6b8ae795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c9c18dd9185dfc2cc61b463ad7cf0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a41c9c18dd9185dfc2cc61b463ad7cf0f">interaction_response_edit</a> (const std::string &amp;<a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a>, const <a class="el" href="structdpp_1_1message.html">message</a> &amp;r, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a41c9c18dd9185dfc2cc61b463ad7cf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Respond to a slash command.  <a href="classdpp_1_1cluster.html#a41c9c18dd9185dfc2cc61b463ad7cf0f">More...</a><br /></td></tr>
<tr class="separator:a41c9c18dd9185dfc2cc61b463ad7cf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124b1a52ca2f5ae298f1bb99ca964dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a124b1a52ca2f5ae298f1bb99ca964dcb">global_command_create</a> (const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;s, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a124b1a52ca2f5ae298f1bb99ca964dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global slash command (a bot can have a maximum of 100 of these).  <a href="classdpp_1_1cluster.html#a124b1a52ca2f5ae298f1bb99ca964dcb">More...</a><br /></td></tr>
<tr class="separator:a124b1a52ca2f5ae298f1bb99ca964dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a61aa62ddf9207c197bfd496ae6ade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a74a61aa62ddf9207c197bfd496ae6ade">guild_auditlog_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a74a61aa62ddf9207c197bfd496ae6ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the audit log for a guild.  <a href="classdpp_1_1cluster.html#a74a61aa62ddf9207c197bfd496ae6ade">More...</a><br /></td></tr>
<tr class="separator:a74a61aa62ddf9207c197bfd496ae6ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0ce1ad5256a252ab0ce43923a07ae3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4c0ce1ad5256a252ab0ce43923a07ae3">guild_command_create</a> (const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;s, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a4c0ce1ad5256a252ab0ce43923a07ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slash command local to a guild.  <a href="classdpp_1_1cluster.html#a4c0ce1ad5256a252ab0ce43923a07ae3">More...</a><br /></td></tr>
<tr class="separator:a4c0ce1ad5256a252ab0ce43923a07ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aad2d123fe4d13cb880ff59d8048f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa7aad2d123fe4d13cb880ff59d8048f5">guild_bulk_command_create</a> (const std::vector&lt; <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &gt; &amp;commands, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa7aad2d123fe4d13cb880ff59d8048f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create/overwrite guild slash commands. Any existing guild slash commands on this guild will be deleted and replaced with these.  <a href="classdpp_1_1cluster.html#aa7aad2d123fe4d13cb880ff59d8048f5">More...</a><br /></td></tr>
<tr class="separator:aa7aad2d123fe4d13cb880ff59d8048f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2319ca200dcd5cce1b9b6696946ece22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2319ca200dcd5cce1b9b6696946ece22">global_bulk_command_create</a> (const std::vector&lt; <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &gt; &amp;commands, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a2319ca200dcd5cce1b9b6696946ece22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create/overwrite global slash commands. Any existing global slash commands will be deletd and replaced with these.  <a href="classdpp_1_1cluster.html#a2319ca200dcd5cce1b9b6696946ece22">More...</a><br /></td></tr>
<tr class="separator:a2319ca200dcd5cce1b9b6696946ece22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef037a47fee2efddedfe78ba4bf0467c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aef037a47fee2efddedfe78ba4bf0467c">global_command_edit</a> (const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;s, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aef037a47fee2efddedfe78ba4bf0467c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a global slash command (a bot can have a maximum of 100 of these)  <a href="classdpp_1_1cluster.html#aef037a47fee2efddedfe78ba4bf0467c">More...</a><br /></td></tr>
<tr class="separator:aef037a47fee2efddedfe78ba4bf0467c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d555ccc3e69298ccac9d160ce3a71bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4d555ccc3e69298ccac9d160ce3a71bf">guild_command_edit</a> (const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;s, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a4d555ccc3e69298ccac9d160ce3a71bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a slash command local to a guild.  <a href="classdpp_1_1cluster.html#a4d555ccc3e69298ccac9d160ce3a71bf">More...</a><br /></td></tr>
<tr class="separator:a4d555ccc3e69298ccac9d160ce3a71bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebb701d07c25d3667f0e1640670bbc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4ebb701d07c25d3667f0e1640670bbc1">guild_command_edit_permissions</a> (const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;s, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a4ebb701d07c25d3667f0e1640670bbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit slash command permissions local to a guild, permissions are read from s.permissions.  <a href="classdpp_1_1cluster.html#a4ebb701d07c25d3667f0e1640670bbc1">More...</a><br /></td></tr>
<tr class="separator:a4ebb701d07c25d3667f0e1640670bbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb7e2a8ddcb41a39d989802853a8605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7cb7e2a8ddcb41a39d989802853a8605">global_command_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a7cb7e2a8ddcb41a39d989802853a8605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a global slash command (a bot can have a maximum of 100 of these)  <a href="classdpp_1_1cluster.html#a7cb7e2a8ddcb41a39d989802853a8605">More...</a><br /></td></tr>
<tr class="separator:a7cb7e2a8ddcb41a39d989802853a8605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4a91a572c4e33ae60a3b09041ae3c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5b4a91a572c4e33ae60a3b09041ae3c2">guild_command_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a5b4a91a572c4e33ae60a3b09041ae3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a slash command local to a guild.  <a href="classdpp_1_1cluster.html#a5b4a91a572c4e33ae60a3b09041ae3c2">More...</a><br /></td></tr>
<tr class="separator:a5b4a91a572c4e33ae60a3b09041ae3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01623d7535dc359905990e710ae3b5e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a01623d7535dc359905990e710ae3b5e9">guild_commands_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a01623d7535dc359905990e710ae3b5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the application's slash commands for a guild.  <a href="classdpp_1_1cluster.html#a01623d7535dc359905990e710ae3b5e9">More...</a><br /></td></tr>
<tr class="separator:a01623d7535dc359905990e710ae3b5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8cadcdde42fcfa8d29c0c4fd0bec5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8a8cadcdde42fcfa8d29c0c4fd0bec5b">global_commands_get</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a8a8cadcdde42fcfa8d29c0c4fd0bec5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the application's global slash commands.  <a href="classdpp_1_1cluster.html#a8a8cadcdde42fcfa8d29c0c4fd0bec5b">More...</a><br /></td></tr>
<tr class="separator:a8a8cadcdde42fcfa8d29c0c4fd0bec5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a5e7d9ba9dcbfc1e219eeb029f61ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae3a5e7d9ba9dcbfc1e219eeb029f61ad">direct_message_create</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, const <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ae3a5e7d9ba9dcbfc1e219eeb029f61ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a direct message, also create the channel for the direct message if needed.  <a href="classdpp_1_1cluster.html#ae3a5e7d9ba9dcbfc1e219eeb029f61ad">More...</a><br /></td></tr>
<tr class="separator:ae3a5e7d9ba9dcbfc1e219eeb029f61ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3b0f7c3dae4ecb1980cabe8f10ccd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9d3b0f7c3dae4ecb1980cabe8f10ccd7">message_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a9d3b0f7c3dae4ecb1980cabe8f10ccd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a message.  <a href="classdpp_1_1cluster.html#a9d3b0f7c3dae4ecb1980cabe8f10ccd7">More...</a><br /></td></tr>
<tr class="separator:a9d3b0f7c3dae4ecb1980cabe8f10ccd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630d744322d1f570a63f33ae10b23ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a630d744322d1f570a63f33ae10b23ae9">messages_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> around, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> before, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> after, uint8_t limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a630d744322d1f570a63f33ae10b23ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multiple messages.  <a href="classdpp_1_1cluster.html#a630d744322d1f570a63f33ae10b23ae9">More...</a><br /></td></tr>
<tr class="separator:a630d744322d1f570a63f33ae10b23ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080a8cefc6ceb0b882fdb6fe70c078a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a080a8cefc6ceb0b882fdb6fe70c078a6">message_create</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a080a8cefc6ceb0b882fdb6fe70c078a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to a channel. The callback function is called when the message has been sent.  <a href="classdpp_1_1cluster.html#a080a8cefc6ceb0b882fdb6fe70c078a6">More...</a><br /></td></tr>
<tr class="separator:a080a8cefc6ceb0b882fdb6fe70c078a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdf2c55ac48902e7b194ab8e651d869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8cdf2c55ac48902e7b194ab8e651d869">message_crosspost</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a8cdf2c55ac48902e7b194ab8e651d869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crosspost a message. The callback function is called when the message has been sent.  <a href="classdpp_1_1cluster.html#a8cdf2c55ac48902e7b194ab8e651d869">More...</a><br /></td></tr>
<tr class="separator:a8cdf2c55ac48902e7b194ab8e651d869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754206a7e97f1aaab4ab83ed53e4f351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a754206a7e97f1aaab4ab83ed53e4f351">message_edit</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a754206a7e97f1aaab4ab83ed53e4f351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a message on a channel. The callback function is called when the message has been edited.  <a href="classdpp_1_1cluster.html#a754206a7e97f1aaab4ab83ed53e4f351">More...</a><br /></td></tr>
<tr class="separator:a754206a7e97f1aaab4ab83ed53e4f351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eb4e0352a29a92587d677d4b5fd6a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a08eb4e0352a29a92587d677d4b5fd6a7">message_add_reaction</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a08eb4e0352a29a92587d677d4b5fd6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a reaction to a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a08eb4e0352a29a92587d677d4b5fd6a7">More...</a><br /></td></tr>
<tr class="separator:a08eb4e0352a29a92587d677d4b5fd6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9abca51107d5aed147fa9b0aa8d675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aba9abca51107d5aed147fa9b0aa8d675">message_delete_own_reaction</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aba9abca51107d5aed147fa9b0aa8d675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete own reaction from a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#aba9abca51107d5aed147fa9b0aa8d675">More...</a><br /></td></tr>
<tr class="separator:aba9abca51107d5aed147fa9b0aa8d675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b04160e95d808013fe222a9b690dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a72b04160e95d808013fe222a9b690dae">message_delete_reaction</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a72b04160e95d808013fe222a9b690dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a user's reaction from a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a72b04160e95d808013fe222a9b690dae">More...</a><br /></td></tr>
<tr class="separator:a72b04160e95d808013fe222a9b690dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05fea3d6c298d5f2371704084383f8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab05fea3d6c298d5f2371704084383f8f">message_get_reactions</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> before, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> after, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ab05fea3d6c298d5f2371704084383f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reactions on a message for a particular emoji. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#ab05fea3d6c298d5f2371704084383f8f">More...</a><br /></td></tr>
<tr class="separator:ab05fea3d6c298d5f2371704084383f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ae40b4389928ce8e6f8d9b47512291"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a13ae40b4389928ce8e6f8d9b47512291">message_delete_all_reactions</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a13ae40b4389928ce8e6f8d9b47512291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all reactions on a message.  <a href="classdpp_1_1cluster.html#a13ae40b4389928ce8e6f8d9b47512291">More...</a><br /></td></tr>
<tr class="separator:a13ae40b4389928ce8e6f8d9b47512291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1478ca3f0fb3c645a34474099e4e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6a1478ca3f0fb3c645a34474099e4e04">message_delete_reaction_emoji</a> (const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a6a1478ca3f0fb3c645a34474099e4e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all reactions on a message using a particular emoji. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a6a1478ca3f0fb3c645a34474099e4e04">More...</a><br /></td></tr>
<tr class="separator:a6a1478ca3f0fb3c645a34474099e4e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c38aa5a7737577fbafcd67a783c60d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8c38aa5a7737577fbafcd67a783c60d1">message_add_reaction</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a8c38aa5a7737577fbafcd67a783c60d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a reaction to a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a8c38aa5a7737577fbafcd67a783c60d1">More...</a><br /></td></tr>
<tr class="separator:a8c38aa5a7737577fbafcd67a783c60d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b18295b9fc438b84c21cc5dd60db8db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3b18295b9fc438b84c21cc5dd60db8db">message_delete_own_reaction</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a3b18295b9fc438b84c21cc5dd60db8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete own reaction from a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a3b18295b9fc438b84c21cc5dd60db8db">More...</a><br /></td></tr>
<tr class="separator:a3b18295b9fc438b84c21cc5dd60db8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b157698d6c65e96a6a96ef93fee9f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0b157698d6c65e96a6a96ef93fee9f56">message_delete_reaction</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a0b157698d6c65e96a6a96ef93fee9f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a user's reaction from a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a0b157698d6c65e96a6a96ef93fee9f56">More...</a><br /></td></tr>
<tr class="separator:a0b157698d6c65e96a6a96ef93fee9f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06083a6cacaf7c4e41884cfb2a1078ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a06083a6cacaf7c4e41884cfb2a1078ab">message_get_reactions</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> before, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> after, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a06083a6cacaf7c4e41884cfb2a1078ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reactions on a message for a particular emoji by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a06083a6cacaf7c4e41884cfb2a1078ab">More...</a><br /></td></tr>
<tr class="separator:a06083a6cacaf7c4e41884cfb2a1078ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253f894d05325a56d85663a4759288a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a253f894d05325a56d85663a4759288a2">message_delete_all_reactions</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a253f894d05325a56d85663a4759288a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all reactions on a message by id.  <a href="classdpp_1_1cluster.html#a253f894d05325a56d85663a4759288a2">More...</a><br /></td></tr>
<tr class="separator:a253f894d05325a56d85663a4759288a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ffe65c0dda699e586f78c61649bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a144ffe65c0dda699e586f78c61649bf5">message_delete_reaction_emoji</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, const std::string &amp;<a class="el" href="structdpp_1_1reaction.html">reaction</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a144ffe65c0dda699e586f78c61649bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all reactions on a message using a particular emoji by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character.  <a href="classdpp_1_1cluster.html#a144ffe65c0dda699e586f78c61649bf5">More...</a><br /></td></tr>
<tr class="separator:a144ffe65c0dda699e586f78c61649bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb75919ec5abd5b510255692ef439f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#abb75919ec5abd5b510255692ef439f97">message_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:abb75919ec5abd5b510255692ef439f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a message from a channel. The callback function is called when the message has been edited.  <a href="classdpp_1_1cluster.html#abb75919ec5abd5b510255692ef439f97">More...</a><br /></td></tr>
<tr class="separator:abb75919ec5abd5b510255692ef439f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4534c2c87bf45c326b126ef0a00ee80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab4534c2c87bf45c326b126ef0a00ee80">message_delete_bulk</a> (const std::vector&lt; <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> &gt; &amp;message_ids, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ab4534c2c87bf45c326b126ef0a00ee80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk delete messages from a channel. The callback function is called when the message has been edited.  <a href="classdpp_1_1cluster.html#ab4534c2c87bf45c326b126ef0a00ee80">More...</a><br /></td></tr>
<tr class="separator:ab4534c2c87bf45c326b126ef0a00ee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108f6f06b43709c8d47df5f94a3ca0a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a108f6f06b43709c8d47df5f94a3ca0a5">channel_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a108f6f06b43709c8d47df5f94a3ca0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a channel.  <a href="classdpp_1_1cluster.html#a108f6f06b43709c8d47df5f94a3ca0a5">More...</a><br /></td></tr>
<tr class="separator:a108f6f06b43709c8d47df5f94a3ca0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e67431b79cc2c3d0f12d59afd5a1c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a24e67431b79cc2c3d0f12d59afd5a1c8">channels_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a24e67431b79cc2c3d0f12d59afd5a1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all channels for a guild.  <a href="classdpp_1_1cluster.html#a24e67431b79cc2c3d0f12d59afd5a1c8">More...</a><br /></td></tr>
<tr class="separator:a24e67431b79cc2c3d0f12d59afd5a1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73706406e2f99b9a580319e389777be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad73706406e2f99b9a580319e389777be">channel_create</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad73706406e2f99b9a580319e389777be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a channel.  <a href="classdpp_1_1cluster.html#ad73706406e2f99b9a580319e389777be">More...</a><br /></td></tr>
<tr class="separator:ad73706406e2f99b9a580319e389777be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5511e31156dd2508387b1ba5a1612c09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5511e31156dd2508387b1ba5a1612c09">channel_edit</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a5511e31156dd2508387b1ba5a1612c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a channel.  <a href="classdpp_1_1cluster.html#a5511e31156dd2508387b1ba5a1612c09">More...</a><br /></td></tr>
<tr class="separator:a5511e31156dd2508387b1ba5a1612c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391779232600ba3a6f57d678047761b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a391779232600ba3a6f57d678047761b0">channel_edit_position</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a391779232600ba3a6f57d678047761b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a channel's position.  <a href="classdpp_1_1cluster.html#a391779232600ba3a6f57d678047761b0">More...</a><br /></td></tr>
<tr class="separator:a391779232600ba3a6f57d678047761b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb4457e63c60500b44bfdee27d80c75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#abfb4457e63c60500b44bfdee27d80c75">channel_edit_permissions</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> overwrite_id, uint32_t allow, uint32_t deny, bool member, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:abfb4457e63c60500b44bfdee27d80c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a channel's permissions.  <a href="classdpp_1_1cluster.html#abfb4457e63c60500b44bfdee27d80c75">More...</a><br /></td></tr>
<tr class="separator:abfb4457e63c60500b44bfdee27d80c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b00dafa69984d444422b500c3d18b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad3b00dafa69984d444422b500c3d18b3">channel_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad3b00dafa69984d444422b500c3d18b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a channel.  <a href="classdpp_1_1cluster.html#ad3b00dafa69984d444422b500c3d18b3">More...</a><br /></td></tr>
<tr class="separator:ad3b00dafa69984d444422b500c3d18b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d4220a93d6ba8c72d5472fd6718d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4a4d4220a93d6ba8c72d5472fd6718d0">invite_get</a> (const std::string &amp;<a class="el" href="classdpp_1_1invite.html">invite</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a4a4d4220a93d6ba8c72d5472fd6718d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get details about an invite.  <a href="classdpp_1_1cluster.html#a4a4d4220a93d6ba8c72d5472fd6718d0">More...</a><br /></td></tr>
<tr class="separator:a4a4d4220a93d6ba8c72d5472fd6718d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c22698fbbb32edebd9824309015a017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4c22698fbbb32edebd9824309015a017">invite_delete</a> (const std::string &amp;<a class="el" href="classdpp_1_1invite.html">invite</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a4c22698fbbb32edebd9824309015a017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an invite.  <a href="classdpp_1_1cluster.html#a4c22698fbbb32edebd9824309015a017">More...</a><br /></td></tr>
<tr class="separator:a4c22698fbbb32edebd9824309015a017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03a0da5c8e6801dc56bda258265da04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa03a0da5c8e6801dc56bda258265da04">channel_invites_get</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:aa03a0da5c8e6801dc56bda258265da04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get invites for a channel.  <a href="classdpp_1_1cluster.html#aa03a0da5c8e6801dc56bda258265da04">More...</a><br /></td></tr>
<tr class="separator:aa03a0da5c8e6801dc56bda258265da04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e66a7400101f466aab40ed58c67942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a07e66a7400101f466aab40ed58c67942">channel_invite_create</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, const class <a class="el" href="classdpp_1_1invite.html">invite</a> &amp;i, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a07e66a7400101f466aab40ed58c67942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create invite for a channel.  <a href="classdpp_1_1cluster.html#a07e66a7400101f466aab40ed58c67942">More...</a><br /></td></tr>
<tr class="separator:a07e66a7400101f466aab40ed58c67942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553bfda3b4f1671e75c5713275b781bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a553bfda3b4f1671e75c5713275b781bd">channel_pins_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a553bfda3b4f1671e75c5713275b781bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a channel's pins.  <a href="classdpp_1_1cluster.html#a553bfda3b4f1671e75c5713275b781bd">More...</a><br /></td></tr>
<tr class="separator:a553bfda3b4f1671e75c5713275b781bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad36637b9bb094d9f24d18f204138a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9ad36637b9bb094d9f24d18f204138a3">gdm_add</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, const std::string &amp;access_token, const std::string &amp;nick, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a9ad36637b9bb094d9f24d18f204138a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a recipient to a Group DM using their access token.  <a href="classdpp_1_1cluster.html#a9ad36637b9bb094d9f24d18f204138a3">More...</a><br /></td></tr>
<tr class="separator:a9ad36637b9bb094d9f24d18f204138a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be231a13131f6fae94f88ee6fcdc5f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6be231a13131f6fae94f88ee6fcdc5f0">gdm_remove</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a6be231a13131f6fae94f88ee6fcdc5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a recipient from a Group DM.  <a href="classdpp_1_1cluster.html#a6be231a13131f6fae94f88ee6fcdc5f0">More...</a><br /></td></tr>
<tr class="separator:a6be231a13131f6fae94f88ee6fcdc5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fce9638b93c6b5d5d67f8bea9f8f6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa2fce9638b93c6b5d5d67f8bea9f8f6c">channel_delete_permission</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> overwrite_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa2fce9638b93c6b5d5d67f8bea9f8f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a permission from a channel.  <a href="classdpp_1_1cluster.html#aa2fce9638b93c6b5d5d67f8bea9f8f6c">More...</a><br /></td></tr>
<tr class="separator:aa2fce9638b93c6b5d5d67f8bea9f8f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7593e4ba82977bf3d8ad9052c9c565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1b7593e4ba82977bf3d8ad9052c9c565">channel_follow_news</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> target_channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a1b7593e4ba82977bf3d8ad9052c9c565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Follow a news channel.  <a href="classdpp_1_1cluster.html#a1b7593e4ba82977bf3d8ad9052c9c565">More...</a><br /></td></tr>
<tr class="separator:a1b7593e4ba82977bf3d8ad9052c9c565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caf58e161373fd3fa26172a4a78c835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2caf58e161373fd3fa26172a4a78c835">channel_typing</a> (const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;c, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a2caf58e161373fd3fa26172a4a78c835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger channel typing indicator.  <a href="classdpp_1_1cluster.html#a2caf58e161373fd3fa26172a4a78c835">More...</a><br /></td></tr>
<tr class="separator:a2caf58e161373fd3fa26172a4a78c835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80ac0e99c0a20c9c05678631189b8f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad80ac0e99c0a20c9c05678631189b8f3">channel_typing</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> cid, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad80ac0e99c0a20c9c05678631189b8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger channel typing indicator.  <a href="classdpp_1_1cluster.html#ad80ac0e99c0a20c9c05678631189b8f3">More...</a><br /></td></tr>
<tr class="separator:ad80ac0e99c0a20c9c05678631189b8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa140a11ab0b2feede600761aaee2483b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa140a11ab0b2feede600761aaee2483b">message_pin</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa140a11ab0b2feede600761aaee2483b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pin a message.  <a href="classdpp_1_1cluster.html#aa140a11ab0b2feede600761aaee2483b">More...</a><br /></td></tr>
<tr class="separator:aa140a11ab0b2feede600761aaee2483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454e53cea10416ca9d299855dbb08e0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a454e53cea10416ca9d299855dbb08e0b">message_unpin</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a454e53cea10416ca9d299855dbb08e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpin a message.  <a href="classdpp_1_1cluster.html#a454e53cea10416ca9d299855dbb08e0b">More...</a><br /></td></tr>
<tr class="separator:a454e53cea10416ca9d299855dbb08e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a003669770549d25a951810bff0153e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6a003669770549d25a951810bff0153e">guild_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> g, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a6a003669770549d25a951810bff0153e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a guild.  <a href="classdpp_1_1cluster.html#a6a003669770549d25a951810bff0153e">More...</a><br /></td></tr>
<tr class="separator:a6a003669770549d25a951810bff0153e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecd82c6169107c9c944356f19abba9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3ecd82c6169107c9c944356f19abba9e">guild_get_preview</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> g, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a3ecd82c6169107c9c944356f19abba9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a guild preview. Returns a guild object but only a subset of the fields will be populated.  <a href="classdpp_1_1cluster.html#a3ecd82c6169107c9c944356f19abba9e">More...</a><br /></td></tr>
<tr class="separator:a3ecd82c6169107c9c944356f19abba9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e8227f11ef33cd2d9cc3abef46adfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a99e8227f11ef33cd2d9cc3abef46adfd">guild_get_member</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a99e8227f11ef33cd2d9cc3abef46adfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a guild member.  <a href="classdpp_1_1cluster.html#a99e8227f11ef33cd2d9cc3abef46adfd">More...</a><br /></td></tr>
<tr class="separator:a99e8227f11ef33cd2d9cc3abef46adfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cc92ce052d063854e0372539e4d9ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a52cc92ce052d063854e0372539e4d9ee">guild_search_members</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;query, uint16_t limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a52cc92ce052d063854e0372539e4d9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for guild members based on whether their username or nickname starts with the given string.  <a href="classdpp_1_1cluster.html#a52cc92ce052d063854e0372539e4d9ee">More...</a><br /></td></tr>
<tr class="separator:a52cc92ce052d063854e0372539e4d9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b24baba4de9d38f7d9a7cea2f71a545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6b24baba4de9d38f7d9a7cea2f71a545">guild_get_members</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, uint16_t limit, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> after, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a6b24baba4de9d38f7d9a7cea2f71a545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all guild members.  <a href="classdpp_1_1cluster.html#a6b24baba4de9d38f7d9a7cea2f71a545">More...</a><br /></td></tr>
<tr class="separator:a6b24baba4de9d38f7d9a7cea2f71a545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2937f10828bc3fbdeff87fc6b4463cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa2937f10828bc3fbdeff87fc6b4463cc">guild_add_member</a> (const <a class="el" href="classdpp_1_1guild__member.html">guild_member</a> &amp;gm, const std::string &amp;access_token, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa2937f10828bc3fbdeff87fc6b4463cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add guild member. Needs a specific oauth2 scope, from which you get the access_token.  <a href="classdpp_1_1cluster.html#aa2937f10828bc3fbdeff87fc6b4463cc">More...</a><br /></td></tr>
<tr class="separator:aa2937f10828bc3fbdeff87fc6b4463cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a1957b81c9606850e730c477dd44aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a57a1957b81c9606850e730c477dd44aa">guild_edit_member</a> (const <a class="el" href="classdpp_1_1guild__member.html">guild_member</a> &amp;gm, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a57a1957b81c9606850e730c477dd44aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit the properties of an existing guild member.  <a href="classdpp_1_1cluster.html#a57a1957b81c9606850e730c477dd44aa">More...</a><br /></td></tr>
<tr class="separator:a57a1957b81c9606850e730c477dd44aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40665f55528cfc1077b8adcae2d49086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a40665f55528cfc1077b8adcae2d49086">guild_member_move</a> (const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a40665f55528cfc1077b8adcae2d49086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the guild member to a other voice channel, if member is connected to one.  <a href="classdpp_1_1cluster.html#a40665f55528cfc1077b8adcae2d49086">More...</a><br /></td></tr>
<tr class="separator:a40665f55528cfc1077b8adcae2d49086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30ff4f80815720bafab51f9bc86b089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa30ff4f80815720bafab51f9bc86b089">guild_set_nickname</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;nickname, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa30ff4f80815720bafab51f9bc86b089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change current user nickname.  <a href="classdpp_1_1cluster.html#aa30ff4f80815720bafab51f9bc86b089">More...</a><br /></td></tr>
<tr class="separator:aa30ff4f80815720bafab51f9bc86b089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dcac8996e5eaad9b1eed9983ecefef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa9dcac8996e5eaad9b1eed9983ecefef">guild_member_add_role</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> role_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa9dcac8996e5eaad9b1eed9983ecefef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add role to guild member.  <a href="classdpp_1_1cluster.html#aa9dcac8996e5eaad9b1eed9983ecefef">More...</a><br /></td></tr>
<tr class="separator:aa9dcac8996e5eaad9b1eed9983ecefef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0289849ef90572a331e68fc84075cb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af0289849ef90572a331e68fc84075cb2">guild_member_delete_role</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> role_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:af0289849ef90572a331e68fc84075cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove role from guild member.  <a href="classdpp_1_1cluster.html#af0289849ef90572a331e68fc84075cb2">More...</a><br /></td></tr>
<tr class="separator:af0289849ef90572a331e68fc84075cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58be46d2934738b32229d984c266a4b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a58be46d2934738b32229d984c266a4b7">guild_member_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a58be46d2934738b32229d984c266a4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove (kick) a guild member.  <a href="classdpp_1_1cluster.html#a58be46d2934738b32229d984c266a4b7">More...</a><br /></td></tr>
<tr class="separator:a58be46d2934738b32229d984c266a4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2273fdee237880d5e6b948198ffae52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad2273fdee237880d5e6b948198ffae52">guild_ban_add</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, uint32_t delete_message_days, const std::string &amp;reason, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad2273fdee237880d5e6b948198ffae52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add guild ban.  <a href="classdpp_1_1cluster.html#ad2273fdee237880d5e6b948198ffae52">More...</a><br /></td></tr>
<tr class="separator:ad2273fdee237880d5e6b948198ffae52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f31527cd6b99cf2757e6c14dac5e5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a18f31527cd6b99cf2757e6c14dac5e5b">guild_ban_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a18f31527cd6b99cf2757e6c14dac5e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete guild ban.  <a href="classdpp_1_1cluster.html#a18f31527cd6b99cf2757e6c14dac5e5b">More...</a><br /></td></tr>
<tr class="separator:a18f31527cd6b99cf2757e6c14dac5e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fffa4f080e0b5abab1417fa8eb1b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af9fffa4f080e0b5abab1417fa8eb1b0f">guild_get_bans</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:af9fffa4f080e0b5abab1417fa8eb1b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild ban list.  <a href="classdpp_1_1cluster.html#af9fffa4f080e0b5abab1417fa8eb1b0f">More...</a><br /></td></tr>
<tr class="separator:af9fffa4f080e0b5abab1417fa8eb1b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad871d30ed11d0799da4a831ede8a7d95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad871d30ed11d0799da4a831ede8a7d95">guild_get_ban</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ad871d30ed11d0799da4a831ede8a7d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get single guild ban.  <a href="classdpp_1_1cluster.html#ad871d30ed11d0799da4a831ede8a7d95">More...</a><br /></td></tr>
<tr class="separator:ad871d30ed11d0799da4a831ede8a7d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52366e37144b166c6a2c773e14992b21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a52366e37144b166c6a2c773e14992b21">template_get</a> (const std::string &amp;code, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a52366e37144b166c6a2c773e14992b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a template.  <a href="classdpp_1_1cluster.html#a52366e37144b166c6a2c773e14992b21">More...</a><br /></td></tr>
<tr class="separator:a52366e37144b166c6a2c773e14992b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad277277c10ccdaecc3869a23d9ecb94b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad277277c10ccdaecc3869a23d9ecb94b">guild_create_from_template</a> (const std::string &amp;code, const std::string &amp;name, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad277277c10ccdaecc3869a23d9ecb94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new guild based on a template.  <a href="classdpp_1_1cluster.html#ad277277c10ccdaecc3869a23d9ecb94b">More...</a><br /></td></tr>
<tr class="separator:ad277277c10ccdaecc3869a23d9ecb94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faa321ede15b209c789ea1155a3d356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1faa321ede15b209c789ea1155a3d356">guild_templates_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a1faa321ede15b209c789ea1155a3d356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild templates.  <a href="classdpp_1_1cluster.html#a1faa321ede15b209c789ea1155a3d356">More...</a><br /></td></tr>
<tr class="separator:a1faa321ede15b209c789ea1155a3d356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38db2ce96431b742e98cabf8170a84d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a38db2ce96431b742e98cabf8170a84d7">guild_template_create</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;name, const std::string &amp;description, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a38db2ce96431b742e98cabf8170a84d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a template for the guild.  <a href="classdpp_1_1cluster.html#a38db2ce96431b742e98cabf8170a84d7">More...</a><br /></td></tr>
<tr class="separator:a38db2ce96431b742e98cabf8170a84d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc2ed8ec7e7550daa418f693ade1016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a3fc2ed8ec7e7550daa418f693ade1016">guild_template_sync</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;code, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a3fc2ed8ec7e7550daa418f693ade1016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syncs the template to the guild's current state.  <a href="classdpp_1_1cluster.html#a3fc2ed8ec7e7550daa418f693ade1016">More...</a><br /></td></tr>
<tr class="separator:a3fc2ed8ec7e7550daa418f693ade1016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f9702b44025f54cf03920d3a3e554b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a22f9702b44025f54cf03920d3a3e554b">guild_template_modify</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;code, const std::string &amp;name, const std::string &amp;description, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a22f9702b44025f54cf03920d3a3e554b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the template's metadata.  <a href="classdpp_1_1cluster.html#a22f9702b44025f54cf03920d3a3e554b">More...</a><br /></td></tr>
<tr class="separator:a22f9702b44025f54cf03920d3a3e554b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91791a9d280c0973834223df37d39ac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a91791a9d280c0973834223df37d39ac8">guild_template_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const std::string &amp;code, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a91791a9d280c0973834223df37d39ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the template.  <a href="classdpp_1_1cluster.html#a91791a9d280c0973834223df37d39ac8">More...</a><br /></td></tr>
<tr class="separator:a91791a9d280c0973834223df37d39ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af327d6e65c703ce001d666ef2adc4b25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af327d6e65c703ce001d666ef2adc4b25">guild_create</a> (const class <a class="el" href="classdpp_1_1guild.html">guild</a> &amp;g, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:af327d6e65c703ce001d666ef2adc4b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a guild.  <a href="classdpp_1_1cluster.html#af327d6e65c703ce001d666ef2adc4b25">More...</a><br /></td></tr>
<tr class="separator:af327d6e65c703ce001d666ef2adc4b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0ce3857773519ca2ed62b49c04f267"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5b0ce3857773519ca2ed62b49c04f267">guild_edit</a> (const class <a class="el" href="classdpp_1_1guild.html">guild</a> &amp;g, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a5b0ce3857773519ca2ed62b49c04f267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a guild.  <a href="classdpp_1_1cluster.html#a5b0ce3857773519ca2ed62b49c04f267">More...</a><br /></td></tr>
<tr class="separator:a5b0ce3857773519ca2ed62b49c04f267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a78935110be8ea8bf5fdc4f0734fd28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8a78935110be8ea8bf5fdc4f0734fd28">guild_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a8a78935110be8ea8bf5fdc4f0734fd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a guild.  <a href="classdpp_1_1cluster.html#a8a78935110be8ea8bf5fdc4f0734fd28">More...</a><br /></td></tr>
<tr class="separator:a8a78935110be8ea8bf5fdc4f0734fd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66ab98a72eb1ba8d2686fcaa1eb49db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad66ab98a72eb1ba8d2686fcaa1eb49db">guild_emojis_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ad66ab98a72eb1ba8d2686fcaa1eb49db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all emojis for a guild.  <a href="classdpp_1_1cluster.html#ad66ab98a72eb1ba8d2686fcaa1eb49db">More...</a><br /></td></tr>
<tr class="separator:ad66ab98a72eb1ba8d2686fcaa1eb49db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada721a222fb3a42a1a1bb6d93dfcc745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ada721a222fb3a42a1a1bb6d93dfcc745">guild_emoji_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> emoji_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ada721a222fb3a42a1a1bb6d93dfcc745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single emoji.  <a href="classdpp_1_1cluster.html#ada721a222fb3a42a1a1bb6d93dfcc745">More...</a><br /></td></tr>
<tr class="separator:ada721a222fb3a42a1a1bb6d93dfcc745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6d9dbdb2009bdea2fad46e93813af5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5f6d9dbdb2009bdea2fad46e93813af5">guild_emoji_create</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const class <a class="el" href="classdpp_1_1emoji.html">emoji</a> &amp;newemoji, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a5f6d9dbdb2009bdea2fad46e93813af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create single emoji. You must ensure that the emoji passed contained image data using the <a class="el" href="classdpp_1_1emoji.html#a33694c119238d58da105c55fdf9dbcd9" title="Load an image into the object as base64.">emoji::load_image()</a> method.  <a href="classdpp_1_1cluster.html#a5f6d9dbdb2009bdea2fad46e93813af5">More...</a><br /></td></tr>
<tr class="separator:a5f6d9dbdb2009bdea2fad46e93813af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4bf8c1767b71ed06bfa407341096d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2c4bf8c1767b71ed06bfa407341096d4">guild_emoji_edit</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const class <a class="el" href="classdpp_1_1emoji.html">emoji</a> &amp;newemoji, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a2c4bf8c1767b71ed06bfa407341096d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a single emoji. You must ensure that the emoji passed contained image data using the <a class="el" href="classdpp_1_1emoji.html#a33694c119238d58da105c55fdf9dbcd9" title="Load an image into the object as base64.">emoji::load_image()</a> method.  <a href="classdpp_1_1cluster.html#a2c4bf8c1767b71ed06bfa407341096d4">More...</a><br /></td></tr>
<tr class="separator:a2c4bf8c1767b71ed06bfa407341096d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c8f4357998bc8a77e8561edcb738c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af9c8f4357998bc8a77e8561edcb738c3">guild_emoji_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> emoji_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:af9c8f4357998bc8a77e8561edcb738c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a guild emoji.  <a href="classdpp_1_1cluster.html#af9c8f4357998bc8a77e8561edcb738c3">More...</a><br /></td></tr>
<tr class="separator:af9c8f4357998bc8a77e8561edcb738c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad296f07bd5b9f900dcedbf88c464e09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aad296f07bd5b9f900dcedbf88c464e09">guild_get_prune_counts</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const struct <a class="el" href="structdpp_1_1prune.html">prune</a> &amp;pruneinfo, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:aad296f07bd5b9f900dcedbf88c464e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get prune counts.  <a href="classdpp_1_1cluster.html#aad296f07bd5b9f900dcedbf88c464e09">More...</a><br /></td></tr>
<tr class="separator:aad296f07bd5b9f900dcedbf88c464e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2102835f11fabbc2cd2e6b41155783f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2102835f11fabbc2cd2e6b41155783f6">guild_begin_prune</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const struct <a class="el" href="structdpp_1_1prune.html">prune</a> &amp;pruneinfo, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a2102835f11fabbc2cd2e6b41155783f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin guild prune.  <a href="classdpp_1_1cluster.html#a2102835f11fabbc2cd2e6b41155783f6">More...</a><br /></td></tr>
<tr class="separator:a2102835f11fabbc2cd2e6b41155783f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5556385a69a408a268332f774ba6c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae5556385a69a408a268332f774ba6c3c">guild_get_voice_regions</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ae5556385a69a408a268332f774ba6c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild voice regions. Voice regions per guild are somewhat deprecated in preference of per-channel voice regions.  <a href="classdpp_1_1cluster.html#ae5556385a69a408a268332f774ba6c3c">More...</a><br /></td></tr>
<tr class="separator:ae5556385a69a408a268332f774ba6c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c0e07243611419141305da123c859a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a93c0e07243611419141305da123c859a">guild_get_invites</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a93c0e07243611419141305da123c859a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild invites.  <a href="classdpp_1_1cluster.html#a93c0e07243611419141305da123c859a">More...</a><br /></td></tr>
<tr class="separator:a93c0e07243611419141305da123c859a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cba3bd187f9b28dcaed5b4f4ed5bda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a43cba3bd187f9b28dcaed5b4f4ed5bda">guild_get_integrations</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a43cba3bd187f9b28dcaed5b4f4ed5bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild itegrations.  <a href="classdpp_1_1cluster.html#a43cba3bd187f9b28dcaed5b4f4ed5bda">More...</a><br /></td></tr>
<tr class="separator:a43cba3bd187f9b28dcaed5b4f4ed5bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb07fc90589ee936f73da5551cff1255"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#afb07fc90589ee936f73da5551cff1255">guild_modify_integration</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const class <a class="el" href="classdpp_1_1integration.html">integration</a> &amp;i, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:afb07fc90589ee936f73da5551cff1255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify guild integration.  <a href="classdpp_1_1cluster.html#afb07fc90589ee936f73da5551cff1255">More...</a><br /></td></tr>
<tr class="separator:afb07fc90589ee936f73da5551cff1255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db4a48d1ebc2133c30963a995e156e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0db4a48d1ebc2133c30963a995e156e1">guild_delete_integration</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> integration_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a0db4a48d1ebc2133c30963a995e156e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete guild integration.  <a href="classdpp_1_1cluster.html#a0db4a48d1ebc2133c30963a995e156e1">More...</a><br /></td></tr>
<tr class="separator:a0db4a48d1ebc2133c30963a995e156e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d976f9d101225e05482db7b739f986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a58d976f9d101225e05482db7b739f986">guild_sync_integration</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> integration_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a58d976f9d101225e05482db7b739f986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync guild integration.  <a href="classdpp_1_1cluster.html#a58d976f9d101225e05482db7b739f986">More...</a><br /></td></tr>
<tr class="separator:a58d976f9d101225e05482db7b739f986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57626c7a0e06aee1c362b986e44030c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a57626c7a0e06aee1c362b986e44030c2">guild_get_widget</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a57626c7a0e06aee1c362b986e44030c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild widget.  <a href="classdpp_1_1cluster.html#a57626c7a0e06aee1c362b986e44030c2">More...</a><br /></td></tr>
<tr class="separator:a57626c7a0e06aee1c362b986e44030c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb37eaa792a69f43171f580695fd4520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#afb37eaa792a69f43171f580695fd4520">guild_edit_widget</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, const class <a class="el" href="classdpp_1_1guild__widget.html">guild_widget</a> &amp;gw, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:afb37eaa792a69f43171f580695fd4520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit guild widget.  <a href="classdpp_1_1cluster.html#afb37eaa792a69f43171f580695fd4520">More...</a><br /></td></tr>
<tr class="separator:afb37eaa792a69f43171f580695fd4520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1332e45cc89e871009e840c25145df5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad1332e45cc89e871009e840c25145df5">guild_get_vanity</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ad1332e45cc89e871009e840c25145df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild vanity url, if enabled.  <a href="classdpp_1_1cluster.html#ad1332e45cc89e871009e840c25145df5">More...</a><br /></td></tr>
<tr class="separator:ad1332e45cc89e871009e840c25145df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627510bf4f4d1c3a999ccb506c75ec47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a627510bf4f4d1c3a999ccb506c75ec47">create_webhook</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;w, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a627510bf4f4d1c3a999ccb506c75ec47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a webhook.  <a href="classdpp_1_1cluster.html#a627510bf4f4d1c3a999ccb506c75ec47">More...</a><br /></td></tr>
<tr class="separator:a627510bf4f4d1c3a999ccb506c75ec47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d352afcbc0430ca11576386278da7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8d352afcbc0430ca11576386278da7d0">get_guild_webhooks</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a8d352afcbc0430ca11576386278da7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get guild webhooks.  <a href="classdpp_1_1cluster.html#a8d352afcbc0430ca11576386278da7d0">More...</a><br /></td></tr>
<tr class="separator:a8d352afcbc0430ca11576386278da7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58b1f27711b42e9aa8a21e34147429f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae58b1f27711b42e9aa8a21e34147429f">get_channel_webhooks</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ae58b1f27711b42e9aa8a21e34147429f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get channel webhooks.  <a href="classdpp_1_1cluster.html#ae58b1f27711b42e9aa8a21e34147429f">More...</a><br /></td></tr>
<tr class="separator:ae58b1f27711b42e9aa8a21e34147429f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e140f1e2eda9632828bce461bc7338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a40e140f1e2eda9632828bce461bc7338">get_webhook</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> webhook_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a40e140f1e2eda9632828bce461bc7338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get webhook.  <a href="classdpp_1_1cluster.html#a40e140f1e2eda9632828bce461bc7338">More...</a><br /></td></tr>
<tr class="separator:a40e140f1e2eda9632828bce461bc7338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770526895ed13e2dfb746decc3f0be67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a770526895ed13e2dfb746decc3f0be67">get_webhook_with_token</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> webhook_id, const std::string &amp;<a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a770526895ed13e2dfb746decc3f0be67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get webhook using token.  <a href="classdpp_1_1cluster.html#a770526895ed13e2dfb746decc3f0be67">More...</a><br /></td></tr>
<tr class="separator:a770526895ed13e2dfb746decc3f0be67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af319c151f1b9b2b578d9303bab7ce5d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af319c151f1b9b2b578d9303bab7ce5d0">edit_webhook</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:af319c151f1b9b2b578d9303bab7ce5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit webhook.  <a href="classdpp_1_1cluster.html#af319c151f1b9b2b578d9303bab7ce5d0">More...</a><br /></td></tr>
<tr class="separator:af319c151f1b9b2b578d9303bab7ce5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bffc1fa43d6a78814f9ca0f378755c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2bffc1fa43d6a78814f9ca0f378755c5">edit_webhook_with_token</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a2bffc1fa43d6a78814f9ca0f378755c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit webhook with token (token is encapsulated in the webhook object)  <a href="classdpp_1_1cluster.html#a2bffc1fa43d6a78814f9ca0f378755c5">More...</a><br /></td></tr>
<tr class="separator:a2bffc1fa43d6a78814f9ca0f378755c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee76e0048ec1cd35420da1bfc5317646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aee76e0048ec1cd35420da1bfc5317646">delete_webhook</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> webhook_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aee76e0048ec1cd35420da1bfc5317646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a webhook.  <a href="classdpp_1_1cluster.html#aee76e0048ec1cd35420da1bfc5317646">More...</a><br /></td></tr>
<tr class="separator:aee76e0048ec1cd35420da1bfc5317646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae790b70aaecd9c42fe8a64c4c71a3d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae790b70aaecd9c42fe8a64c4c71a3d0c">delete_webhook_with_token</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> webhook_id, const std::string &amp;<a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ae790b70aaecd9c42fe8a64c4c71a3d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete webhook with token.  <a href="classdpp_1_1cluster.html#ae790b70aaecd9c42fe8a64c4c71a3d0c">More...</a><br /></td></tr>
<tr class="separator:ae790b70aaecd9c42fe8a64c4c71a3d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e83314cede8b9277a01b7b173abbad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad5e83314cede8b9277a01b7b173abbad">execute_webhook</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, bool wait=false, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id=0, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad5e83314cede8b9277a01b7b173abbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute webhook.  <a href="classdpp_1_1cluster.html#ad5e83314cede8b9277a01b7b173abbad">More...</a><br /></td></tr>
<tr class="separator:ad5e83314cede8b9277a01b7b173abbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8685b3bd821ab87342670d730689191e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8685b3bd821ab87342670d730689191e">get_webhook_message</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a8685b3bd821ab87342670d730689191e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get webhook message.  <a href="classdpp_1_1cluster.html#a8685b3bd821ab87342670d730689191e">More...</a><br /></td></tr>
<tr class="separator:a8685b3bd821ab87342670d730689191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a37684f9d12edd4ca7d00296a5443b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a86a37684f9d12edd4ca7d00296a5443b">edit_webhook_message</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;m, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a86a37684f9d12edd4ca7d00296a5443b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit webhook message.  <a href="classdpp_1_1cluster.html#a86a37684f9d12edd4ca7d00296a5443b">More...</a><br /></td></tr>
<tr class="separator:a86a37684f9d12edd4ca7d00296a5443b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e937f48e410469c90f37368afa4cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae6e937f48e410469c90f37368afa4cbe">delete_webhook_message</a> (const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;wh, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ae6e937f48e410469c90f37368afa4cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete webhook message.  <a href="classdpp_1_1cluster.html#ae6e937f48e410469c90f37368afa4cbe">More...</a><br /></td></tr>
<tr class="separator:ae6e937f48e410469c90f37368afa4cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884dbb70619fcf92b06577dea8093219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a884dbb70619fcf92b06577dea8093219">roles_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a884dbb70619fcf92b06577dea8093219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a role for a guild.  <a href="classdpp_1_1cluster.html#a884dbb70619fcf92b06577dea8093219">More...</a><br /></td></tr>
<tr class="separator:a884dbb70619fcf92b06577dea8093219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab912eb28e9bb4df46954c7a9b93b283d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab912eb28e9bb4df46954c7a9b93b283d">role_create</a> (const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;r, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ab912eb28e9bb4df46954c7a9b93b283d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a role on a guild.  <a href="classdpp_1_1cluster.html#ab912eb28e9bb4df46954c7a9b93b283d">More...</a><br /></td></tr>
<tr class="separator:ab912eb28e9bb4df46954c7a9b93b283d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cc5286955e6641d574d232d8b47f55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a24cc5286955e6641d574d232d8b47f55">role_edit</a> (const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;r, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a24cc5286955e6641d574d232d8b47f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a role on a guild.  <a href="classdpp_1_1cluster.html#a24cc5286955e6641d574d232d8b47f55">More...</a><br /></td></tr>
<tr class="separator:a24cc5286955e6641d574d232d8b47f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77932ee797aeb44098c2013811b2887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac77932ee797aeb44098c2013811b2887">role_edit_position</a> (const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;r, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ac77932ee797aeb44098c2013811b2887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a role's position in a guild.  <a href="classdpp_1_1cluster.html#ac77932ee797aeb44098c2013811b2887">More...</a><br /></td></tr>
<tr class="separator:ac77932ee797aeb44098c2013811b2887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45414d0d189edd147c3d76b4480ec0b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a45414d0d189edd147c3d76b4480ec0b8">role_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> role_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a45414d0d189edd147c3d76b4480ec0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a role.  <a href="classdpp_1_1cluster.html#a45414d0d189edd147c3d76b4480ec0b8">More...</a><br /></td></tr>
<tr class="separator:a45414d0d189edd147c3d76b4480ec0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73483dbeb0f1946dc18b1d0a5331b0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a73483dbeb0f1946dc18b1d0a5331b0d0">user_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a73483dbeb0f1946dc18b1d0a5331b0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a user by id.  <a href="classdpp_1_1cluster.html#a73483dbeb0f1946dc18b1d0a5331b0d0">More...</a><br /></td></tr>
<tr class="separator:a73483dbeb0f1946dc18b1d0a5331b0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad927e85ed6b99e9b05f4190f1b19cae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aad927e85ed6b99e9b05f4190f1b19cae">current_user_get</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:aad927e85ed6b99e9b05f4190f1b19cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current (bot) user.  <a href="classdpp_1_1cluster.html#aad927e85ed6b99e9b05f4190f1b19cae">More...</a><br /></td></tr>
<tr class="separator:aad927e85ed6b99e9b05f4190f1b19cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc39069aaaa492727f39b35edd957e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac3dc39069aaaa492727f39b35edd957e">current_application_get</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ac3dc39069aaaa492727f39b35edd957e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current (bot) application.  <a href="classdpp_1_1cluster.html#ac3dc39069aaaa492727f39b35edd957e">More...</a><br /></td></tr>
<tr class="separator:ac3dc39069aaaa492727f39b35edd957e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e1e5dd813d36fffd6b532ed1b31178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a75e1e5dd813d36fffd6b532ed1b31178">current_user_connections_get</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a75e1e5dd813d36fffd6b532ed1b31178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current user's connections (linked accounts, e.g. steam, xbox). This call requires the oauth2 <code>connections</code> scope and cannot be executed against a bot token.  <a href="classdpp_1_1cluster.html#a75e1e5dd813d36fffd6b532ed1b31178">More...</a><br /></td></tr>
<tr class="separator:a75e1e5dd813d36fffd6b532ed1b31178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c8fd5f22e0eae6bf357ad498b43f87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a93c8fd5f22e0eae6bf357ad498b43f87">current_user_get_guilds</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a93c8fd5f22e0eae6bf357ad498b43f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current (bot) user guilds.  <a href="classdpp_1_1cluster.html#a93c8fd5f22e0eae6bf357ad498b43f87">More...</a><br /></td></tr>
<tr class="separator:a93c8fd5f22e0eae6bf357ad498b43f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4db23ebdf9a8323bd54458dadecaed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0a4db23ebdf9a8323bd54458dadecaed">current_user_edit</a> (const std::string &amp;nickname, const std::string &amp;image_blob=&quot;&quot;, const <a class="el" href="namespacedpp.html#a7d622bf5ff000e82a44af1a8ac794e83">image_type</a> type=<a class="el" href="namespacedpp.html#a7d622bf5ff000e82a44af1a8ac794e83ace2c4de1f89397132561031f246f89f7">i_png</a>, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a0a4db23ebdf9a8323bd54458dadecaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit current (bot) user.  <a href="classdpp_1_1cluster.html#a0a4db23ebdf9a8323bd54458dadecaed">More...</a><br /></td></tr>
<tr class="separator:a0a4db23ebdf9a8323bd54458dadecaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662fc0a998c62395f166da5e4a2acaf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a662fc0a998c62395f166da5e4a2acaf3">current_user_get_dms</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a662fc0a998c62395f166da5e4a2acaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current user DM channels.  <a href="classdpp_1_1cluster.html#a662fc0a998c62395f166da5e4a2acaf3">More...</a><br /></td></tr>
<tr class="separator:a662fc0a998c62395f166da5e4a2acaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c6a9bb92a500aefc65a953e419c27f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a55c6a9bb92a500aefc65a953e419c27f">create_dm_channel</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a55c6a9bb92a500aefc65a953e419c27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dm channel.  <a href="classdpp_1_1cluster.html#a55c6a9bb92a500aefc65a953e419c27f">More...</a><br /></td></tr>
<tr class="separator:a55c6a9bb92a500aefc65a953e419c27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20f6c8ef35465a17c9510fa8353ef3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa20f6c8ef35465a17c9510fa8353ef3a">current_user_leave_guild</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aa20f6c8ef35465a17c9510fa8353ef3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a guild.  <a href="classdpp_1_1cluster.html#aa20f6c8ef35465a17c9510fa8353ef3a">More...</a><br /></td></tr>
<tr class="separator:aa20f6c8ef35465a17c9510fa8353ef3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fc5594e7d2dabcc03e9ef031a361db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a62fc5594e7d2dabcc03e9ef031a361db">thread_create</a> (const std::string &amp;thread_name, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, uint16_t auto_archive_duration, <a class="el" href="namespacedpp.html#a8af3a726df107c304139477dbfa42092">channel_type</a> thread_type, bool invitable, uint16_t rate_limit_per_user, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a62fc5594e7d2dabcc03e9ef031a361db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread.  <a href="classdpp_1_1cluster.html#a62fc5594e7d2dabcc03e9ef031a361db">More...</a><br /></td></tr>
<tr class="separator:a62fc5594e7d2dabcc03e9ef031a361db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc314e4918852cc217b473ff9d95ddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aacc314e4918852cc217b473ff9d95ddc">thread_create_with_message</a> (const std::string &amp;thread_name, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> message_id, uint16_t auto_archive_duration, uint16_t rate_limit_per_user, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:aacc314e4918852cc217b473ff9d95ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread with a message (Discord: ID of a thread is same as message ID)  <a href="classdpp_1_1cluster.html#aacc314e4918852cc217b473ff9d95ddc">More...</a><br /></td></tr>
<tr class="separator:aacc314e4918852cc217b473ff9d95ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485553dc602bb2a7ed3ca11057034221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a485553dc602bb2a7ed3ca11057034221">current_user_join_thread</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a485553dc602bb2a7ed3ca11057034221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a thread.  <a href="classdpp_1_1cluster.html#a485553dc602bb2a7ed3ca11057034221">More...</a><br /></td></tr>
<tr class="separator:a485553dc602bb2a7ed3ca11057034221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a819f21159771de3142d57eabfe306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a13a819f21159771de3142d57eabfe306">current_user_leave_thread</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a13a819f21159771de3142d57eabfe306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a thread.  <a href="classdpp_1_1cluster.html#a13a819f21159771de3142d57eabfe306">More...</a><br /></td></tr>
<tr class="separator:a13a819f21159771de3142d57eabfe306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066a4a71deac82b823757c2c80479a5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a066a4a71deac82b823757c2c80479a5d">thread_member_add</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a066a4a71deac82b823757c2c80479a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a member to a thread.  <a href="classdpp_1_1cluster.html#a066a4a71deac82b823757c2c80479a5d">More...</a><br /></td></tr>
<tr class="separator:a066a4a71deac82b823757c2c80479a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad253c2a68c5a1e78b880da7252a15814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad253c2a68c5a1e78b880da7252a15814">thread_member_remove</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:ad253c2a68c5a1e78b880da7252a15814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a member from a thread.  <a href="classdpp_1_1cluster.html#ad253c2a68c5a1e78b880da7252a15814">More...</a><br /></td></tr>
<tr class="separator:ad253c2a68c5a1e78b880da7252a15814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39edec2f1389d1aa5bb6c09e4318b6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad39edec2f1389d1aa5bb6c09e4318b6a">thread_member_get</a> (const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> user_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ad39edec2f1389d1aa5bb6c09e4318b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread member.  <a href="classdpp_1_1cluster.html#ad39edec2f1389d1aa5bb6c09e4318b6a">More...</a><br /></td></tr>
<tr class="separator:ad39edec2f1389d1aa5bb6c09e4318b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636b55f518a2e724eabf31453aa89abe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a636b55f518a2e724eabf31453aa89abe">thread_members_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> thread_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a636b55f518a2e724eabf31453aa89abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get members of a thread.  <a href="classdpp_1_1cluster.html#a636b55f518a2e724eabf31453aa89abe">More...</a><br /></td></tr>
<tr class="separator:a636b55f518a2e724eabf31453aa89abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6825c29651e995f251e01f5a1f20122d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6825c29651e995f251e01f5a1f20122d">threads_get_active</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a6825c29651e995f251e01f5a1f20122d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get active threads in a channel (Sorted by ID in descending order)  <a href="classdpp_1_1cluster.html#a6825c29651e995f251e01f5a1f20122d">More...</a><br /></td></tr>
<tr class="separator:a6825c29651e995f251e01f5a1f20122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b93e8be30c7e954c27e19d8b7fa8170"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2b93e8be30c7e954c27e19d8b7fa8170">threads_get_public_archived</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, time_t before_timestamp, uint16_t limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a2b93e8be30c7e954c27e19d8b7fa8170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get public archived threads in a channel (Sorted by archive_timestamp in descending order)  <a href="classdpp_1_1cluster.html#a2b93e8be30c7e954c27e19d8b7fa8170">More...</a><br /></td></tr>
<tr class="separator:a2b93e8be30c7e954c27e19d8b7fa8170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8336e48eaabaeb8df4d69a087982e82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae8336e48eaabaeb8df4d69a087982e82">threads_get_private_archived</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, time_t before_timestamp, uint16_t limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ae8336e48eaabaeb8df4d69a087982e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get private archived threads in a channel (Sorted by archive_timestamp in descending order)  <a href="classdpp_1_1cluster.html#ae8336e48eaabaeb8df4d69a087982e82">More...</a><br /></td></tr>
<tr class="separator:ae8336e48eaabaeb8df4d69a087982e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0c3894cd560fa7871f22d7cfb8f591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0d0c3894cd560fa7871f22d7cfb8f591">threads_get_joined_private_archived</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> before_id, uint16_t limit, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a0d0c3894cd560fa7871f22d7cfb8f591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get private archived threads in a channel which current user has joined (Sorted by ID in descending order)  <a href="classdpp_1_1cluster.html#a0d0c3894cd560fa7871f22d7cfb8f591">More...</a><br /></td></tr>
<tr class="separator:a0d0c3894cd560fa7871f22d7cfb8f591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f31d36f327a74d24fb4075cec6c2400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7f31d36f327a74d24fb4075cec6c2400">guild_sticker_create</a> (<a class="el" href="structdpp_1_1sticker.html">sticker</a> &amp;s, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a7f31d36f327a74d24fb4075cec6c2400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sticker in a guild.  <a href="classdpp_1_1cluster.html#a7f31d36f327a74d24fb4075cec6c2400">More...</a><br /></td></tr>
<tr class="separator:a7f31d36f327a74d24fb4075cec6c2400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222a8cb4498fd65ae8bb3345b02d0f8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a222a8cb4498fd65ae8bb3345b02d0f8e">guild_sticker_modify</a> (<a class="el" href="structdpp_1_1sticker.html">sticker</a> &amp;s, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a222a8cb4498fd65ae8bb3345b02d0f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a sticker in a guild.  <a href="classdpp_1_1cluster.html#a222a8cb4498fd65ae8bb3345b02d0f8e">More...</a><br /></td></tr>
<tr class="separator:a222a8cb4498fd65ae8bb3345b02d0f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ed56cd299340bdf286bc3457225124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a08ed56cd299340bdf286bc3457225124">guild_sticker_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> sticker_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a08ed56cd299340bdf286bc3457225124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a sticker from a guild.  <a href="classdpp_1_1cluster.html#a08ed56cd299340bdf286bc3457225124">More...</a><br /></td></tr>
<tr class="separator:a08ed56cd299340bdf286bc3457225124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115a49075ceb1817f1e81fc9388bf65e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a115a49075ceb1817f1e81fc9388bf65e">nitro_sticker_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a115a49075ceb1817f1e81fc9388bf65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a nitro sticker.  <a href="classdpp_1_1cluster.html#a115a49075ceb1817f1e81fc9388bf65e">More...</a><br /></td></tr>
<tr class="separator:a115a49075ceb1817f1e81fc9388bf65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a2d335385b4689e7489d0eaf4475fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac7a2d335385b4689e7489d0eaf4475fe">guild_sticker_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ac7a2d335385b4689e7489d0eaf4475fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a guild sticker.  <a href="classdpp_1_1cluster.html#ac7a2d335385b4689e7489d0eaf4475fe">More...</a><br /></td></tr>
<tr class="separator:ac7a2d335385b4689e7489d0eaf4475fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccd1468d3f031c5bc786fdbd087d0a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#adccd1468d3f031c5bc786fdbd087d0a2">guild_stickers_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:adccd1468d3f031c5bc786fdbd087d0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all guild stickers.  <a href="classdpp_1_1cluster.html#adccd1468d3f031c5bc786fdbd087d0a2">More...</a><br /></td></tr>
<tr class="separator:adccd1468d3f031c5bc786fdbd087d0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64421a4b2402238feb0536639009c18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae64421a4b2402238feb0536639009c18">sticker_packs_get</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ae64421a4b2402238feb0536639009c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get sticker packs.  <a href="classdpp_1_1cluster.html#ae64421a4b2402238feb0536639009c18">More...</a><br /></td></tr>
<tr class="separator:ae64421a4b2402238feb0536639009c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe69055dc2ee16d08e693df11fec75a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5fe69055dc2ee16d08e693df11fec75a">stage_instance_create</a> (const <a class="el" href="structdpp_1_1stage__instance.html">stage_instance</a> &amp;instance, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a5fe69055dc2ee16d08e693df11fec75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stage instance on a stage channel.  <a href="classdpp_1_1cluster.html#a5fe69055dc2ee16d08e693df11fec75a">More...</a><br /></td></tr>
<tr class="separator:a5fe69055dc2ee16d08e693df11fec75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edd6ac5d8553b4823465bebadfaa9af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a1edd6ac5d8553b4823465bebadfaa9af">stage_instance_get</a> (const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a1edd6ac5d8553b4823465bebadfaa9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stage instance associated with the channel id, if it exists.  <a href="classdpp_1_1cluster.html#a1edd6ac5d8553b4823465bebadfaa9af">More...</a><br /></td></tr>
<tr class="separator:a1edd6ac5d8553b4823465bebadfaa9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e1b1edb3094c7d220a3a80323bbe17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af4e1b1edb3094c7d220a3a80323bbe17">stage_instance_edit</a> (const <a class="el" href="structdpp_1_1stage__instance.html">stage_instance</a> &amp;instance, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:af4e1b1edb3094c7d220a3a80323bbe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit a stage instance.  <a href="classdpp_1_1cluster.html#af4e1b1edb3094c7d220a3a80323bbe17">More...</a><br /></td></tr>
<tr class="separator:af4e1b1edb3094c7d220a3a80323bbe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8c2ba02d51ad166f90300ab5b53ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9f8c2ba02d51ad166f90300ab5b53ecb">stage_instance_delete</a> (const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> channel_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a9f8c2ba02d51ad166f90300ab5b53ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a stage instance.  <a href="classdpp_1_1cluster.html#a9f8c2ba02d51ad166f90300ab5b53ecb">More...</a><br /></td></tr>
<tr class="separator:a9f8c2ba02d51ad166f90300ab5b53ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d45a29b3976f7b623d92e70ab9a1bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af6d45a29b3976f7b623d92e70ab9a1bc">get_voice_regions</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:af6d45a29b3976f7b623d92e70ab9a1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all voice regions.  <a href="classdpp_1_1cluster.html#af6d45a29b3976f7b623d92e70ab9a1bc">More...</a><br /></td></tr>
<tr class="separator:af6d45a29b3976f7b623d92e70ab9a1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f16d04f100a0159683cba96e8c0a6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a68f16d04f100a0159683cba96e8c0a6c">get_gateway_bot</a> (<a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a68f16d04f100a0159683cba96e8c0a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gateway information for the bot using the token.  <a href="classdpp_1_1cluster.html#a68f16d04f100a0159683cba96e8c0a6c">More...</a><br /></td></tr>
<tr class="separator:a68f16d04f100a0159683cba96e8c0a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8554f93aed5fb84162af41c997fc1e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae8554f93aed5fb84162af41c997fc1e3">guild_events_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:ae8554f93aed5fb84162af41c997fc1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all scheduled events for a guild.  <a href="classdpp_1_1cluster.html#ae8554f93aed5fb84162af41c997fc1e3">More...</a><br /></td></tr>
<tr class="separator:ae8554f93aed5fb84162af41c997fc1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f6a78b9b2ad6218ed1b8c7b044013a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a09f6a78b9b2ad6218ed1b8c7b044013a">guild_event_users_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> event_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback, uint8_t limit=100, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> before=0, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> after=0)</td></tr>
<tr class="memdesc:a09f6a78b9b2ad6218ed1b8c7b044013a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get users RSVP'd to an event.  <a href="classdpp_1_1cluster.html#a09f6a78b9b2ad6218ed1b8c7b044013a">More...</a><br /></td></tr>
<tr class="separator:a09f6a78b9b2ad6218ed1b8c7b044013a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dc202cee249447c1a135a80a852daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a04dc202cee249447c1a135a80a852daf">guild_event_create</a> (const <a class="el" href="structdpp_1_1scheduled__event.html">scheduled_event</a> &amp;event, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a04dc202cee249447c1a135a80a852daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scheduled event on a guild.  <a href="classdpp_1_1cluster.html#a04dc202cee249447c1a135a80a852daf">More...</a><br /></td></tr>
<tr class="separator:a04dc202cee249447c1a135a80a852daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bec34914c433a1105697dd5c24c7f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a17bec34914c433a1105697dd5c24c7f2">guild_event_delete</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> event_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a17bec34914c433a1105697dd5c24c7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a scheduled event from a guild.  <a href="classdpp_1_1cluster.html#a17bec34914c433a1105697dd5c24c7f2">More...</a><br /></td></tr>
<tr class="separator:a17bec34914c433a1105697dd5c24c7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b82a96ca6b744388e9b290cbf775ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a36b82a96ca6b744388e9b290cbf775ff">guild_event_edit</a> (const <a class="el" href="structdpp_1_1scheduled__event.html">scheduled_event</a> &amp;event, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback={})</td></tr>
<tr class="memdesc:a36b82a96ca6b744388e9b290cbf775ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit/modify a scheduled event on a guild.  <a href="classdpp_1_1cluster.html#a36b82a96ca6b744388e9b290cbf775ff">More...</a><br /></td></tr>
<tr class="separator:a36b82a96ca6b744388e9b290cbf775ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8c168682519ee125ed0a48239c08ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5b8c168682519ee125ed0a48239c08ef">guild_event_get</a> (<a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> guild_id, <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> event_id, <a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a> callback)</td></tr>
<tr class="memdesc:a5b8c168682519ee125ed0a48239c08ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a scheduled event for a guild.  <a href="classdpp_1_1cluster.html#a5b8c168682519ee125ed0a48239c08ef">More...</a><br /></td></tr>
<tr class="separator:a5b8c168682519ee125ed0a48239c08ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a644b186bc4b386a8313e3c5dce456c4e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a644b186bc4b386a8313e3c5dce456c4e">token</a></td></tr>
<tr class="separator:a644b186bc4b386a8313e3c5dce456c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ce7fc13658a25e2faeadcd36282b0b"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a32ce7fc13658a25e2faeadcd36282b0b">last_identify</a></td></tr>
<tr class="separator:a32ce7fc13658a25e2faeadcd36282b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239af1e13449c85658fb37e6589745a0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a239af1e13449c85658fb37e6589745a0">intents</a></td></tr>
<tr class="separator:a239af1e13449c85658fb37e6589745a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7418aa521c49af80822039b013d8d004"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7418aa521c49af80822039b013d8d004">numshards</a></td></tr>
<tr class="separator:a7418aa521c49af80822039b013d8d004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5155862c1d7267c7f4ee8781ff3e8d7f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5155862c1d7267c7f4ee8781ff3e8d7f">cluster_id</a></td></tr>
<tr class="separator:a5155862c1d7267c7f4ee8781ff3e8d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80e4df300e69988d163d61c14e540ab"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad80e4df300e69988d163d61c14e540ab">maxclusters</a></td></tr>
<tr class="separator:ad80e4df300e69988d163d61c14e540ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6161f8d412b2e81a06594f727684a260"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6161f8d412b2e81a06594f727684a260">rest_ping</a></td></tr>
<tr class="separator:a6161f8d412b2e81a06594f727684a260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31317a40181f6864646c8758871b495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1user.html">dpp::user</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad31317a40181f6864646c8758871b495">me</a></td></tr>
<tr class="memdesc:ad31317a40181f6864646c8758871b495"><td class="mdescLeft">&#160;</td><td class="mdescRight">The details of the bot user. This is assumed to be identical across all shards in the cluster. Each connecting shard updates this information.  <a href="classdpp_1_1cluster.html#ad31317a40181f6864646c8758871b495">More...</a><br /></td></tr>
<tr class="separator:ad31317a40181f6864646c8758871b495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae28f81712be86530fe3314d166ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdpp_1_1cache__policy__t.html">cache_policy_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a9fae28f81712be86530fe3314d166ad3">cache_policy</a></td></tr>
<tr class="memdesc:a9fae28f81712be86530fe3314d166ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current cache policy for the cluster.  <a href="classdpp_1_1cluster.html#a9fae28f81712be86530fe3314d166ad3">More...</a><br /></td></tr>
<tr class="separator:a9fae28f81712be86530fe3314d166ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10466db79966215a799fc2a30010551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedpp.html#af7cde3079d745428f44ef6231a2ac672">websocket_protocol_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae10466db79966215a799fc2a30010551">ws_mode</a></td></tr>
<tr class="memdesc:ae10466db79966215a799fc2a30010551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Websocket mode for all shards in the cluster, either ws_json or ws_etf. Production bots should use ETF, while development bots should use JSON.  <a href="classdpp_1_1cluster.html#ae10466db79966215a799fc2a30010551">More...</a><br /></td></tr>
<tr class="separator:ae10466db79966215a799fc2a30010551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f83901e4107e8b4e806fdbd7ed1251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1voice__state__update__t.html">voice_state_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad0f83901e4107e8b4e806fdbd7ed1251">on_voice_state_update</a></td></tr>
<tr class="memdesc:ad0f83901e4107e8b4e806fdbd7ed1251"><td class="mdescLeft">&#160;</td><td class="mdescRight">on voice state update event  <a href="classdpp_1_1cluster.html#ad0f83901e4107e8b4e806fdbd7ed1251">More...</a><br /></td></tr>
<tr class="separator:ad0f83901e4107e8b4e806fdbd7ed1251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4005f102e1ff9413feee1ba6876832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1voice__client__disconnect__t.html">voice_client_disconnect_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aef4005f102e1ff9413feee1ba6876832">on_voice_client_disconnect</a></td></tr>
<tr class="memdesc:aef4005f102e1ff9413feee1ba6876832"><td class="mdescLeft">&#160;</td><td class="mdescRight">on voice client disconnect event  <a href="classdpp_1_1cluster.html#aef4005f102e1ff9413feee1ba6876832">More...</a><br /></td></tr>
<tr class="separator:aef4005f102e1ff9413feee1ba6876832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af298505ed4ad0c50a61bff08d81851af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1voice__client__speaking__t.html">voice_client_speaking_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af298505ed4ad0c50a61bff08d81851af">on_voice_client_speaking</a></td></tr>
<tr class="memdesc:af298505ed4ad0c50a61bff08d81851af"><td class="mdescLeft">&#160;</td><td class="mdescRight">on voice client speaking event  <a href="classdpp_1_1cluster.html#af298505ed4ad0c50a61bff08d81851af">More...</a><br /></td></tr>
<tr class="separator:af298505ed4ad0c50a61bff08d81851af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b68d30779754eaf7f9b74ecc156a372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1log__t.html">log_t</a> &amp;event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8b68d30779754eaf7f9b74ecc156a372">on_log</a></td></tr>
<tr class="memdesc:a8b68d30779754eaf7f9b74ecc156a372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a log message is to be written to the log. You can attach any logging system here you wish, e.g. spdlog, or even just a simple use of std::cout or printf. If nothing attaches this log event, then the library will be silent.  <a href="classdpp_1_1cluster.html#a8b68d30779754eaf7f9b74ecc156a372">More...</a><br /></td></tr>
<tr class="separator:a8b68d30779754eaf7f9b74ecc156a372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9a12c6bd98bdce99024a9608aa84af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__join__request__delete__t.html">guild_join_request_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8a9a12c6bd98bdce99024a9608aa84af">on_guild_join_request_delete</a></td></tr>
<tr class="memdesc:a8a9a12c6bd98bdce99024a9608aa84af"><td class="mdescLeft">&#160;</td><td class="mdescRight">on guild join request delete. Triggered when a user declines the membership screening questionnaire for a guild.  <a href="classdpp_1_1cluster.html#a8a9a12c6bd98bdce99024a9608aa84af">More...</a><br /></td></tr>
<tr class="separator:a8a9a12c6bd98bdce99024a9608aa84af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aa1d8bcc90afe7aa265940763f5a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1interaction__create__t.html">interaction_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a23aa1d8bcc90afe7aa265940763f5a65">on_interaction_create</a></td></tr>
<tr class="memdesc:a23aa1d8bcc90afe7aa265940763f5a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new interaction is created. Interactions are created by discord when commands you have registered are issued by a user. For an example of this in action please see <a class="el" href="slashcommands.html">Using Slash Commands and Interactions</a>.  <a href="classdpp_1_1cluster.html#a23aa1d8bcc90afe7aa265940763f5a65">More...</a><br /></td></tr>
<tr class="separator:a23aa1d8bcc90afe7aa265940763f5a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa178115555d4db7353f0ee05b3d62902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1button__click__t.html">button_click_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa178115555d4db7353f0ee05b3d62902">on_button_click</a></td></tr>
<tr class="memdesc:aa178115555d4db7353f0ee05b3d62902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a button is clicked attached to a message. Button clicks are triggered by discord when buttons are clicked which you have associated with a message using <a class="el" href="classdpp_1_1component.html" title="Represents the component object. A component is a clickable button or drop down list within a discord...">dpp::component</a>.  <a href="classdpp_1_1cluster.html#aa178115555d4db7353f0ee05b3d62902">More...</a><br /></td></tr>
<tr class="separator:aa178115555d4db7353f0ee05b3d62902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934bbe75a3c0806262189be1a9038845"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1autocomplete__t.html">autocomplete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a934bbe75a3c0806262189be1a9038845">on_autocomplete</a></td></tr>
<tr class="memdesc:a934bbe75a3c0806262189be1a9038845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an auto completed field needs suggestions to present to the user This is triggered by discord when option choices have auto completion enabled which you have associated with a <a class="el" href="classdpp_1_1slashcommand.html" title="Represents an application command, created by your bot either globally, or on a guild.">dpp::slashcommand</a>.  <a href="classdpp_1_1cluster.html#a934bbe75a3c0806262189be1a9038845">More...</a><br /></td></tr>
<tr class="separator:a934bbe75a3c0806262189be1a9038845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6ea43ae09004d54e7fb91219abb116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1select__click__t.html">select_click_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8a6ea43ae09004d54e7fb91219abb116">on_select_click</a></td></tr>
<tr class="memdesc:a8a6ea43ae09004d54e7fb91219abb116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a select menu is clicked attached to a message. Select menu clicks are triggered by discord when select menus are clicked which you have associated with a message using <a class="el" href="classdpp_1_1component.html" title="Represents the component object. A component is a clickable button or drop down list within a discord...">dpp::component</a>.  <a href="classdpp_1_1cluster.html#a8a6ea43ae09004d54e7fb91219abb116">More...</a><br /></td></tr>
<tr class="separator:a8a6ea43ae09004d54e7fb91219abb116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222659a0402e17e4900f8bdcf46d60a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__delete__t.html">guild_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a222659a0402e17e4900f8bdcf46d60a7">on_guild_delete</a></td></tr>
<tr class="memdesc:a222659a0402e17e4900f8bdcf46d60a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a guild is deleted. A guild can be deleted via the bot being kicked, the bot leaving the guild explicitly with dpp::guild_delete, or via the guild being unavaialble due to an outage.  <a href="classdpp_1_1cluster.html#a222659a0402e17e4900f8bdcf46d60a7">More...</a><br /></td></tr>
<tr class="separator:a222659a0402e17e4900f8bdcf46d60a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77d4a1c6718d1371d53844ec49235c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1channel__delete__t.html">channel_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af77d4a1c6718d1371d53844ec49235c4">on_channel_delete</a></td></tr>
<tr class="memdesc:af77d4a1c6718d1371d53844ec49235c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a channel is deleted from a guild. The channel will still be temporarily avaialble in the cache. Pointers to the channel should not be retained long-term as they will be deleted by the garbage collector.  <a href="classdpp_1_1cluster.html#af77d4a1c6718d1371d53844ec49235c4">More...</a><br /></td></tr>
<tr class="separator:af77d4a1c6718d1371d53844ec49235c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d6e3d756c10174c23e58ffe2cf97ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1channel__update__t.html">channel_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a14d6e3d756c10174c23e58ffe2cf97ba">on_channel_update</a></td></tr>
<tr class="memdesc:a14d6e3d756c10174c23e58ffe2cf97ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a channel is edited on a guild. The new channel details have already been applied to the guild when you receive this event.  <a href="classdpp_1_1cluster.html#a14d6e3d756c10174c23e58ffe2cf97ba">More...</a><br /></td></tr>
<tr class="separator:a14d6e3d756c10174c23e58ffe2cf97ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eca020e6b80f8ec68a1ecba86c43dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1ready__t.html">ready_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac5eca020e6b80f8ec68a1ecba86c43dc">on_ready</a></td></tr>
<tr class="memdesc:ac5eca020e6b80f8ec68a1ecba86c43dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a shard is connected and ready. A set of on_guild_create events will follow this event.  <a href="classdpp_1_1cluster.html#ac5eca020e6b80f8ec68a1ecba86c43dc">More...</a><br /></td></tr>
<tr class="separator:ac5eca020e6b80f8ec68a1ecba86c43dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb3ebaf4cc6db89b398d197d17d9f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1message__delete__t.html">message_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7fb3ebaf4cc6db89b398d197d17d9f03">on_message_delete</a></td></tr>
<tr class="memdesc:a7fb3ebaf4cc6db89b398d197d17d9f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a message is deleted. The message has already been deleted from Discord when you receive this event.  <a href="classdpp_1_1cluster.html#a7fb3ebaf4cc6db89b398d197d17d9f03">More...</a><br /></td></tr>
<tr class="separator:a7fb3ebaf4cc6db89b398d197d17d9f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae349c245c7fa002090b95fd66b88f2a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1application__command__delete__t.html">application_command_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae349c245c7fa002090b95fd66b88f2a5">on_application_command_delete</a></td></tr>
<tr class="memdesc:ae349c245c7fa002090b95fd66b88f2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an application command (slash command) is deleted.  <a href="classdpp_1_1cluster.html#ae349c245c7fa002090b95fd66b88f2a5">More...</a><br /></td></tr>
<tr class="separator:ae349c245c7fa002090b95fd66b88f2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb35033028cfd0fd2642fd3dfc8ef02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__member__remove__t.html">guild_member_remove_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#adcb35033028cfd0fd2642fd3dfc8ef02">on_guild_member_remove</a></td></tr>
<tr class="memdesc:adcb35033028cfd0fd2642fd3dfc8ef02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user leaves a guild (either through being kicked, or choosing to leave)  <a href="classdpp_1_1cluster.html#adcb35033028cfd0fd2642fd3dfc8ef02">More...</a><br /></td></tr>
<tr class="separator:adcb35033028cfd0fd2642fd3dfc8ef02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8bbb63ca756c719f36ff1c6340d754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1application__command__create__t.html">application_command_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#afc8bbb63ca756c719f36ff1c6340d754">on_application_command_create</a></td></tr>
<tr class="memdesc:afc8bbb63ca756c719f36ff1c6340d754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new application command (slash command) is registered.  <a href="classdpp_1_1cluster.html#afc8bbb63ca756c719f36ff1c6340d754">More...</a><br /></td></tr>
<tr class="separator:afc8bbb63ca756c719f36ff1c6340d754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760583fe988bebe640a9a68b908c1a9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1resumed__t.html">resumed_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a760583fe988bebe640a9a68b908c1a9d">on_resumed</a></td></tr>
<tr class="memdesc:a760583fe988bebe640a9a68b908c1a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a connection to a shard successfully resumes. A resumed session does not need to re-synchronise guilds, members, etc. This is generally non-fatal and informational only.  <a href="classdpp_1_1cluster.html#a760583fe988bebe640a9a68b908c1a9d">More...</a><br /></td></tr>
<tr class="separator:a760583fe988bebe640a9a68b908c1a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b30c2f556abc539494438e7d5c1b4ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__role__create__t.html">guild_role_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0b30c2f556abc539494438e7d5c1b4ae">on_guild_role_create</a></td></tr>
<tr class="memdesc:a0b30c2f556abc539494438e7d5c1b4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new role is created on a guild.  <a href="classdpp_1_1cluster.html#a0b30c2f556abc539494438e7d5c1b4ae">More...</a><br /></td></tr>
<tr class="separator:a0b30c2f556abc539494438e7d5c1b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9afbcedb627dfa0830b783594a66490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1typing__start__t.html">typing_start_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad9afbcedb627dfa0830b783594a66490">on_typing_start</a></td></tr>
<tr class="memdesc:ad9afbcedb627dfa0830b783594a66490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user is typing on a channel.  <a href="classdpp_1_1cluster.html#ad9afbcedb627dfa0830b783594a66490">More...</a><br /></td></tr>
<tr class="separator:ad9afbcedb627dfa0830b783594a66490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af049a65227f648286a9d2e49fcd91bc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__add__t.html">message_reaction_add_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af049a65227f648286a9d2e49fcd91bc5">on_message_reaction_add</a></td></tr>
<tr class="memdesc:af049a65227f648286a9d2e49fcd91bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new reaction is added to a message.  <a href="classdpp_1_1cluster.html#af049a65227f648286a9d2e49fcd91bc5">More...</a><br /></td></tr>
<tr class="separator:af049a65227f648286a9d2e49fcd91bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0069b8aa4da038722a777c095962bec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__members__chunk__t.html">guild_members_chunk_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0069b8aa4da038722a777c095962bec9">on_guild_members_chunk</a></td></tr>
<tr class="memdesc:a0069b8aa4da038722a777c095962bec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a set of members is received for a guild. D++ will request these for all new guilds if needed, after the on_guild_create events.  <a href="classdpp_1_1cluster.html#a0069b8aa4da038722a777c095962bec9">More...</a><br /></td></tr>
<tr class="separator:a0069b8aa4da038722a777c095962bec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf5b31fd3b0cecfae99439458aa23e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__remove__t.html">message_reaction_remove_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#abdf5b31fd3b0cecfae99439458aa23e7">on_message_reaction_remove</a></td></tr>
<tr class="memdesc:abdf5b31fd3b0cecfae99439458aa23e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a single reaction is removed from a message.  <a href="classdpp_1_1cluster.html#abdf5b31fd3b0cecfae99439458aa23e7">More...</a><br /></td></tr>
<tr class="separator:abdf5b31fd3b0cecfae99439458aa23e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52ce8b7ef61c41773b1b38e46f6cc21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__create__t.html">guild_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab52ce8b7ef61c41773b1b38e46f6cc21">on_guild_create</a></td></tr>
<tr class="memdesc:ab52ce8b7ef61c41773b1b38e46f6cc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new guild is created. D++ will request members for the guild for its cache using guild_members_chunk.  <a href="classdpp_1_1cluster.html#ab52ce8b7ef61c41773b1b38e46f6cc21">More...</a><br /></td></tr>
<tr class="separator:ab52ce8b7ef61c41773b1b38e46f6cc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156195841560c2e1b1764dfb06b83bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1channel__create__t.html">channel_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a156195841560c2e1b1764dfb06b83bdc">on_channel_create</a></td></tr>
<tr class="memdesc:a156195841560c2e1b1764dfb06b83bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new channel is created on a guild.  <a href="classdpp_1_1cluster.html#a156195841560c2e1b1764dfb06b83bdc">More...</a><br /></td></tr>
<tr class="separator:a156195841560c2e1b1764dfb06b83bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84df62d9facbde422bfac46b39efbd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__remove__emoji__t.html">message_reaction_remove_emoji_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab84df62d9facbde422bfac46b39efbd2">on_message_reaction_remove_emoji</a></td></tr>
<tr class="memdesc:ab84df62d9facbde422bfac46b39efbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when all reactions for a particular emoji are removed from a message.  <a href="classdpp_1_1cluster.html#ab84df62d9facbde422bfac46b39efbd2">More...</a><br /></td></tr>
<tr class="separator:ab84df62d9facbde422bfac46b39efbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7838ae8d979f4a449cec9aaaf267ccdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1message__delete__bulk__t.html">message_delete_bulk_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a7838ae8d979f4a449cec9aaaf267ccdc">on_message_delete_bulk</a></td></tr>
<tr class="memdesc:a7838ae8d979f4a449cec9aaaf267ccdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when multiple messages are deleted from a channel or DM.  <a href="classdpp_1_1cluster.html#a7838ae8d979f4a449cec9aaaf267ccdc">More...</a><br /></td></tr>
<tr class="separator:a7838ae8d979f4a449cec9aaaf267ccdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2613d1afaef70b34dc15d1bbba91ae44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__role__update__t.html">guild_role_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2613d1afaef70b34dc15d1bbba91ae44">on_guild_role_update</a></td></tr>
<tr class="memdesc:a2613d1afaef70b34dc15d1bbba91ae44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an existing role is updated on a guild.  <a href="classdpp_1_1cluster.html#a2613d1afaef70b34dc15d1bbba91ae44">More...</a><br /></td></tr>
<tr class="separator:a2613d1afaef70b34dc15d1bbba91ae44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6713bfe6c0df810f89ce73124e036790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__role__delete__t.html">guild_role_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6713bfe6c0df810f89ce73124e036790">on_guild_role_delete</a></td></tr>
<tr class="memdesc:a6713bfe6c0df810f89ce73124e036790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a role is deleted in a guild.  <a href="classdpp_1_1cluster.html#a6713bfe6c0df810f89ce73124e036790">More...</a><br /></td></tr>
<tr class="separator:a6713bfe6c0df810f89ce73124e036790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3af28a32fb05848d0e975768155999a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1channel__pins__update__t.html">channel_pins_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad3af28a32fb05848d0e975768155999a">on_channel_pins_update</a></td></tr>
<tr class="memdesc:ad3af28a32fb05848d0e975768155999a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a message is pinned. Note that the pinned message is not returned to this event, just the timestamp of the last pinned message.  <a href="classdpp_1_1cluster.html#ad3af28a32fb05848d0e975768155999a">More...</a><br /></td></tr>
<tr class="separator:ad3af28a32fb05848d0e975768155999a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f58f47d0dab75191f412c563d8ee39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1message__reaction__remove__all__t.html">message_reaction_remove_all_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae6f58f47d0dab75191f412c563d8ee39">on_message_reaction_remove_all</a></td></tr>
<tr class="memdesc:ae6f58f47d0dab75191f412c563d8ee39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when all reactions are removed from a message.  <a href="classdpp_1_1cluster.html#ae6f58f47d0dab75191f412c563d8ee39">More...</a><br /></td></tr>
<tr class="separator:ae6f58f47d0dab75191f412c563d8ee39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224e4628b25e9b0f29444793c8dd5335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1voice__server__update__t.html">voice_server_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a224e4628b25e9b0f29444793c8dd5335">on_voice_server_update</a></td></tr>
<tr class="memdesc:a224e4628b25e9b0f29444793c8dd5335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when we are told which voice server we can use. This will be sent either when we establish a new voice channel connection, or as discord rearrange their infrastructure.  <a href="classdpp_1_1cluster.html#a224e4628b25e9b0f29444793c8dd5335">More...</a><br /></td></tr>
<tr class="separator:a224e4628b25e9b0f29444793c8dd5335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0ffdd605394dd9cc10fd58f2b691d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__emojis__update__t.html">guild_emojis_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a2e0ffdd605394dd9cc10fd58f2b691d5">on_guild_emojis_update</a></td></tr>
<tr class="memdesc:a2e0ffdd605394dd9cc10fd58f2b691d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new emojis are added to a guild. The complete set of emojis is sent every time.  <a href="classdpp_1_1cluster.html#a2e0ffdd605394dd9cc10fd58f2b691d5">More...</a><br /></td></tr>
<tr class="separator:a2e0ffdd605394dd9cc10fd58f2b691d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9047fdd33193acad1e8999217cb79b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__stickers__update__t.html">guild_stickers_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aee9047fdd33193acad1e8999217cb79b">on_guild_stickers_update</a></td></tr>
<tr class="memdesc:aee9047fdd33193acad1e8999217cb79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new stickers are added to a guild. The complete set of stickers is sent every time.  <a href="classdpp_1_1cluster.html#aee9047fdd33193acad1e8999217cb79b">More...</a><br /></td></tr>
<tr class="separator:aee9047fdd33193acad1e8999217cb79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8a60045a8b5681d79625e5e1b4f927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1presence__update__t.html">presence_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0d8a60045a8b5681d79625e5e1b4f927">on_presence_update</a></td></tr>
<tr class="memdesc:a0d8a60045a8b5681d79625e5e1b4f927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user's presence is updated. To receive these you will need the GUILD_PRESENCES privileged intent. You will receive many of these, very often, and receiving them will significantly increase your bot's CPU usage. If you don't need them it is recommended to not ask for them.  <a href="classdpp_1_1cluster.html#a0d8a60045a8b5681d79625e5e1b4f927">More...</a><br /></td></tr>
<tr class="separator:a0d8a60045a8b5681d79625e5e1b4f927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a1f90bab8183454fb6f228dda8dc51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1webhooks__update__t.html">webhooks_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af5a1f90bab8183454fb6f228dda8dc51">on_webhooks_update</a></td></tr>
<tr class="memdesc:af5a1f90bab8183454fb6f228dda8dc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the webhooks for a guild are updated.  <a href="classdpp_1_1cluster.html#af5a1f90bab8183454fb6f228dda8dc51">More...</a><br /></td></tr>
<tr class="separator:af5a1f90bab8183454fb6f228dda8dc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb82d67aef151ddd17ba6857ca285034"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__member__add__t.html">guild_member_add_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#abb82d67aef151ddd17ba6857ca285034">on_guild_member_add</a></td></tr>
<tr class="memdesc:abb82d67aef151ddd17ba6857ca285034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new member joins a guild.  <a href="classdpp_1_1cluster.html#abb82d67aef151ddd17ba6857ca285034">More...</a><br /></td></tr>
<tr class="separator:abb82d67aef151ddd17ba6857ca285034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5633fcd031f73fd6ab9e827fd33aa414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1invite__delete__t.html">invite_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5633fcd031f73fd6ab9e827fd33aa414">on_invite_delete</a></td></tr>
<tr class="memdesc:a5633fcd031f73fd6ab9e827fd33aa414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an invite is deleted from a guild.  <a href="classdpp_1_1cluster.html#a5633fcd031f73fd6ab9e827fd33aa414">More...</a><br /></td></tr>
<tr class="separator:a5633fcd031f73fd6ab9e827fd33aa414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaeca29cbe20fe449914f5c77aaf2601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__update__t.html">guild_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#adaeca29cbe20fe449914f5c77aaf2601">on_guild_update</a></td></tr>
<tr class="memdesc:adaeca29cbe20fe449914f5c77aaf2601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when details of a guild are updated.  <a href="classdpp_1_1cluster.html#adaeca29cbe20fe449914f5c77aaf2601">More...</a><br /></td></tr>
<tr class="separator:adaeca29cbe20fe449914f5c77aaf2601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16da01a26f15814ed53eec781160dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__integrations__update__t.html">guild_integrations_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab16da01a26f15814ed53eec781160dae">on_guild_integrations_update</a></td></tr>
<tr class="memdesc:ab16da01a26f15814ed53eec781160dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an integration is updated for a guild. This returns the complete list. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc.  <a href="classdpp_1_1cluster.html#ab16da01a26f15814ed53eec781160dae">More...</a><br /></td></tr>
<tr class="separator:ab16da01a26f15814ed53eec781160dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25cc6467ceb4a55903895a3aa93eaff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__member__update__t.html">guild_member_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac25cc6467ceb4a55903895a3aa93eaff">on_guild_member_update</a></td></tr>
<tr class="memdesc:ac25cc6467ceb4a55903895a3aa93eaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when details of a guild member (e.g. their roles or nickname) are updated.  <a href="classdpp_1_1cluster.html#ac25cc6467ceb4a55903895a3aa93eaff">More...</a><br /></td></tr>
<tr class="separator:ac25cc6467ceb4a55903895a3aa93eaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f3fb072c9a1a92e680938431477e65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1application__command__update__t.html">application_command_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ae8f3fb072c9a1a92e680938431477e65">on_application_command_update</a></td></tr>
<tr class="memdesc:ae8f3fb072c9a1a92e680938431477e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an application command (slash command) is updated. You will only receive this event for application commands that belong to your bot/application.  <a href="classdpp_1_1cluster.html#ae8f3fb072c9a1a92e680938431477e65">More...</a><br /></td></tr>
<tr class="separator:ae8f3fb072c9a1a92e680938431477e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bcbf92ec745bc2a282a32377d4854a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1invite__create__t.html">invite_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a09bcbf92ec745bc2a282a32377d4854a">on_invite_create</a></td></tr>
<tr class="memdesc:a09bcbf92ec745bc2a282a32377d4854a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new invite is created for a guild.  <a href="classdpp_1_1cluster.html#a09bcbf92ec745bc2a282a32377d4854a">More...</a><br /></td></tr>
<tr class="separator:a09bcbf92ec745bc2a282a32377d4854a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583d733f99b3ad2c6d547f32979ea516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1message__update__t.html">message_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a583d733f99b3ad2c6d547f32979ea516">on_message_update</a></td></tr>
<tr class="memdesc:a583d733f99b3ad2c6d547f32979ea516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a message is updated (edited).  <a href="classdpp_1_1cluster.html#a583d733f99b3ad2c6d547f32979ea516">More...</a><br /></td></tr>
<tr class="separator:a583d733f99b3ad2c6d547f32979ea516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba195e369b6280d8cdf978644896673d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1user__update__t.html">user_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aba195e369b6280d8cdf978644896673d">on_user_update</a></td></tr>
<tr class="memdesc:aba195e369b6280d8cdf978644896673d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user is updated. This is separate to guild_member_update and includes things such as an avatar change, username change, discriminator change or change in subscription status for nitro.  <a href="classdpp_1_1cluster.html#aba195e369b6280d8cdf978644896673d">More...</a><br /></td></tr>
<tr class="separator:aba195e369b6280d8cdf978644896673d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acf1be98db275266dea3fc2d83be817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1message__create__t.html">message_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0acf1be98db275266dea3fc2d83be817">on_message_create</a></td></tr>
<tr class="memdesc:a0acf1be98db275266dea3fc2d83be817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new message arrives from discord. Note that D++ does not cache messages. If you want to cache these objects you should create something yourself within your bot. Caching of messages is not on the roadmap to be supported as it consumes excessive amounts of RAM.  <a href="classdpp_1_1cluster.html#a0acf1be98db275266dea3fc2d83be817">More...</a><br /></td></tr>
<tr class="separator:a0acf1be98db275266dea3fc2d83be817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e24648afcfecd1456e5cb6bfcb4ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__ban__add__t.html">guild_ban_add_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af2e24648afcfecd1456e5cb6bfcb4ac6">on_guild_ban_add</a></td></tr>
<tr class="memdesc:af2e24648afcfecd1456e5cb6bfcb4ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a ban is added to a guild.  <a href="classdpp_1_1cluster.html#af2e24648afcfecd1456e5cb6bfcb4ac6">More...</a><br /></td></tr>
<tr class="separator:af2e24648afcfecd1456e5cb6bfcb4ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4652a0d7d8471ffb4885a70b26461d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__ban__remove__t.html">guild_ban_remove_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a4652a0d7d8471ffb4885a70b26461d07">on_guild_ban_remove</a></td></tr>
<tr class="memdesc:a4652a0d7d8471ffb4885a70b26461d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a ban is removed from a guild.  <a href="classdpp_1_1cluster.html#a4652a0d7d8471ffb4885a70b26461d07">More...</a><br /></td></tr>
<tr class="separator:a4652a0d7d8471ffb4885a70b26461d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e6a647d42e6e57140ec67834e8a305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1integration__create__t.html">integration_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a07e6a647d42e6e57140ec67834e8a305">on_integration_create</a></td></tr>
<tr class="memdesc:a07e6a647d42e6e57140ec67834e8a305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new intgration is attached to a guild by a user. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc.  <a href="classdpp_1_1cluster.html#a07e6a647d42e6e57140ec67834e8a305">More...</a><br /></td></tr>
<tr class="separator:a07e6a647d42e6e57140ec67834e8a305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c1f2756c5d0d9634de77e5bf4f80bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1integration__update__t.html">integration_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a24c1f2756c5d0d9634de77e5bf4f80bd">on_integration_update</a></td></tr>
<tr class="memdesc:a24c1f2756c5d0d9634de77e5bf4f80bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an integration is updated by a user. This returns details of just the single integration that has changed. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc.  <a href="classdpp_1_1cluster.html#a24c1f2756c5d0d9634de77e5bf4f80bd">More...</a><br /></td></tr>
<tr class="separator:a24c1f2756c5d0d9634de77e5bf4f80bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd820eae596bdafb6da900e4205182f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1integration__delete__t.html">integration_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aefd820eae596bdafb6da900e4205182f">on_integration_delete</a></td></tr>
<tr class="memdesc:aefd820eae596bdafb6da900e4205182f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an integration is removed by a user. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc.  <a href="classdpp_1_1cluster.html#aefd820eae596bdafb6da900e4205182f">More...</a><br /></td></tr>
<tr class="separator:aefd820eae596bdafb6da900e4205182f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e40ca5a868de5ee11f24a6c4d6e4a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1thread__create__t.html">thread_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0e40ca5a868de5ee11f24a6c4d6e4a6b">on_thread_create</a></td></tr>
<tr class="memdesc:a0e40ca5a868de5ee11f24a6c4d6e4a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a thread is created Note: Threads are not cached by D++, but a list of thread IDs is accessible in a guild object.  <a href="classdpp_1_1cluster.html#a0e40ca5a868de5ee11f24a6c4d6e4a6b">More...</a><br /></td></tr>
<tr class="separator:a0e40ca5a868de5ee11f24a6c4d6e4a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cd9a0973faef7e6b60a69225afeaa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1thread__update__t.html">thread_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#aa5cd9a0973faef7e6b60a69225afeaa0">on_thread_update</a></td></tr>
<tr class="memdesc:aa5cd9a0973faef7e6b60a69225afeaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a thread is updated.  <a href="classdpp_1_1cluster.html#aa5cd9a0973faef7e6b60a69225afeaa0">More...</a><br /></td></tr>
<tr class="separator:aa5cd9a0973faef7e6b60a69225afeaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecde12ab525690cc394208c6682be99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1thread__delete__t.html">thread_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6ecde12ab525690cc394208c6682be99">on_thread_delete</a></td></tr>
<tr class="memdesc:a6ecde12ab525690cc394208c6682be99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a thread is deleted.  <a href="classdpp_1_1cluster.html#a6ecde12ab525690cc394208c6682be99">More...</a><br /></td></tr>
<tr class="separator:a6ecde12ab525690cc394208c6682be99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad849df31420d38c61a8612a7760c5834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1thread__list__sync__t.html">thread_list_sync_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad849df31420d38c61a8612a7760c5834">on_thread_list_sync</a></td></tr>
<tr class="memdesc:ad849df31420d38c61a8612a7760c5834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when thread list is synced (upon gaining access to a channel) Note: Threads are not cached by D++, but a list of thread IDs is accessible in a guild object.  <a href="classdpp_1_1cluster.html#ad849df31420d38c61a8612a7760c5834">More...</a><br /></td></tr>
<tr class="separator:ad849df31420d38c61a8612a7760c5834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcac1f0134cb08bdaebad831fa483fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1thread__member__update__t.html">thread_member_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#afdcac1f0134cb08bdaebad831fa483fd">on_thread_member_update</a></td></tr>
<tr class="memdesc:afdcac1f0134cb08bdaebad831fa483fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when current user's thread member object is updated.  <a href="classdpp_1_1cluster.html#afdcac1f0134cb08bdaebad831fa483fd">More...</a><br /></td></tr>
<tr class="separator:afdcac1f0134cb08bdaebad831fa483fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63f0cdfcce6519c2d7748fb05475c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1thread__members__update__t.html">thread_members_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac63f0cdfcce6519c2d7748fb05475c81">on_thread_members_update</a></td></tr>
<tr class="memdesc:ac63f0cdfcce6519c2d7748fb05475c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a thread's member list is updated (without GUILD_MEMBERS intent, is only called for current user)  <a href="classdpp_1_1cluster.html#ac63f0cdfcce6519c2d7748fb05475c81">More...</a><br /></td></tr>
<tr class="separator:ac63f0cdfcce6519c2d7748fb05475c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c70bcd16af9713f726a09380ef11b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__create__t.html">guild_scheduled_event_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0c70bcd16af9713f726a09380ef11b79">on_guild_scheduled_event_create</a></td></tr>
<tr class="memdesc:a0c70bcd16af9713f726a09380ef11b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new scheduled event is created.  <a href="classdpp_1_1cluster.html#a0c70bcd16af9713f726a09380ef11b79">More...</a><br /></td></tr>
<tr class="separator:a0c70bcd16af9713f726a09380ef11b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092db2b006613f2cc6fdeb5c44678fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__update__t.html">guild_scheduled_event_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a092db2b006613f2cc6fdeb5c44678fdd">on_guild_scheduled_event_update</a></td></tr>
<tr class="memdesc:a092db2b006613f2cc6fdeb5c44678fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new scheduled event is updated.  <a href="classdpp_1_1cluster.html#a092db2b006613f2cc6fdeb5c44678fdd">More...</a><br /></td></tr>
<tr class="separator:a092db2b006613f2cc6fdeb5c44678fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9908ea41c859c6e73274694dc5fbe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__delete__t.html">guild_scheduled_event_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8b9908ea41c859c6e73274694dc5fbe4">on_guild_scheduled_event_delete</a></td></tr>
<tr class="memdesc:a8b9908ea41c859c6e73274694dc5fbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new scheduled event is deleted.  <a href="classdpp_1_1cluster.html#a8b9908ea41c859c6e73274694dc5fbe4">More...</a><br /></td></tr>
<tr class="separator:a8b9908ea41c859c6e73274694dc5fbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac0a7f419e8112c673cdac0bcd225fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__user__add__t.html">guild_scheduled_event_user_add_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a0ac0a7f419e8112c673cdac0bcd225fb">on_guild_scheduled_event_user_add</a></td></tr>
<tr class="memdesc:a0ac0a7f419e8112c673cdac0bcd225fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user is added to a scheduled event.  <a href="classdpp_1_1cluster.html#a0ac0a7f419e8112c673cdac0bcd225fb">More...</a><br /></td></tr>
<tr class="separator:a0ac0a7f419e8112c673cdac0bcd225fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6609485238c84b358aac33d627f4f409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1guild__scheduled__event__user__remove__t.html">guild_scheduled_event_user_remove_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a6609485238c84b358aac33d627f4f409">on_guild_scheduled_event_user_remove</a></td></tr>
<tr class="memdesc:a6609485238c84b358aac33d627f4f409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user is removed to a scheduled event.  <a href="classdpp_1_1cluster.html#a6609485238c84b358aac33d627f4f409">More...</a><br /></td></tr>
<tr class="separator:a6609485238c84b358aac33d627f4f409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b58460acf026a8a30cf589d4961c04e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1voice__buffer__send__t.html">voice_buffer_send_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5b58460acf026a8a30cf589d4961c04e">on_voice_buffer_send</a></td></tr>
<tr class="memdesc:a5b58460acf026a8a30cf589d4961c04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when packets are sent from the voice buffer. The voice buffer contains packets that are already encoded with Opus and encrypted with Sodium, and merged into packets by the repacketizer, which is done in the dpp::discord_voice_client::send_audio method. You should use the buffer size properties of <a class="el" href="structdpp_1_1voice__buffer__send__t.html" title="voice buffer send">dpp::voice_buffer_send_t</a> to determine if you should fill the buffer with more content.  <a href="classdpp_1_1cluster.html#a5b58460acf026a8a30cf589d4961c04e">More...</a><br /></td></tr>
<tr class="separator:a5b58460acf026a8a30cf589d4961c04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7100923971433c0de42321f530a639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1voice__user__talking__t.html">voice_user_talking_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a5a7100923971433c0de42321f530a639">on_voice_user_talking</a></td></tr>
<tr class="memdesc:a5a7100923971433c0de42321f530a639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a user is talking on a voice channel.  <a href="classdpp_1_1cluster.html#a5a7100923971433c0de42321f530a639">More...</a><br /></td></tr>
<tr class="separator:a5a7100923971433c0de42321f530a639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dd03ef61b20d398dd64f0c091b6cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1voice__ready__t.html">voice_ready_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ac9dd03ef61b20d398dd64f0c091b6cf8">on_voice_ready</a></td></tr>
<tr class="memdesc:ac9dd03ef61b20d398dd64f0c091b6cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a voice channel is connected and ready to send audio. Note that this is not directly attached to the READY event of the websocket, as there is further connection that needs to be done before audio is ready to send.  <a href="classdpp_1_1cluster.html#ac9dd03ef61b20d398dd64f0c091b6cf8">More...</a><br /></td></tr>
<tr class="separator:ac9dd03ef61b20d398dd64f0c091b6cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17ccb505a153dcfd4ae2ab22f0df37e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1voice__receive__t.html">voice_receive_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ad17ccb505a153dcfd4ae2ab22f0df37e">on_voice_receive</a></td></tr>
<tr class="memdesc:ad17ccb505a153dcfd4ae2ab22f0df37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new audio data is received. Each separate user's audio from the voice channel will arrive tagged with their user id in the event, if a user can be attributed to the received audio.  <a href="classdpp_1_1cluster.html#ad17ccb505a153dcfd4ae2ab22f0df37e">More...</a><br /></td></tr>
<tr class="separator:ad17ccb505a153dcfd4ae2ab22f0df37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e80d5055faabfe85259b393734ecae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1voice__track__marker__t.html">voice_track_marker_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a8e80d5055faabfe85259b393734ecae1">on_voice_track_marker</a></td></tr>
<tr class="memdesc:a8e80d5055faabfe85259b393734ecae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when sending of audio passes over a track marker. Track markers are arbitrarily placed "bookmarks" in the audio buffer, placed by the bot developer. Each track marker can have a string value associated with it which is specified in <a class="el" href="classdpp_1_1discord__voice__client.html#a84fc0cb1aaf9691aed818e18daea1b84" title="Insert a track marker into the audio output buffer. A track marker is an arbitrary flag in the buffer...">dpp::discord_voice_client::insert_marker</a> and returned to this event.  <a href="classdpp_1_1cluster.html#a8e80d5055faabfe85259b393734ecae1">More...</a><br /></td></tr>
<tr class="separator:a8e80d5055faabfe85259b393734ecae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af568ad97be5c6a9f08ed4b68fa1dc738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1stage__instance__create__t.html">stage_instance_create_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#af568ad97be5c6a9f08ed4b68fa1dc738">on_stage_instance_create</a></td></tr>
<tr class="memdesc:af568ad97be5c6a9f08ed4b68fa1dc738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new stage instance is created on a stage channel.  <a href="classdpp_1_1cluster.html#af568ad97be5c6a9f08ed4b68fa1dc738">More...</a><br /></td></tr>
<tr class="separator:af568ad97be5c6a9f08ed4b68fa1dc738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ebe81fa8df2eb71a126f2f222da2b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1stage__instance__update__t.html">stage_instance_update_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a30ebe81fa8df2eb71a126f2f222da2b0">on_stage_instance_update</a></td></tr>
<tr class="memdesc:a30ebe81fa8df2eb71a126f2f222da2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a stage instance is updated.  <a href="classdpp_1_1cluster.html#a30ebe81fa8df2eb71a126f2f222da2b0">More...</a><br /></td></tr>
<tr class="separator:a30ebe81fa8df2eb71a126f2f222da2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e25040c5693fe302cd6662394b533c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt; void(const <a class="el" href="structdpp_1_1stage__instance__delete__t.html">stage_instance_delete_t</a> &amp;_event)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#a17e25040c5693fe302cd6662394b533c">on_stage_instance_delete</a></td></tr>
<tr class="memdesc:a17e25040c5693fe302cd6662394b533c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an existing stage instance is deleted from a stage channel.  <a href="classdpp_1_1cluster.html#a17e25040c5693fe302cd6662394b533c">More...</a><br /></td></tr>
<tr class="separator:a17e25040c5693fe302cd6662394b533c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab0d2c95628830a28f9abb09441914e40"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdpp_1_1cluster.html#ab0d2c95628830a28f9abb09441914e40">discord_client</a></td></tr>
<tr class="separator:ab0d2c95628830a28f9abb09441914e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The cluster class represents a group of shards and a command queue for sending and receiving commands from discord via HTTP. You should usually instantiate a cluster object at the very least to make use of the library. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aac40e45e1ff8efb4e9ae75a7ecacc786" name="aac40e45e1ff8efb4e9ae75a7ecacc786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac40e45e1ff8efb4e9ae75a7ecacc786">&#9670;&nbsp;</a></span>cluster() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dpp::cluster::cluster </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intents</em> = <code><a class="el" href="namespacedpp.html#a0042c0fc8164da4239b977d5be8e2ef5a561a52b3c6883808735c41891351c68f">i_default_intents</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shards</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cluster_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxclusters</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdpp_1_1cache__policy__t.html">cache_policy_t</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code>{<a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>,&#160;<a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>,&#160;<a class="el" href="namespacedpp.html#ace5c63d91b72c5bae7d8cf9d8f531e52a81a53a5c84326ed9419729871d0af46e">cp_aggressive</a>}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for creating a cluster. All but the token are optional. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The bot token to use for all HTTP commands and websocket connections </td></tr>
    <tr><td class="paramname">intents</td><td>A bitmask of dpd::intents values for all shards on this cluster. This is required to be sent for all bots with over 100 servers. </td></tr>
    <tr><td class="paramname">shards</td><td>The total number of shards on this bot. If there are multiple clusters, then (shards / clusters) actual shards will run on this cluster. If you omit this value, the library will attempt to query the Discord API for the correct number of shards to start. </td></tr>
    <tr><td class="paramname">cluster_id</td><td>The ID of this cluster, should be between 0 and MAXCLUSTERS-1 </td></tr>
    <tr><td class="paramname">maxclusters</td><td>The total number of clusters that are active, which may be on separate processes or even separate machines. </td></tr>
    <tr><td class="paramname">compressed</td><td>Whether or not to use compression for shards on this cluster. Saves a ton of bandwidth at the cost of some CPU </td></tr>
    <tr><td class="paramname">policy</td><td>Set the user caching policy for the cluster, either lazy (only cache users/members when they message the bot) or aggressive (request whole member lists on seeing new guilds too) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdpp_1_1exception.html" title="The dpp::exception class derives from std::exception and supports some other ways of passing in error...">dpp::exception</a></td><td>Thrown on windows, if WinSock fails to initialise, or on any other system if a <a class="el" href="classdpp_1_1request__queue.html" title="The request_queue class manages rate limits and marshalls HTTP requests that have been built as http_...">dpp::request_queue</a> fails to construct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b0b523f89559b4ce204ca9ed9693d79" name="a6b0b523f89559b4ce204ca9ed9693d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0b523f89559b4ce204ca9ed9693d79">&#9670;&nbsp;</a></span>cluster() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dpp::cluster::cluster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classdpp_1_1cluster.html" title="The cluster class represents a group of shards and a command queue for sending and receiving commands...">dpp::cluster</a> is non-copyable </p>

</div>
</div>
<a id="a2d957f52245734f6d44444af8380c952" name="a2d957f52245734f6d44444af8380c952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d957f52245734f6d44444af8380c952">&#9670;&nbsp;</a></span>cluster() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dpp::cluster::cluster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classdpp_1_1cluster.html" title="The cluster class represents a group of shards and a command queue for sending and receiving commands...">dpp::cluster</a> is non-moveable </p>

</div>
</div>
<a id="a270be0ab59aff4f335ef3f4af7559d92" name="a270be0ab59aff4f335ef3f4af7559d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270be0ab59aff4f335ef3f4af7559d92">&#9670;&nbsp;</a></span>~cluster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dpp::cluster::~cluster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the cluster object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad73706406e2f99b9a580319e389777be" name="ad73706406e2f99b9a580319e389777be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73706406e2f99b9a580319e389777be">&#9670;&nbsp;</a></span>channel_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a channel. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1channel.html" title="A definition of a discord channel There are one of these for every channel type except threads....">dpp::channel</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3b00dafa69984d444422b500c3d18b3" name="ad3b00dafa69984d444422b500c3d18b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b00dafa69984d444422b500c3d18b3">&#9670;&nbsp;</a></span>channel_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a channel. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel id to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2fce9638b93c6b5d5d67f8bea9f8f6c" name="aa2fce9638b93c6b5d5d67f8bea9f8f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fce9638b93c6b5d5d67f8bea9f8f6c">&#9670;&nbsp;</a></span>channel_delete_permission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_delete_permission </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>overwrite_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a permission from a channel. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to remove permission from </td></tr>
    <tr><td class="paramname">overwrite_id</td><td>Overwrite to remove, user or channel ID </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5511e31156dd2508387b1ba5a1612c09" name="a5511e31156dd2508387b1ba5a1612c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5511e31156dd2508387b1ba5a1612c09">&#9670;&nbsp;</a></span>channel_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_edit </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a channel. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to edit/update </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1channel.html" title="A definition of a discord channel There are one of these for every channel type except threads....">dpp::channel</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfb4457e63c60500b44bfdee27d80c75" name="abfb4457e63c60500b44bfdee27d80c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb4457e63c60500b44bfdee27d80c75">&#9670;&nbsp;</a></span>channel_edit_permissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_edit_permissions </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>overwrite_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>allow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>deny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a channel's permissions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to set permissions for </td></tr>
    <tr><td class="paramname">overwrite_id</td><td>Overwrite to change (a user or channel ID) </td></tr>
    <tr><td class="paramname">allow</td><td>allow permissions </td></tr>
    <tr><td class="paramname">deny</td><td>deny permissions </td></tr>
    <tr><td class="paramname">member</td><td>true if the overwrite_id is a user id, false if it is a channel id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a391779232600ba3a6f57d678047761b0" name="a391779232600ba3a6f57d678047761b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391779232600ba3a6f57d678047761b0">&#9670;&nbsp;</a></span>channel_edit_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_edit_position </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a channel's position. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to change the position for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1channel.html" title="A definition of a discord channel There are one of these for every channel type except threads....">dpp::channel</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b7593e4ba82977bf3d8ad9052c9c565" name="a1b7593e4ba82977bf3d8ad9052c9c565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7593e4ba82977bf3d8ad9052c9c565">&#9670;&nbsp;</a></span>channel_follow_news()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_follow_news </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>target_channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Follow a news channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel id to follow </td></tr>
    <tr><td class="paramname">target_channel_id</td><td>Channel to subscribe the channel to </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a108f6f06b43709c8d47df5f94a3ca0a5" name="a108f6f06b43709c8d47df5f94a3ca0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108f6f06b43709c8d47df5f94a3ca0a5">&#9670;&nbsp;</a></span>channel_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel ID to retrieve </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1channel.html" title="A definition of a discord channel There are one of these for every channel type except threads....">dpp::channel</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07e66a7400101f466aab40ed58c67942" name="a07e66a7400101f466aab40ed58c67942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e66a7400101f466aab40ed58c67942">&#9670;&nbsp;</a></span>channel_invite_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_invite_create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1invite.html">invite</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create invite for a channel. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to create an invite on </td></tr>
    <tr><td class="paramname">i</td><td>Invite to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1invite.html" title="Represents an invite to a discord guild or channel.">dpp::invite</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa03a0da5c8e6801dc56bda258265da04" name="aa03a0da5c8e6801dc56bda258265da04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03a0da5c8e6801dc56bda258265da04">&#9670;&nbsp;</a></span>channel_invites_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_invites_get </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get invites for a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to get invites for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#aa85b043fd45cf24caa23ab6004a2415a">dpp::invite_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a553bfda3b4f1671e75c5713275b781bd" name="a553bfda3b4f1671e75c5713275b781bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553bfda3b4f1671e75c5713275b781bd">&#9670;&nbsp;</a></span>channel_pins_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_pins_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a channel's pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel ID to get pins for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a44d4dd39b5d7c24c5fe97a76a73cf708">dpp::message_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2caf58e161373fd3fa26172a4a78c835" name="a2caf58e161373fd3fa26172a4a78c835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caf58e161373fd3fa26172a4a78c835">&#9670;&nbsp;</a></span>channel_typing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_typing </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1channel.html">channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger channel typing indicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Channel to set as typing on </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad80ac0e99c0a20c9c05678631189b8f3" name="ad80ac0e99c0a20c9c05678631189b8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80ac0e99c0a20c9c05678631189b8f3">&#9670;&nbsp;</a></span>channel_typing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channel_typing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger channel typing indicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>Channel ID to set as typing on </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24e67431b79cc2c3d0f12d59afd5a1c8" name="a24e67431b79cc2c3d0f12d59afd5a1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e67431b79cc2c3d0f12d59afd5a1c8">&#9670;&nbsp;</a></span>channels_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::channels_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all channels for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to retrieve channels for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a7c77c4dd9434985643b2f1993b227f30" title="A group of channels.">dpp::channel_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1e3f0868ece15373e81844dff719aa0" name="af1e3f0868ece15373e81844dff719aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e3f0868ece15373e81844dff719aa0">&#9670;&nbsp;</a></span>clear_audit_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp; dpp::cluster::clear_audit_reason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the audit log reason for the next REST call to be made. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically. </p>
<p >Example: </p><div class="fragment"><div class="line">bot.set_audit_reason(<span class="stringliteral">&quot;Won&#39;t be sent&quot;</span>)</div>
<div class="line">   .clear_audit_reason()</div>
<div class="line">   .channel_delete(my_channel_id);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>cluster&amp; Reference to self for chaining. </dd></dl>

</div>
</div>
<a id="a55c6a9bb92a500aefc65a953e419c27f" name="a55c6a9bb92a500aefc65a953e419c27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c6a9bb92a500aefc65a953e419c27f">&#9670;&nbsp;</a></span>create_dm_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::create_dm_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a dm channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_id</td><td>User ID to create DM channel with </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1channel.html" title="A definition of a discord channel There are one of these for every channel type except threads....">dpp::channel</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a627510bf4f4d1c3a999ccb506c75ec47" name="a627510bf4f4d1c3a999ccb506c75ec47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627510bf4f4d1c3a999ccb506c75ec47">&#9670;&nbsp;</a></span>create_webhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::create_webhook </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a webhook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Webhook to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1webhook.html" title="Represents a discord webhook.">dpp::webhook</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3dc39069aaaa492727f39b35edd957e" name="ac3dc39069aaaa492727f39b35edd957e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dc39069aaaa492727f39b35edd957e">&#9670;&nbsp;</a></span>current_application_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_application_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current (bot) application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1application.html" title="The application class represents details of a bot application.">dpp::application</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75e1e5dd813d36fffd6b532ed1b31178" name="a75e1e5dd813d36fffd6b532ed1b31178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e1e5dd813d36fffd6b532ed1b31178">&#9670;&nbsp;</a></span>current_user_connections_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_connections_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current user's connections (linked accounts, e.g. steam, xbox). This call requires the oauth2 <code>connections</code> scope and cannot be executed against a bot token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#ad5f78f7b7bca070ac34c0267ca49013a">dpp::connection_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a4db23ebdf9a8323bd54458dadecaed" name="a0a4db23ebdf9a8323bd54458dadecaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4db23ebdf9a8323bd54458dadecaed">&#9670;&nbsp;</a></span>current_user_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_edit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nickname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>image_blob</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a7d622bf5ff000e82a44af1a8ac794e83">image_type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespacedpp.html#a7d622bf5ff000e82a44af1a8ac794e83ace2c4de1f89397132561031f246f89f7">i_png</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit current (bot) user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nickname</td><td>Nickname to set </td></tr>
    <tr><td class="paramname">image_blob</td><td>Avatar data to upload (NOTE: Very heavily rate limited!) </td></tr>
    <tr><td class="paramname">type</td><td>Type of image for avatar </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1user.html" title="Represents a user on discord. May or may not be a member of a dpp::guild.">dpp::user</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdpp_1_1exception.html" title="The dpp::exception class derives from std::exception and supports some other ways of passing in error...">dpp::exception</a></td><td>Image data is larger than the maximum size of 256 kilobytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad927e85ed6b99e9b05f4190f1b19cae" name="aad927e85ed6b99e9b05f4190f1b19cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad927e85ed6b99e9b05f4190f1b19cae">&#9670;&nbsp;</a></span>current_user_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current (bot) user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">dpp::user_identified</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">user_identified</a> object is a subclass of <a class="el" href="classdpp_1_1user.html" title="Represents a user on discord. May or may not be a member of a dpp::guild.">dpp::user</a> which contains further details if you have the oauth2 identify or email scopes. If you do not have these scopes, these fields are empty. You can safely convert a <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">user_identified</a> to user with <code>dynamic_cast</code>. </dd></dl>

</div>
</div>
<a id="a662fc0a998c62395f166da5e4a2acaf3" name="a662fc0a998c62395f166da5e4a2acaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662fc0a998c62395f166da5e4a2acaf3">&#9670;&nbsp;</a></span>current_user_get_dms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_get_dms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current user DM channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a7c77c4dd9434985643b2f1993b227f30" title="A group of channels.">dpp::channel_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93c8fd5f22e0eae6bf357ad498b43f87" name="a93c8fd5f22e0eae6bf357ad498b43f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c8fd5f22e0eae6bf357ad498b43f87">&#9670;&nbsp;</a></span>current_user_get_guilds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_get_guilds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current (bot) user guilds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a0d9e1952e25391a3379ee3db2d930bf7">dpp::guild_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a485553dc602bb2a7ed3ca11057034221" name="a485553dc602bb2a7ed3ca11057034221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485553dc602bb2a7ed3ca11057034221">&#9670;&nbsp;</a></span>current_user_join_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_join_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread ID to join </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa20f6c8ef35465a17c9510fa8353ef3a" name="aa20f6c8ef35465a17c9510fa8353ef3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20f6c8ef35465a17c9510fa8353ef3a">&#9670;&nbsp;</a></span>current_user_leave_guild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_leave_guild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to leave </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13a819f21159771de3142d57eabfe306" name="a13a819f21159771de3142d57eabfe306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a819f21159771de3142d57eabfe306">&#9670;&nbsp;</a></span>current_user_leave_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::current_user_leave_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread ID to leave </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee76e0048ec1cd35420da1bfc5317646" name="aee76e0048ec1cd35420da1bfc5317646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee76e0048ec1cd35420da1bfc5317646">&#9670;&nbsp;</a></span>delete_webhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::delete_webhook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>webhook_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a webhook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">webhook_id</td><td>Webhook ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6e937f48e410469c90f37368afa4cbe" name="ae6e937f48e410469c90f37368afa4cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e937f48e410469c90f37368afa4cbe">&#9670;&nbsp;</a></span>delete_webhook_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::delete_webhook_message </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete webhook message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Webhook to delete message for </td></tr>
    <tr><td class="paramname">message_id</td><td>Message ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae790b70aaecd9c42fe8a64c4c71a3d0c" name="ae790b70aaecd9c42fe8a64c4c71a3d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae790b70aaecd9c42fe8a64c4c71a3d0c">&#9670;&nbsp;</a></span>delete_webhook_with_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::delete_webhook_with_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>webhook_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete webhook with token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">webhook_id</td><td>Webhook ID to delete </td></tr>
    <tr><td class="paramname">token</td><td>Token of webhook to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3a5e7d9ba9dcbfc1e219eeb029f61ad" name="ae3a5e7d9ba9dcbfc1e219eeb029f61ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a5e7d9ba9dcbfc1e219eeb029f61ad">&#9670;&nbsp;</a></span>direct_message_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::direct_message_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a direct message, also create the channel for the direct message if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_id</td><td>User ID of user to send message to </td></tr>
    <tr><td class="paramname">m</td><td>Message object </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af319c151f1b9b2b578d9303bab7ce5d0" name="af319c151f1b9b2b578d9303bab7ce5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af319c151f1b9b2b578d9303bab7ce5d0">&#9670;&nbsp;</a></span>edit_webhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::edit_webhook </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit webhook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Webhook to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1webhook.html" title="Represents a discord webhook.">dpp::webhook</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a37684f9d12edd4ca7d00296a5443b" name="a86a37684f9d12edd4ca7d00296a5443b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a37684f9d12edd4ca7d00296a5443b">&#9670;&nbsp;</a></span>edit_webhook_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::edit_webhook_message </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit webhook message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Webhook to edit message for </td></tr>
    <tr><td class="paramname">m</td><td>New message </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bffc1fa43d6a78814f9ca0f378755c5" name="a2bffc1fa43d6a78814f9ca0f378755c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bffc1fa43d6a78814f9ca0f378755c5">&#9670;&nbsp;</a></span>edit_webhook_with_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::edit_webhook_with_token </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit webhook with token (token is encapsulated in the webhook object) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Wehook to edit (should include token) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1webhook.html" title="Represents a discord webhook.">dpp::webhook</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5e83314cede8b9277a01b7b173abbad" name="ad5e83314cede8b9277a01b7b173abbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e83314cede8b9277a01b7b173abbad">&#9670;&nbsp;</a></span>execute_webhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::execute_webhook </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute webhook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Webhook to execute </td></tr>
    <tr><td class="paramname">m</td><td>Message to send </td></tr>
    <tr><td class="paramname">wait</td><td>waits for server confirmation of message send before response, and returns the created message body </td></tr>
    <tr><td class="paramname">thread_id</td><td>Send a message to the specified thread within a webhook's channel. The thread will automatically be unarchived </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ad36637b9bb094d9f24d18f204138a3" name="a9ad36637b9bb094d9f24d18f204138a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad36637b9bb094d9f24d18f204138a3">&#9670;&nbsp;</a></span>gdm_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::gdm_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>access_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a recipient to a Group DM using their access token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel id to add group DM recipients to </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to add </td></tr>
    <tr><td class="paramname">access_token</td><td>Access token from OAuth2 </td></tr>
    <tr><td class="paramname">nick</td><td>Nickname of user to apply to the chat </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6be231a13131f6fae94f88ee6fcdc5f0" name="a6be231a13131f6fae94f88ee6fcdc5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be231a13131f6fae94f88ee6fcdc5f0">&#9670;&nbsp;</a></span>gdm_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::gdm_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a recipient from a Group DM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel ID of group DM </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to remove from group DM </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7a2958625740b4a6fde6643042c5f7e" name="ab7a2958625740b4a6fde6643042c5f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a2958625740b4a6fde6643042c5f7e">&#9670;&nbsp;</a></span>get_audit_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dpp::cluster::get_audit_reason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the audit reason set for the next REST call to be made on this thread. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically. </p>
<dl class="section note"><dt>Note</dt><dd>This method call clears the audit reason when it returns it.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The audit reason to be used. </dd></dl>

</div>
</div>
<a id="ae58b1f27711b42e9aa8a21e34147429f" name="ae58b1f27711b42e9aa8a21e34147429f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58b1f27711b42e9aa8a21e34147429f">&#9670;&nbsp;</a></span>get_channel_webhooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_channel_webhooks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get channel webhooks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel ID to get webhooks for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1cb0cc074a1653521bab47f83498e9ca" title="A group of webhooks.">dpp::webhook_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6164d5543b7594731a980da9b0b2088" name="ae6164d5543b7594731a980da9b0b2088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6164d5543b7594731a980da9b0b2088">&#9670;&nbsp;</a></span>get_dm_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> dpp::cluster::get_dm_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dm channel for a user id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_id</td><td>the user id to get the dm channel for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on failure </dd></dl>

</div>
</div>
<a id="a68f16d04f100a0159683cba96e8c0a6c" name="a68f16d04f100a0159683cba96e8c0a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f16d04f100a0159683cba96e8c0a6c">&#9670;&nbsp;</a></span>get_gateway_bot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_gateway_bot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the gateway information for the bot using the token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1gateway.html" title="Represents the various information from the &#39;get gateway bot&#39; api call.">dpp::gateway</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d352afcbc0430ca11576386278da7d0" name="a8d352afcbc0430ca11576386278da7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d352afcbc0430ca11576386278da7d0">&#9670;&nbsp;</a></span>get_guild_webhooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_guild_webhooks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild webhooks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get webhooks for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1cb0cc074a1653521bab47f83498e9ca" title="A group of webhooks.">dpp::webhook_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c677c0d5c059e87cc01ce598d49487d" name="a5c677c0d5c059e87cc01ce598d49487d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c677c0d5c059e87cc01ce598d49487d">&#9670;&nbsp;</a></span>get_shard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1discord__client.html">discord_client</a> * dpp::cluster::get_shard </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a shard by id, returning the <a class="el" href="classdpp_1_1discord__client.html" title="Implements a discord client. Each discord_client connects to one shard and derives from a websocket c...">discord_client</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Shard ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>discord_client* shard, or null </dd></dl>

</div>
</div>
<a id="af4d6195862e6d25c644902631a0b34d1" name="af4d6195862e6d25c644902631a0b34d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d6195862e6d25c644902631a0b34d1">&#9670;&nbsp;</a></span>get_shards()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedpp.html#a13c4d4e6238396245b349e6a637897e0">shard_list</a> &amp; dpp::cluster::get_shards </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of shards. </p>
<dl class="section return"><dt>Returns</dt><dd>shard_list&amp; Reference to map of shards for this cluster </dd></dl>

</div>
</div>
<a id="af6d45a29b3976f7b623d92e70ab9a1bc" name="af6d45a29b3976f7b623d92e70ab9a1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d45a29b3976f7b623d92e70ab9a1bc">&#9670;&nbsp;</a></span>get_voice_regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_voice_regions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all voice regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#ae90871830444cab0316109a1824fc0b8" title="A group of voice regions.">dpp::voiceregion_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40e140f1e2eda9632828bce461bc7338" name="a40e140f1e2eda9632828bce461bc7338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e140f1e2eda9632828bce461bc7338">&#9670;&nbsp;</a></span>get_webhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_webhook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>webhook_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get webhook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">webhook_id</td><td>Webhook ID to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1webhook.html" title="Represents a discord webhook.">dpp::webhook</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8685b3bd821ab87342670d730689191e" name="a8685b3bd821ab87342670d730689191e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8685b3bd821ab87342670d730689191e">&#9670;&nbsp;</a></span>get_webhook_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_webhook_message </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1webhook.html">webhook</a> &amp;&#160;</td>
          <td class="paramname"><em>wh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get webhook message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wh</td><td>Webhook to get the original message for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a770526895ed13e2dfb746decc3f0be67" name="a770526895ed13e2dfb746decc3f0be67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770526895ed13e2dfb746decc3f0be67">&#9670;&nbsp;</a></span>get_webhook_with_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::get_webhook_with_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>webhook_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get webhook using token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">webhook_id</td><td>Webhook ID to retrieve </td></tr>
    <tr><td class="paramname">token</td><td>Token of webhook </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1webhook.html" title="Represents a discord webhook.">dpp::webhook</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2319ca200dcd5cce1b9b6696946ece22" name="a2319ca200dcd5cce1b9b6696946ece22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2319ca200dcd5cce1b9b6696946ece22">&#9670;&nbsp;</a></span>global_bulk_command_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::global_bulk_command_create </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create/overwrite global slash commands. Any existing global slash commands will be deletd and replaced with these. </p>
<dl class="section note"><dt>Note</dt><dd>Global commands are cached by discord server-side and can take up to an hour to be visible. For testing, you should use <a class="el" href="classdpp_1_1cluster.html#aa7aad2d123fe4d13cb880ff59d8048f5" title="Create/overwrite guild slash commands. Any existing guild slash commands on this guild will be delete...">cluster::guild_bulk_command_create</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commands</td><td>Vector of slash commands to create/update. overwriting existing commands that are registered globally for this application. Updates will be available in all guilds after 1 hour. Commands that do not already exist will count toward daily application command create limits. </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a list of dpp::slashcommmand object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a124b1a52ca2f5ae298f1bb99ca964dcb" name="a124b1a52ca2f5ae298f1bb99ca964dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124b1a52ca2f5ae298f1bb99ca964dcb">&#9670;&nbsp;</a></span>global_command_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::global_command_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global slash command (a bot can have a maximum of 100 of these). </p>
<dl class="section note"><dt>Note</dt><dd>Global commands are cached by discord server-side and can take up to an hour to be visible. For testing, you should use <a class="el" href="classdpp_1_1cluster.html#a4c0ce1ad5256a252ab0ce43923a07ae3" title="Create a slash command local to a guild.">cluster::guild_command_create</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Slash command to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a dpp::slashcommmand object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cb7e2a8ddcb41a39d989802853a8605" name="a7cb7e2a8ddcb41a39d989802853a8605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb7e2a8ddcb41a39d989802853a8605">&#9670;&nbsp;</a></span>global_command_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::global_command_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a global slash command (a bot can have a maximum of 100 of these) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Slash command to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef037a47fee2efddedfe78ba4bf0467c" name="aef037a47fee2efddedfe78ba4bf0467c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef037a47fee2efddedfe78ba4bf0467c">&#9670;&nbsp;</a></span>global_command_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::global_command_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a global slash command (a bot can have a maximum of 100 of these) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Slash command to change </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a8cadcdde42fcfa8d29c0c4fd0bec5b" name="a8a8cadcdde42fcfa8d29c0c4fd0bec5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8cadcdde42fcfa8d29c0c4fd0bec5b">&#9670;&nbsp;</a></span>global_commands_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::global_commands_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the application's global slash commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#adfefe335636cdf5dbbba145a3828c554" title="A group of application slash commands.">dpp::slashcommand_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2937f10828bc3fbdeff87fc6b4463cc" name="aa2937f10828bc3fbdeff87fc6b4463cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2937f10828bc3fbdeff87fc6b4463cc">&#9670;&nbsp;</a></span>guild_add_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_add_member </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1guild__member.html">guild_member</a> &amp;&#160;</td>
          <td class="paramname"><em>gm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>access_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add guild member. Needs a specific oauth2 scope, from which you get the access_token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gm</td><td>Guild member to add </td></tr>
    <tr><td class="paramname">access_token</td><td>Access token from Oauth2 scope </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__member.html" title="Represents dpp::user membership upon a dpp::guild. This contains the user&#39;s nickname,...">dpp::guild_member</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74a61aa62ddf9207c197bfd496ae6ade" name="a74a61aa62ddf9207c197bfd496ae6ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a61aa62ddf9207c197bfd496ae6ade">&#9670;&nbsp;</a></span>guild_auditlog_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_auditlog_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the audit log for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to get the audit log of </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1auditlog.html" title="The auditlog class represents the audit log entry of a guild.">dpp::auditlog</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2273fdee237880d5e6b948198ffae52" name="ad2273fdee237880d5e6b948198ffae52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2273fdee237880d5e6b948198ffae52">&#9670;&nbsp;</a></span>guild_ban_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_ban_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delete_message_days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add guild ban. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to add ban to </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to ban </td></tr>
    <tr><td class="paramname">delete_message_days</td><td>How many days of ther user's messages to also delete </td></tr>
    <tr><td class="paramname">reason</td><td>Reason for ban </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1ban.html" title="The ban class represents a ban on a guild.">dpp::ban</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18f31527cd6b99cf2757e6c14dac5e5b" name="a18f31527cd6b99cf2757e6c14dac5e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f31527cd6b99cf2757e6c14dac5e5b">&#9670;&nbsp;</a></span>guild_ban_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_ban_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete guild ban. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to delete ban from </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to delete ban for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2102835f11fabbc2cd2e6b41155783f6" name="a2102835f11fabbc2cd2e6b41155783f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2102835f11fabbc2cd2e6b41155783f6">&#9670;&nbsp;</a></span>guild_begin_prune()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_begin_prune </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1prune.html">prune</a> &amp;&#160;</td>
          <td class="paramname"><em>pruneinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin guild prune. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to prune </td></tr>
    <tr><td class="paramname">pruneinfo</td><td>Pruning info </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1prune.html" title="Defines a request to count prunable users, or start a prune operation.">dpp::prune</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7aad2d123fe4d13cb880ff59d8048f5" name="aa7aad2d123fe4d13cb880ff59d8048f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7aad2d123fe4d13cb880ff59d8048f5">&#9670;&nbsp;</a></span>guild_bulk_command_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_bulk_command_create </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create/overwrite guild slash commands. Any existing guild slash commands on this guild will be deleted and replaced with these. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commands</td><td>Vector of slash commands to create/update. New guild commands will be available in the guild immediately. If the command did not already exist, it will count toward daily application command create limits. </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID to create/update the slash commands in </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a list of dpp::slashcommmand object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0ce1ad5256a252ab0ce43923a07ae3" name="a4c0ce1ad5256a252ab0ce43923a07ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0ce1ad5256a252ab0ce43923a07ae3">&#9670;&nbsp;</a></span>guild_command_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_command_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a slash command local to a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Slash command to create </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID to create the slash command in </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a dpp::slashcommmand object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b4a91a572c4e33ae60a3b09041ae3c2" name="a5b4a91a572c4e33ae60a3b09041ae3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4a91a572c4e33ae60a3b09041ae3c2">&#9670;&nbsp;</a></span>guild_command_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_command_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a slash command local to a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Slash command to delete </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID to delete the slash command in </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d555ccc3e69298ccac9d160ce3a71bf" name="a4d555ccc3e69298ccac9d160ce3a71bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d555ccc3e69298ccac9d160ce3a71bf">&#9670;&nbsp;</a></span>guild_command_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_command_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a slash command local to a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Slash command to edit </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID to edit the slash command in </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ebb701d07c25d3667f0e1640670bbc1" name="a4ebb701d07c25d3667f0e1640670bbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebb701d07c25d3667f0e1640670bbc1">&#9670;&nbsp;</a></span>guild_command_edit_permissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_command_edit_permissions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1slashcommand.html">slashcommand</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit slash command permissions local to a guild, permissions are read from s.permissions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Slash command to edit </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID to edit the slash command in </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01623d7535dc359905990e710ae3b5e9" name="a01623d7535dc359905990e710ae3b5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01623d7535dc359905990e710ae3b5e9">&#9670;&nbsp;</a></span>guild_commands_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_commands_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the application's slash commands for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get the slash commands for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#adfefe335636cdf5dbbba145a3828c554" title="A group of application slash commands.">dpp::slashcommand_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af327d6e65c703ce001d666ef2adc4b25" name="af327d6e65c703ce001d666ef2adc4b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af327d6e65c703ce001d666ef2adc4b25">&#9670;&nbsp;</a></span>guild_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1guild.html">guild</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Guild to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad277277c10ccdaecc3869a23d9ecb94b" name="ad277277c10ccdaecc3869a23d9ecb94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad277277c10ccdaecc3869a23d9ecb94b">&#9670;&nbsp;</a></span>guild_create_from_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_create_from_template </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new guild based on a template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Template code to create guild from </td></tr>
    <tr><td class="paramname">name</td><td>Guild name to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a78935110be8ea8bf5fdc4f0734fd28" name="a8a78935110be8ea8bf5fdc4f0734fd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a78935110be8ea8bf5fdc4f0734fd28">&#9670;&nbsp;</a></span>guild_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0db4a48d1ebc2133c30963a995e156e1" name="a0db4a48d1ebc2133c30963a995e156e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db4a48d1ebc2133c30963a995e156e1">&#9670;&nbsp;</a></span>guild_delete_integration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_delete_integration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>integration_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete guild integration. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to delete integration for </td></tr>
    <tr><td class="paramname">integration_id</td><td>Integration ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b0ce3857773519ca2ed62b49c04f267" name="a5b0ce3857773519ca2ed62b49c04f267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0ce3857773519ca2ed62b49c04f267">&#9670;&nbsp;</a></span>guild_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_edit </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1guild.html">guild</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Guild to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57a1957b81c9606850e730c477dd44aa" name="a57a1957b81c9606850e730c477dd44aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a1957b81c9606850e730c477dd44aa">&#9670;&nbsp;</a></span>guild_edit_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_edit_member </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdpp_1_1guild__member.html">guild_member</a> &amp;&#160;</td>
          <td class="paramname"><em>gm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit the properties of an existing guild member. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gm</td><td>Guild member to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__member.html" title="Represents dpp::user membership upon a dpp::guild. This contains the user&#39;s nickname,...">dpp::guild_member</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb37eaa792a69f43171f580695fd4520" name="afb37eaa792a69f43171f580695fd4520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb37eaa792a69f43171f580695fd4520">&#9670;&nbsp;</a></span>guild_edit_widget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_edit_widget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1guild__widget.html">guild_widget</a> &amp;&#160;</td>
          <td class="paramname"><em>gw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit guild widget. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to edit widget for </td></tr>
    <tr><td class="paramname">gw</td><td>New guild widget information </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__widget.html" title="Represents a guild widget, simple web widget of member list.">dpp::guild_widget</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f6d9dbdb2009bdea2fad46e93813af5" name="a5f6d9dbdb2009bdea2fad46e93813af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6d9dbdb2009bdea2fad46e93813af5">&#9670;&nbsp;</a></span>guild_emoji_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_emoji_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1emoji.html">emoji</a> &amp;&#160;</td>
          <td class="paramname"><em>newemoji</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create single emoji. You must ensure that the emoji passed contained image data using the <a class="el" href="classdpp_1_1emoji.html#a33694c119238d58da105c55fdf9dbcd9" title="Load an image into the object as base64.">emoji::load_image()</a> method. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to create emoji om </td></tr>
    <tr><td class="paramname">newemoji</td><td>Emoji to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1emoji.html" title="Represents an emoji for a dpp::guild.">dpp::emoji</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9c8f4357998bc8a77e8561edcb738c3" name="af9c8f4357998bc8a77e8561edcb738c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c8f4357998bc8a77e8561edcb738c3">&#9670;&nbsp;</a></span>guild_emoji_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_emoji_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>emoji_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a guild emoji. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to delete emoji on </td></tr>
    <tr><td class="paramname">emoji_id</td><td>Emoji ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c4bf8c1767b71ed06bfa407341096d4" name="a2c4bf8c1767b71ed06bfa407341096d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4bf8c1767b71ed06bfa407341096d4">&#9670;&nbsp;</a></span>guild_emoji_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_emoji_edit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1emoji.html">emoji</a> &amp;&#160;</td>
          <td class="paramname"><em>newemoji</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a single emoji. You must ensure that the emoji passed contained image data using the <a class="el" href="classdpp_1_1emoji.html#a33694c119238d58da105c55fdf9dbcd9" title="Load an image into the object as base64.">emoji::load_image()</a> method. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to edit emoji on </td></tr>
    <tr><td class="paramname">newemoji</td><td>Emoji to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1emoji.html" title="Represents an emoji for a dpp::guild.">dpp::emoji</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada721a222fb3a42a1a1bb6d93dfcc745" name="ada721a222fb3a42a1a1bb6d93dfcc745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada721a222fb3a42a1a1bb6d93dfcc745">&#9670;&nbsp;</a></span>guild_emoji_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_emoji_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>emoji_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a single emoji. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get emoji for </td></tr>
    <tr><td class="paramname">emoji_id</td><td>Emoji ID to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1emoji.html" title="Represents an emoji for a dpp::guild.">dpp::emoji</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad66ab98a72eb1ba8d2686fcaa1eb49db" name="ad66ab98a72eb1ba8d2686fcaa1eb49db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66ab98a72eb1ba8d2686fcaa1eb49db">&#9670;&nbsp;</a></span>guild_emojis_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_emojis_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all emojis for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get emojis for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a58e2720e1ccc11d2b3b1be2e18df79d9" title="Group of emojis.">dpp::emoji_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04dc202cee249447c1a135a80a852daf" name="a04dc202cee249447c1a135a80a852daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dc202cee249447c1a135a80a852daf">&#9670;&nbsp;</a></span>guild_event_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_event_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1scheduled__event.html">scheduled_event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scheduled event on a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to create (guild ID must be populated) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1d8eeeaca0cdc14125cbf2f4f0722781" title="A group of scheduled events.">dpp::scheduled_event_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17bec34914c433a1105697dd5c24c7f2" name="a17bec34914c433a1105697dd5c24c7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bec34914c433a1105697dd5c24c7f2">&#9670;&nbsp;</a></span>guild_event_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_event_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>event_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a scheduled event from a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_id</td><td>Event ID to delete </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID of event to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36b82a96ca6b744388e9b290cbf775ff" name="a36b82a96ca6b744388e9b290cbf775ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b82a96ca6b744388e9b290cbf775ff">&#9670;&nbsp;</a></span>guild_event_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_event_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1scheduled__event.html">scheduled_event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit/modify a scheduled event on a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to create (event ID and guild ID must be populated) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1d8eeeaca0cdc14125cbf2f4f0722781" title="A group of scheduled events.">dpp::scheduled_event_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b8c168682519ee125ed0a48239c08ef" name="a5b8c168682519ee125ed0a48239c08ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8c168682519ee125ed0a48239c08ef">&#9670;&nbsp;</a></span>guild_event_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_event_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>event_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a scheduled event for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to get event for </td></tr>
    <tr><td class="paramname">event_id</td><td>Event ID to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1scheduled__event.html" title="A scheduled event.">dpp::scheduled_event</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09f6a78b9b2ad6218ed1b8c7b044013a" name="a09f6a78b9b2ad6218ed1b8c7b044013a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f6a78b9b2ad6218ed1b8c7b044013a">&#9670;&nbsp;</a></span>guild_event_users_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_event_users_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>event_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>before</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>after</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get users RSVP'd to an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to get user list for </td></tr>
    <tr><td class="paramname">event_id</td><td>Guild to get user list for </td></tr>
    <tr><td class="paramname">limit</td><td>Maximum number of results to return </td></tr>
    <tr><td class="paramname">before</td><td>Return user IDs that fall before this ID, if provided </td></tr>
    <tr><td class="paramname">after</td><td>Return user IDs that fall after this ID, if provided </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1c4073c92e19579c06591033a4a234e1">dpp::user_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8554f93aed5fb84162af41c997fc1e3" name="ae8554f93aed5fb84162af41c997fc1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8554f93aed5fb84162af41c997fc1e3">&#9670;&nbsp;</a></span>guild_events_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_events_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all scheduled events for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to get events for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1d8eeeaca0cdc14125cbf2f4f0722781" title="A group of scheduled events.">dpp::scheduled_event_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a003669770549d25a951810bff0153e" name="a6a003669770549d25a951810bff0153e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a003669770549d25a951810bff0153e">&#9670;&nbsp;</a></span>guild_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Guild ID to retrieve </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad871d30ed11d0799da4a831ede8a7d95" name="ad871d30ed11d0799da4a831ede8a7d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad871d30ed11d0799da4a831ede8a7d95">&#9670;&nbsp;</a></span>guild_get_ban()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_ban </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get single guild ban. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get ban for </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID of ban to retrieve </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1ban.html" title="The ban class represents a ban on a guild.">dpp::ban</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9fffa4f080e0b5abab1417fa8eb1b0f" name="af9fffa4f080e0b5abab1417fa8eb1b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fffa4f080e0b5abab1417fa8eb1b0f">&#9670;&nbsp;</a></span>guild_get_bans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_bans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild ban list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get bans for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a52b195380df96e9c43f35fa2da82db14">dpp::ban_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43cba3bd187f9b28dcaed5b4f4ed5bda" name="a43cba3bd187f9b28dcaed5b4f4ed5bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cba3bd187f9b28dcaed5b4f4ed5bda">&#9670;&nbsp;</a></span>guild_get_integrations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_integrations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild itegrations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get integrations for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#aa13e2c5898009fad42ebe12fd5641d8a">dpp::integration_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93c0e07243611419141305da123c859a" name="a93c0e07243611419141305da123c859a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c0e07243611419141305da123c859a">&#9670;&nbsp;</a></span>guild_get_invites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_invites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild invites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get invites for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#aa85b043fd45cf24caa23ab6004a2415a">dpp::invite_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99e8227f11ef33cd2d9cc3abef46adfd" name="a99e8227f11ef33cd2d9cc3abef46adfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e8227f11ef33cd2d9cc3abef46adfd">&#9670;&nbsp;</a></span>guild_get_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_member </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a guild member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get member for </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID of member to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__member.html" title="Represents dpp::user membership upon a dpp::guild. This contains the user&#39;s nickname,...">dpp::guild_member</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b24baba4de9d38f7d9a7cea2f71a545" name="a6b24baba4de9d38f7d9a7cea2f71a545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b24baba4de9d38f7d9a7cea2f71a545">&#9670;&nbsp;</a></span>guild_get_members()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_members </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all guild members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get all members for </td></tr>
    <tr><td class="paramname">limit</td><td>max number of members to return (1-1000) </td></tr>
    <tr><td class="paramname">after</td><td>the highest user id in the previous page </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a219aedbe5bf37835c4a65115fccba278">dpp::guild_member_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ecd82c6169107c9c944356f19abba9e" name="a3ecd82c6169107c9c944356f19abba9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecd82c6169107c9c944356f19abba9e">&#9670;&nbsp;</a></span>guild_get_preview()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_preview </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a guild preview. Returns a guild object but only a subset of the fields will be populated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Guild ID to retrieve </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad296f07bd5b9f900dcedbf88c464e09" name="aad296f07bd5b9f900dcedbf88c464e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad296f07bd5b9f900dcedbf88c464e09">&#9670;&nbsp;</a></span>guild_get_prune_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_prune_counts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1prune.html">prune</a> &amp;&#160;</td>
          <td class="paramname"><em>pruneinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get prune counts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to count for pruning </td></tr>
    <tr><td class="paramname">pruneinfo</td><td>Pruning info </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1prune.html" title="Defines a request to count prunable users, or start a prune operation.">dpp::prune</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1332e45cc89e871009e840c25145df5" name="ad1332e45cc89e871009e840c25145df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1332e45cc89e871009e840c25145df5">&#9670;&nbsp;</a></span>guild_get_vanity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_vanity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild vanity url, if enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to get vanity URL for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1invite.html" title="Represents an invite to a discord guild or channel.">dpp::invite</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a> filled to match the vanity url. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5556385a69a408a268332f774ba6c3c" name="ae5556385a69a408a268332f774ba6c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5556385a69a408a268332f774ba6c3c">&#9670;&nbsp;</a></span>guild_get_voice_regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_voice_regions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild voice regions. Voice regions per guild are somewhat deprecated in preference of per-channel voice regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get voice regions for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#ae90871830444cab0316109a1824fc0b8" title="A group of voice regions.">dpp::voiceregion_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57626c7a0e06aee1c362b986e44030c2" name="a57626c7a0e06aee1c362b986e44030c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57626c7a0e06aee1c362b986e44030c2">&#9670;&nbsp;</a></span>guild_get_widget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_get_widget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild widget. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get widget for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__widget.html" title="Represents a guild widget, simple web widget of member list.">dpp::guild_widget</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9dcac8996e5eaad9b1eed9983ecefef" name="aa9dcac8996e5eaad9b1eed9983ecefef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9dcac8996e5eaad9b1eed9983ecefef">&#9670;&nbsp;</a></span>guild_member_add_role()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_member_add_role </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>role_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add role to guild member. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to add a role to </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to add role to </td></tr>
    <tr><td class="paramname">role_id</td><td>Role ID to add to the user </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58be46d2934738b32229d984c266a4b7" name="a58be46d2934738b32229d984c266a4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58be46d2934738b32229d984c266a4b7">&#9670;&nbsp;</a></span>guild_member_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_member_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove (kick) a guild member. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to kick member from </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to kick </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0289849ef90572a331e68fc84075cb2" name="af0289849ef90572a331e68fc84075cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0289849ef90572a331e68fc84075cb2">&#9670;&nbsp;</a></span>guild_member_delete_role()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_member_delete_role </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>role_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove role from guild member. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to remove role from user on </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID to remove role from </td></tr>
    <tr><td class="paramname">role_id</td><td>Role to remove </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40665f55528cfc1077b8adcae2d49086" name="a40665f55528cfc1077b8adcae2d49086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40665f55528cfc1077b8adcae2d49086">&#9670;&nbsp;</a></span>guild_member_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_member_move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the guild member to a other voice channel, if member is connected to one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Id of the channel to which the user is used </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild id to which the user is connected </td></tr>
    <tr><td class="paramname">user_id</td><td>User id, who should be moved </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild__member.html" title="Represents dpp::user membership upon a dpp::guild. This contains the user&#39;s nickname,...">dpp::guild_member</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb07fc90589ee936f73da5551cff1255" name="afb07fc90589ee936f73da5551cff1255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb07fc90589ee936f73da5551cff1255">&#9670;&nbsp;</a></span>guild_modify_integration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_modify_integration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1integration.html">integration</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify guild integration. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to modify integration for </td></tr>
    <tr><td class="paramname">i</td><td>Integration to modify </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1integration.html" title="Represents an integration on a guild, e.g. a connection to twitch.">dpp::integration</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52cc92ce052d063854e0372539e4d9ee" name="a52cc92ce052d063854e0372539e4d9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52cc92ce052d063854e0372539e4d9ee">&#9670;&nbsp;</a></span>guild_search_members()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_search_members </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for guild members based on whether their username or nickname starts with the given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to search in </td></tr>
    <tr><td class="paramname">query</td><td>Query string to match username(s) and nickname(s) against </td></tr>
    <tr><td class="paramname">limit</td><td>max number of members to return (1-1000) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a219aedbe5bf37835c4a65115fccba278">dpp::guild_member_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa30ff4f80815720bafab51f9bc86b089" name="aa30ff4f80815720bafab51f9bc86b089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30ff4f80815720bafab51f9bc86b089">&#9670;&nbsp;</a></span>guild_set_nickname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_set_nickname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>nickname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change current user nickname. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to change nickanem on </td></tr>
    <tr><td class="paramname">nickname</td><td>New nickname, or empty string to clear nickname </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f31d36f327a74d24fb4075cec6c2400" name="a7f31d36f327a74d24fb4075cec6c2400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f31d36f327a74d24fb4075cec6c2400">&#9670;&nbsp;</a></span>guild_sticker_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_sticker_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdpp_1_1sticker.html">sticker</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sticker in a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Sticker to create. Must have its guild ID set. </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08ed56cd299340bdf286bc3457225124" name="a08ed56cd299340bdf286bc3457225124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ed56cd299340bdf286bc3457225124">&#9670;&nbsp;</a></span>guild_sticker_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_sticker_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>sticker_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a sticker from a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sticker_id</td><td>sticker ID to delete </td></tr>
    <tr><td class="paramname">guild_id</td><td>guild ID to delete from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7a2d335385b4689e7489d0eaf4475fe" name="ac7a2d335385b4689e7489d0eaf4475fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2d335385b4689e7489d0eaf4475fe">&#9670;&nbsp;</a></span>guild_sticker_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_sticker_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a guild sticker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of sticker to get. </td></tr>
    <tr><td class="paramname">guild_id</td><td>Guild ID of the guild where the sticker is </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a222a8cb4498fd65ae8bb3345b02d0f8e" name="a222a8cb4498fd65ae8bb3345b02d0f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222a8cb4498fd65ae8bb3345b02d0f8e">&#9670;&nbsp;</a></span>guild_sticker_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_sticker_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdpp_1_1sticker.html">sticker</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a sticker in a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Sticker to modify. Must have its guild ID and sticker ID set. </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adccd1468d3f031c5bc786fdbd087d0a2" name="adccd1468d3f031c5bc786fdbd087d0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccd1468d3f031c5bc786fdbd087d0a2">&#9670;&nbsp;</a></span>guild_stickers_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_stickers_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all guild stickers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID of the guild where the sticker is </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58d976f9d101225e05482db7b739f986" name="a58d976f9d101225e05482db7b739f986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d976f9d101225e05482db7b739f986">&#9670;&nbsp;</a></span>guild_sync_integration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_sync_integration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>integration_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sync guild integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to sync integration on </td></tr>
    <tr><td class="paramname">integration_id</td><td>Integration ID to synchronise </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38db2ce96431b742e98cabf8170a84d7" name="a38db2ce96431b742e98cabf8170a84d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38db2ce96431b742e98cabf8170a84d7">&#9670;&nbsp;</a></span>guild_template_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_template_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a template for the guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to create template from </td></tr>
    <tr><td class="paramname">name</td><td>Template name to create </td></tr>
    <tr><td class="paramname">description</td><td>Description of template to create </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91791a9d280c0973834223df37d39ac8" name="a91791a9d280c0973834223df37d39ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91791a9d280c0973834223df37d39ac8">&#9670;&nbsp;</a></span>guild_template_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_template_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID of template to delete </td></tr>
    <tr><td class="paramname">code</td><td>Template code to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22f9702b44025f54cf03920d3a3e554b" name="a22f9702b44025f54cf03920d3a3e554b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f9702b44025f54cf03920d3a3e554b">&#9670;&nbsp;</a></span>guild_template_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_template_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the template's metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID of template to modify </td></tr>
    <tr><td class="paramname">code</td><td>Template code to modify </td></tr>
    <tr><td class="paramname">name</td><td>New name of template </td></tr>
    <tr><td class="paramname">description</td><td>New description of template </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fc2ed8ec7e7550daa418f693ade1016" name="a3fc2ed8ec7e7550daa418f693ade1016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc2ed8ec7e7550daa418f693ade1016">&#9670;&nbsp;</a></span>guild_template_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_template_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syncs the template to the guild's current state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild to synchronise template for </td></tr>
    <tr><td class="paramname">code</td><td>Code of template to synchronise </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1faa321ede15b209c789ea1155a3d356" name="a1faa321ede15b209c789ea1155a3d356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faa321ede15b209c789ea1155a3d356">&#9670;&nbsp;</a></span>guild_templates_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::guild_templates_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get guild templates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get templates for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a0d9e1952e25391a3379ee3db2d930bf7">dpp::guild_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c92a68228fe9dcb96b1c7cb6b8ae795" name="a4c92a68228fe9dcb96b1c7cb6b8ae795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c92a68228fe9dcb96b1c7cb6b8ae795">&#9670;&nbsp;</a></span>interaction_response_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::interaction_response_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>interaction_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1interaction__response.html">interaction_response</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Respond to a slash command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interaction_id</td><td>Interaction id to respond to </td></tr>
    <tr><td class="paramname">token</td><td>Token for the interaction webhook </td></tr>
    <tr><td class="paramname">r</td><td>Response to send </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41c9c18dd9185dfc2cc61b463ad7cf0f" name="a41c9c18dd9185dfc2cc61b463ad7cf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c9c18dd9185dfc2cc61b463ad7cf0f">&#9670;&nbsp;</a></span>interaction_response_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::interaction_response_edit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Respond to a slash command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Token for the interaction webhook </td></tr>
    <tr><td class="paramname">r</td><td>Message to send </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c22698fbbb32edebd9824309015a017" name="a4c22698fbbb32edebd9824309015a017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c22698fbbb32edebd9824309015a017">&#9670;&nbsp;</a></span>invite_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::invite_delete </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>invite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an invite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invite</td><td>Invite code to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a4d4220a93d6ba8c72d5472fd6718d0" name="a4a4d4220a93d6ba8c72d5472fd6718d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4d4220a93d6ba8c72d5472fd6718d0">&#9670;&nbsp;</a></span>invite_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::invite_get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>invite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get details about an invite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invite</td><td>Invite code to get information on </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1invite.html" title="Represents an invite to a discord guild or channel.">dpp::invite</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13689440c9cc80279d415c563a6363c0" name="a13689440c9cc80279d415c563a6363c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13689440c9cc80279d415c563a6363c0">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a7d48d478ccc3bffb34637bdb48f629c2">dpp::loglevel</a>&#160;</td>
          <td class="paramname"><em>severity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log a message to whatever log the user is using. The logged message is passed up the chain to the on_log event in user code which can then do whatever it wants to do with it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">severity</td><td>The log level from <a class="el" href="namespacedpp.html#a7d48d478ccc3bffb34637bdb48f629c2" title="Log levels.">dpp::loglevel</a> </td></tr>
    <tr><td class="paramname">msg</td><td>The log message to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08eb4e0352a29a92587d677d4b5fd6a7" name="a08eb4e0352a29a92587d677d4b5fd6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eb4e0352a29a92587d677d4b5fd6a7">&#9670;&nbsp;</a></span>message_add_reaction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_add_reaction </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a reaction to a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to add a reaction to </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to add. Emojis should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c38aa5a7737577fbafcd67a783c60d1" name="a8c38aa5a7737577fbafcd67a783c60d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c38aa5a7737577fbafcd67a783c60d1">&#9670;&nbsp;</a></span>message_add_reaction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_add_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a reaction to a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to add reactions to </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to add reactions to </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to add. Emojis should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a080a8cefc6ceb0b882fdb6fe70c078a6" name="a080a8cefc6ceb0b882fdb6fe70c078a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080a8cefc6ceb0b882fdb6fe70c078a6">&#9670;&nbsp;</a></span>message_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_create </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to a channel. The callback function is called when the message has been sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to send </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cdf2c55ac48902e7b194ab8e651d869" name="a8cdf2c55ac48902e7b194ab8e651d869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdf2c55ac48902e7b194ab8e651d869">&#9670;&nbsp;</a></span>message_crosspost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_crosspost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crosspost a message. The callback function is called when the message has been sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to crosspost </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel ID to crosspost from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb75919ec5abd5b510255692ef439f97" name="abb75919ec5abd5b510255692ef439f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb75919ec5abd5b510255692ef439f97">&#9670;&nbsp;</a></span>message_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a message from a channel. The callback function is called when the message has been edited. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message ID to delete </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13ae40b4389928ce8e6f8d9b47512291" name="a13ae40b4389928ce8e6f8d9b47512291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ae40b4389928ce8e6f8d9b47512291">&#9670;&nbsp;</a></span>message_delete_all_reactions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_all_reactions </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all reactions on a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a253f894d05325a56d85663a4759288a2" name="a253f894d05325a56d85663a4759288a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253f894d05325a56d85663a4759288a2">&#9670;&nbsp;</a></span>message_delete_all_reactions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_all_reactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all reactions on a message by id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete reactions from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4534c2c87bf45c326b126ef0a00ee80" name="ab4534c2c87bf45c326b126ef0a00ee80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4534c2c87bf45c326b126ef0a00ee80">&#9670;&nbsp;</a></span>message_delete_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_bulk </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>message_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk delete messages from a channel. The callback function is called when the message has been edited. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_ids</td><td>List of message IDs to delete (maximum of 100 message IDs) </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete from </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba9abca51107d5aed147fa9b0aa8d675" name="aba9abca51107d5aed147fa9b0aa8d675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9abca51107d5aed147fa9b0aa8d675">&#9670;&nbsp;</a></span>message_delete_own_reaction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_own_reaction </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete own reaction from a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to delete own reaction from </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to delete. The reaction should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b18295b9fc438b84c21cc5dd60db8db" name="a3b18295b9fc438b84c21cc5dd60db8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b18295b9fc438b84c21cc5dd60db8db">&#9670;&nbsp;</a></span>message_delete_own_reaction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_own_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete own reaction from a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete reactions from </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to delete. The reaction should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72b04160e95d808013fe222a9b690dae" name="a72b04160e95d808013fe222a9b690dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b04160e95d808013fe222a9b690dae">&#9670;&nbsp;</a></span>message_delete_reaction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_reaction </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a user's reaction from a message. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to delete a user's reaction from </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID who's reaction you want to remove </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to remove. Reactions should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b157698d6c65e96a6a96ef93fee9f56" name="a0b157698d6c65e96a6a96ef93fee9f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b157698d6c65e96a6a96ef93fee9f56">&#9670;&nbsp;</a></span>message_delete_reaction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a user's reaction from a message by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete reactions from </td></tr>
    <tr><td class="paramname">user_id</td><td>User ID who's reaction you want to remove </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to remove. Reactions should be in the form emojiname:id </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a1478ca3f0fb3c645a34474099e4e04" name="a6a1478ca3f0fb3c645a34474099e4e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1478ca3f0fb3c645a34474099e4e04">&#9670;&nbsp;</a></span>message_delete_reaction_emoji() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_reaction_emoji </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all reactions on a message using a particular emoji. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to delete, in the form emojiname:id or a unicode character </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a144ffe65c0dda699e586f78c61649bf5" name="a144ffe65c0dda699e586f78c61649bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144ffe65c0dda699e586f78c61649bf5">&#9670;&nbsp;</a></span>message_delete_reaction_emoji() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_delete_reaction_emoji </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all reactions on a message using a particular emoji by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to delete reactions from </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to delete reactions from </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction to delete, in the form emojiname:id or a unicode character </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a754206a7e97f1aaab4ab83ed53e4f351" name="a754206a7e97f1aaab4ab83ed53e4f351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754206a7e97f1aaab4ab83ed53e4f351">&#9670;&nbsp;</a></span>message_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_edit </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a message on a channel. The callback function is called when the message has been edited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d3b0f7c3dae4ecb1980cabe8f10ccd7" name="a9d3b0f7c3dae4ecb1980cabe8f10ccd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3b0f7c3dae4ecb1980cabe8f10ccd7">&#9670;&nbsp;</a></span>message_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message ID </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel ID </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1message.html" title="Represents messages sent and received on Discord.">dpp::message</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab05fea3d6c298d5f2371704084383f8f" name="ab05fea3d6c298d5f2371704084383f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05fea3d6c298d5f2371704084383f8f">&#9670;&nbsp;</a></span>message_get_reactions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_get_reactions </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdpp_1_1message.html">message</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get reactions on a message for a particular emoji. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Message to get reactions for </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction should be in the form emojiname:id or a unicode character </td></tr>
    <tr><td class="paramname">before</td><td>Reactions before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">after</td><td>Reactions before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">limit</td><td>This number of reactions maximum should be returned </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1c4073c92e19579c06591033a4a234e1">dpp::user_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06083a6cacaf7c4e41884cfb2a1078ab" name="a06083a6cacaf7c4e41884cfb2a1078ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06083a6cacaf7c4e41884cfb2a1078ab">&#9670;&nbsp;</a></span>message_get_reactions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_get_reactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get reactions on a message for a particular emoji by id. The reaction string must be either an <code>emojiname:id</code> or a unicode character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_id</td><td>Message to get reactions for </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel to get reactions for </td></tr>
    <tr><td class="paramname">reaction</td><td>Reaction should be in the form emojiname:id or a unicode character </td></tr>
    <tr><td class="paramname">before</td><td>Reactions before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">after</td><td>Reactions before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">limit</td><td>This number of reactions maximum should be returned </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a1c4073c92e19579c06591033a4a234e1">dpp::user_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa140a11ab0b2feede600761aaee2483b" name="aa140a11ab0b2feede600761aaee2483b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa140a11ab0b2feede600761aaee2483b">&#9670;&nbsp;</a></span>message_pin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_pin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pin a message. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel id to pin message on </td></tr>
    <tr><td class="paramname">message_id</td><td>Message id to pin message on </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a454e53cea10416ca9d299855dbb08e0b" name="a454e53cea10416ca9d299855dbb08e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454e53cea10416ca9d299855dbb08e0b">&#9670;&nbsp;</a></span>message_unpin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::message_unpin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpin a message. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel id to unpin message on </td></tr>
    <tr><td class="paramname">message_id</td><td>Message id to unpin message on </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a630d744322d1f570a63f33ae10b23ae9" name="a630d744322d1f570a63f33ae10b23ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630d744322d1f570a63f33ae10b23ae9">&#9670;&nbsp;</a></span>messages_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::messages_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>around</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get multiple messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel ID to retrieve messages for </td></tr>
    <tr><td class="paramname">around</td><td>Messages should be retrieved around this ID if this is set to non-zero </td></tr>
    <tr><td class="paramname">before</td><td>Messages before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">after</td><td>Messages before this ID should be retrieved if this is set to non-zero </td></tr>
    <tr><td class="paramname">limit</td><td>This number of messages maximum should be returned </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#a44d4dd39b5d7c24c5fe97a76a73cf708">dpp::message_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a115a49075ceb1817f1e81fc9388bf65e" name="a115a49075ceb1817f1e81fc9388bf65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115a49075ceb1817f1e81fc9388bf65e">&#9670;&nbsp;</a></span>nitro_sticker_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::nitro_sticker_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a nitro sticker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of sticker to get. </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62b83ee3be02df68eb5e697ddc5efc0a" name="a62b83ee3be02df68eb5e697ddc5efc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b83ee3be02df68eb5e697ddc5efc0a">&#9670;&nbsp;</a></span>post_rest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::post_rest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>major_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a805ef1feb2862a208ec0e9d1be005c88">http_method</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#aafc7fb6792b12d92c4e77b46d20924ee">json_encode_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filecontent</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a REST request. Where possible use a helper method instead like message_create. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to post to, e.g. /api/guilds </td></tr>
    <tr><td class="paramname">major_parameters</td><td>Major parameters for the endpoint e.g. a guild id </td></tr>
    <tr><td class="paramname">parameters</td><td>Minor parameters for the API request </td></tr>
    <tr><td class="paramname">method</td><td>Method, e.g. GET, POST </td></tr>
    <tr><td class="paramname">postdata</td><td>Post data (usually JSON encoded) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the HTTP call completes. The callback parameter will contain amongst other things, the decoded json. </td></tr>
    <tr><td class="paramname">filename</td><td>Filename to post for POST requests (for uploading files) </td></tr>
    <tr><td class="paramname">filecontent</td><td>File content to post for POST requests (for uploading files) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a156fe68358c421111e690f553c4e4f52" name="a156fe68358c421111e690f553c4e4f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156fe68358c421111e690f553c4e4f52">&#9670;&nbsp;</a></span>request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::request </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a805ef1feb2862a208ec0e9d1be005c88">http_method</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#ae3249e99494d04bb4be50341f474621e">http_completion_event</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postdata</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mimetype</em> = <code>&quot;text/plain&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::multimap&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>headers</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a HTTP(S) request. For use when wanting asnyncronous access to HTTP APIs outside of Discord. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Endpoint to post to, e.g. /api/guilds </td></tr>
    <tr><td class="paramname">method</td><td>Method, e.g. GET, POST </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the HTTP call completes. No processing is done on the returned data. </td></tr>
    <tr><td class="paramname">postdata</td><td>POST data </td></tr>
    <tr><td class="paramname">mimetype</td><td>MIME type of POST data </td></tr>
    <tr><td class="paramname">headers</td><td>Headers to send with the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab912eb28e9bb4df46954c7a9b93b283d" name="ab912eb28e9bb4df46954c7a9b93b283d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab912eb28e9bb4df46954c7a9b93b283d">&#9670;&nbsp;</a></span>role_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::role_create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a role on a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Role to create (guild ID is encapsulated in the role object) </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1role.html" title="Represents a role within a dpp::guild. Roles are combined via logical OR of the permission bitmasks,...">dpp::role</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45414d0d189edd147c3d76b4480ec0b8" name="a45414d0d189edd147c3d76b4480ec0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45414d0d189edd147c3d76b4480ec0b8">&#9670;&nbsp;</a></span>role_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::role_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>role_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a role. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to delete the role on </td></tr>
    <tr><td class="paramname">role_id</td><td>Role ID to delete </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24cc5286955e6641d574d232d8b47f55" name="a24cc5286955e6641d574d232d8b47f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cc5286955e6641d574d232d8b47f55">&#9670;&nbsp;</a></span>role_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::role_edit </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a role on a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Role to edit </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1role.html" title="Represents a role within a dpp::guild. Roles are combined via logical OR of the permission bitmasks,...">dpp::role</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac77932ee797aeb44098c2013811b2887" name="ac77932ee797aeb44098c2013811b2887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77932ee797aeb44098c2013811b2887">&#9670;&nbsp;</a></span>role_edit_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::role_edit_position </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1role.html">role</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a role's position in a guild. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Role to change position of </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1role.html" title="Represents a role within a dpp::guild. Roles are combined via logical OR of the permission bitmasks,...">dpp::role</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a884dbb70619fcf92b06577dea8093219" name="a884dbb70619fcf92b06577dea8093219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884dbb70619fcf92b06577dea8093219">&#9670;&nbsp;</a></span>roles_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::roles_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>guild_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a role for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guild_id</td><td>Guild ID to get role for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="namespacedpp.html#adb1c0770936ed4ac64158cf9523e638b">dpp::role_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbcc02c388c197cf7050551ef89aeefe" name="adbcc02c388c197cf7050551ef89aeefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcc02c388c197cf7050551ef89aeefe">&#9670;&nbsp;</a></span>set_audit_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp; dpp::cluster::set_audit_reason </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the audit log reason for the next REST call to be made. This is set per-thread, so you must ensure that if you call this method, your request that is associated with the reason happens on the same thread where you set the reason. Once the next call is made, the audit log reason is cleared for this thread automatically. </p>
<p >Example: </p><div class="fragment"><div class="line">bot.set_audit_reason(<span class="stringliteral">&quot;Too much abusive content&quot;</span>)</div>
<div class="line">   .channel_delete(my_channel_id);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>The reason to set for the next REST call on this thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cluster&amp; Reference to self for chaining. </dd></dl>

</div>
</div>
<a id="a3fc501cc0ebb334d09a7f4bb1ea6b3e6" name="a3fc501cc0ebb334d09a7f4bb1ea6b3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc501cc0ebb334d09a7f4bb1ea6b3e6">&#9670;&nbsp;</a></span>set_dm_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::set_dm_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the dm channel id for a user id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_id</td><td>user id to set the dm channel for </td></tr>
    <tr><td class="paramname">channel_id</td><td>dm channel to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b67c9455ac0378712e4c0fd0ba7f2a9" name="a9b67c9455ac0378712e4c0fd0ba7f2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b67c9455ac0378712e4c0fd0ba7f2a9">&#9670;&nbsp;</a></span>set_presence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::set_presence </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classdpp_1_1presence.html">dpp::presence</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the presence for all shards on the cluster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The presence to set. Only the online status and the first activity are sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a056e4191c03dd210c2a410b6599a0bf9" name="a056e4191c03dd210c2a410b6599a0bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056e4191c03dd210c2a410b6599a0bf9">&#9670;&nbsp;</a></span>set_websocket_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1cluster.html">cluster</a> &amp; dpp::cluster::set_websocket_protocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#af7cde3079d745428f44ef6231a2ac672">websocket_protocol_t</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the websocket protocol for all shards on this cluster. You should call this method before <a class="el" href="classdpp_1_1cluster.html#a40e99d13e1380eccd30d13123014594f" title="Start the cluster, connecting all its shards. Returns once all shards are connected.">cluster::start</a>. Generally ws_etf is faster, but provides less facilities for debugging should something go wrong. It is recommended to use ETF in production and JSON in development. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>websocket protocol to use, either ws_json or ws_etf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cluster&amp; Reference to self for chaining. </dd></dl>

</div>
</div>
<a id="a5fe69055dc2ee16d08e693df11fec75a" name="a5fe69055dc2ee16d08e693df11fec75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe69055dc2ee16d08e693df11fec75a">&#9670;&nbsp;</a></span>stage_instance_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::stage_instance_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1stage__instance.html">stage_instance</a> &amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stage instance on a stage channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Stage instance to create </td></tr>
    <tr><td class="paramname">callback</td><td>User function to execute when the api call completes On success the callback will contain a <a class="el" href="structdpp_1_1stage__instance.html" title="A stage instance. Stage instances are like a conference facility, with moderators/speakers and listen...">dpp::stage_instance</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method. </dd></dl>

</div>
</div>
<a id="a9f8c2ba02d51ad166f90300ab5b53ecb" name="a9f8c2ba02d51ad166f90300ab5b53ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8c2ba02d51ad166f90300ab5b53ecb">&#9670;&nbsp;</a></span>stage_instance_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::stage_instance_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a stage instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>ID of the associated channel </td></tr>
    <tr><td class="paramname">callback</td><td>User function to execute when the api call completes On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method. </dd></dl>

</div>
</div>
<a id="af4e1b1edb3094c7d220a3a80323bbe17" name="af4e1b1edb3094c7d220a3a80323bbe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e1b1edb3094c7d220a3a80323bbe17">&#9670;&nbsp;</a></span>stage_instance_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::stage_instance_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdpp_1_1stage__instance.html">stage_instance</a> &amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit a stage instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Stage instance to edit </td></tr>
    <tr><td class="paramname">callback</td><td>User function to execute when the api call completes On success the callback will contain a <a class="el" href="structdpp_1_1stage__instance.html" title="A stage instance. Stage instances are like a conference facility, with moderators/speakers and listen...">dpp::stage_instance</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method. </dd></dl>

</div>
</div>
<a id="a1edd6ac5d8553b4823465bebadfaa9af" name="a1edd6ac5d8553b4823465bebadfaa9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edd6ac5d8553b4823465bebadfaa9af">&#9670;&nbsp;</a></span>stage_instance_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::stage_instance_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the stage instance associated with the channel id, if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>ID of the associated channel </td></tr>
    <tr><td class="paramname">callback</td><td>User function to execute when the api call completes On success the callback will contain a <a class="el" href="structdpp_1_1stage__instance.html" title="A stage instance. Stage instances are like a conference facility, with moderators/speakers and listen...">dpp::stage_instance</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40e99d13e1380eccd30d13123014594f" name="a40e99d13e1380eccd30d13123014594f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e99d13e1380eccd30d13123014594f">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::start </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_after</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the cluster, connecting all its shards. Returns once all shards are connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">return_after</td><td>If true the bot will return to your program after starting shards, if false this function will never return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a87a674519512fbf96b59f9b9cb8bb5" name="a2a87a674519512fbf96b59f9b9cb8bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a87a674519512fbf96b59f9b9cb8bb5">&#9670;&nbsp;</a></span>start_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#a8b9ab0b8cf29978147a7df3947cd8f30">timer</a> dpp::cluster::start_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a13d8465c3c643fdd87405fd115cd4964">timer_callback_t</a>&#160;</td>
          <td class="paramname"><em>on_tick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a13d8465c3c643fdd87405fd115cd4964">timer_callback_t</a>&#160;</td>
          <td class="paramname"><em>on_stop</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a timer. Every <code>frequency</code> seconds, the callback is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_tick</td><td>The callback lambda to call for this timer when ticked </td></tr>
    <tr><td class="paramname">on_stop</td><td>The callback lambda to call for this timer when it is stopped </td></tr>
    <tr><td class="paramname">frequency</td><td>How often to tick the timer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timer A handle to the timer, used to remove that timer later </dd></dl>

</div>
</div>
<a id="ae64421a4b2402238feb0536639009c18" name="ae64421a4b2402238feb0536639009c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64421a4b2402238feb0536639009c18">&#9670;&nbsp;</a></span>sticker_packs_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::sticker_packs_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get sticker packs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1sticker.html" title="Represents stickers received in messages.">dpp::sticker</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a065dbc305d760d94f4ce0867f64777a3" name="a065dbc305d760d94f4ce0867f64777a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065dbc305d760d94f4ce0867f64777a3">&#9670;&nbsp;</a></span>stop_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dpp::cluster::stop_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a8b9ab0b8cf29978147a7df3947cd8f30">timer</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop a ticking timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Timer handle received from <a class="el" href="classdpp_1_1cluster.html#a2a87a674519512fbf96b59f9b9cb8bb5" title="Start a timer. Every frequency seconds, the callback is called.">cluster::start_timer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the timer was stopped, false if it did not exist </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the timer has an on_stop lambda, the on_stop lambda will be called. </dd></dl>

</div>
</div>
<a id="a52366e37144b166c6a2c773e14992b21" name="a52366e37144b166c6a2c773e14992b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52366e37144b166c6a2c773e14992b21">&#9670;&nbsp;</a></span>template_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::template_get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Template code </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1guild.html" title="Represents a guild on Discord (AKA a server)">dpp::guild</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62fc5594e7d2dabcc03e9ef031a361db" name="a62fc5594e7d2dabcc03e9ef031a361db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62fc5594e7d2dabcc03e9ef031a361db">&#9670;&nbsp;</a></span>thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>thread_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>auto_archive_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a8af3a726df107c304139477dbfa42092">channel_type</a>&#160;</td>
          <td class="paramname"><em>thread_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invitable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rate_limit_per_user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread. </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_name</td><td>Name of the thread </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel in which thread to create </td></tr>
    <tr><td class="paramname">auto_archive_duration</td><td>Duration after which thread auto-archives. Can be set to - 60, 1440 (for boosted guilds can also be: 4320, 10080) </td></tr>
    <tr><td class="paramname">thread_type</td><td>Type of thread - GUILD_PUBLIC_THREAD, GUILD_NEWS_THREAD, GUILD_PRIVATE_THREAD </td></tr>
    <tr><td class="paramname">invitable</td><td>whether non-moderators can add other non-moderators to a thread; only available when creating a private thread </td></tr>
    <tr><td class="paramname">rate_limit_per_user</td><td>amount of seconds a user has to wait before sending another message (0-21600); bots, as well as users with the permission manage_messages, manage_thread, or manage_channel, are unaffected </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1thread.html" title="A definition of a discord thread. A thread is a superset of a channel. Not to be confused with std::t...">dpp::thread</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacc314e4918852cc217b473ff9d95ddc" name="aacc314e4918852cc217b473ff9d95ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc314e4918852cc217b473ff9d95ddc">&#9670;&nbsp;</a></span>thread_create_with_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_create_with_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>thread_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>message_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>auto_archive_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rate_limit_per_user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread with a message (Discord: ID of a thread is same as message ID) </p>
<dl class="section note"><dt>Note</dt><dd>This method supports audit log reasons set by the <a class="el" href="classdpp_1_1cluster.html#adbcc02c388c197cf7050551ef89aeefe" title="Set the audit log reason for the next REST call to be made. This is set per-thread,...">cluster::set_audit_reason()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_name</td><td>Name of the thread </td></tr>
    <tr><td class="paramname">channel_id</td><td>Channel in which thread to create </td></tr>
    <tr><td class="paramname">message_id</td><td>message to start thread with </td></tr>
    <tr><td class="paramname">auto_archive_duration</td><td>Duration after which thread auto-archives. Can be set to - 60, 1440 (for boosted guilds can also be: 4320, 10080) </td></tr>
    <tr><td class="paramname">rate_limit_per_user</td><td>amount of seconds a user has to wait before sending another message (0-21600); bots, as well as users with the permission manage_messages, manage_thread, or manage_channel, are unaffected </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1thread.html" title="A definition of a discord thread. A thread is a superset of a channel. Not to be confused with std::t...">dpp::thread</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a066a4a71deac82b823757c2c80479a5d" name="a066a4a71deac82b823757c2c80479a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066a4a71deac82b823757c2c80479a5d">&#9670;&nbsp;</a></span>thread_member_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_member_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a member to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread ID to add to </td></tr>
    <tr><td class="paramname">user_id</td><td>Member ID to add </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad39edec2f1389d1aa5bb6c09e4318b6a" name="ad39edec2f1389d1aa5bb6c09e4318b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39edec2f1389d1aa5bb6c09e4318b6a">&#9670;&nbsp;</a></span>thread_member_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_member_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a thread member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread to get member for </td></tr>
    <tr><td class="paramname">user_id</td><td>ID of the user to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="structdpp_1_1thread__member.html" title="represents membership of a user with a thread">dpp::thread_member</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad253c2a68c5a1e78b880da7252a15814" name="ad253c2a68c5a1e78b880da7252a15814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad253c2a68c5a1e78b880da7252a15814">&#9670;&nbsp;</a></span>thread_member_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_member_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a member from a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread ID to remove from </td></tr>
    <tr><td class="paramname">user_id</td><td>Member ID to remove </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="structdpp_1_1confirmation.html" title="Confirmation object represents any true or false simple REST request.">dpp::confirmation</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a636b55f518a2e724eabf31453aa89abe" name="a636b55f518a2e724eabf31453aa89abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636b55f518a2e724eabf31453aa89abe">&#9670;&nbsp;</a></span>thread_members_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::thread_members_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get members of a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>Thread to get members for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="namespacedpp.html#a57e84724c41fed341bee0d653a06076a" title="A group of thread member objects.">dpp::thread_member_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6825c29651e995f251e01f5a1f20122d" name="a6825c29651e995f251e01f5a1f20122d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6825c29651e995f251e01f5a1f20122d">&#9670;&nbsp;</a></span>threads_get_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::threads_get_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get active threads in a channel (Sorted by ID in descending order) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to get active threads for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="namespacedpp.html#afb8eae726b5ea68baff8c48d7fb835af" title="A group of threads.">dpp::thread_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d0c3894cd560fa7871f22d7cfb8f591" name="a0d0c3894cd560fa7871f22d7cfb8f591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0c3894cd560fa7871f22d7cfb8f591">&#9670;&nbsp;</a></span>threads_get_joined_private_archived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::threads_get_joined_private_archived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>before_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get private archived threads in a channel which current user has joined (Sorted by ID in descending order) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to get public archived threads for </td></tr>
    <tr><td class="paramname">before_id</td><td>Get threads before this id </td></tr>
    <tr><td class="paramname">limit</td><td>Number of threads to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="namespacedpp.html#afb8eae726b5ea68baff8c48d7fb835af" title="A group of threads.">dpp::thread_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8336e48eaabaeb8df4d69a087982e82" name="ae8336e48eaabaeb8df4d69a087982e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8336e48eaabaeb8df4d69a087982e82">&#9670;&nbsp;</a></span>threads_get_private_archived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::threads_get_private_archived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>before_timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get private archived threads in a channel (Sorted by archive_timestamp in descending order) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to get public archived threads for </td></tr>
    <tr><td class="paramname">before_timestamp</td><td>Get threads before this timestamp </td></tr>
    <tr><td class="paramname">limit</td><td>Number of threads to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="namespacedpp.html#afb8eae726b5ea68baff8c48d7fb835af" title="A group of threads.">dpp::thread_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b93e8be30c7e954c27e19d8b7fa8170" name="a2b93e8be30c7e954c27e19d8b7fa8170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b93e8be30c7e954c27e19d8b7fa8170">&#9670;&nbsp;</a></span>threads_get_public_archived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::threads_get_public_archived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>channel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>before_timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get public archived threads in a channel (Sorted by archive_timestamp in descending order) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to get public archived threads for </td></tr>
    <tr><td class="paramname">before_timestamp</td><td>Get threads before this timestamp </td></tr>
    <tr><td class="paramname">limit</td><td>Number of threads to get </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes On success the callback will contain a <a class="el" href="namespacedpp.html#afb8eae726b5ea68baff8c48d7fb835af" title="A group of threads.">dpp::thread_map</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af12b5b33ea156bde9977796858066a6b" name="af12b5b33ea156bde9977796858066a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12b5b33ea156bde9977796858066a6b">&#9670;&nbsp;</a></span>uptime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdpp_1_1utility_1_1uptime.html">dpp::utility::uptime</a> dpp::cluster::uptime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uptime of the cluster. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structdpp_1_1utility_1_1uptime.html" title="A class used to represent an uptime in hours, minutes, seconds and days, with helper functions to con...">dpp::utility::uptime</a> The uptime of the cluster </dd></dl>

</div>
</div>
<a id="a73483dbeb0f1946dc18b1d0a5331b0d0" name="a73483dbeb0f1946dc18b1d0a5331b0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73483dbeb0f1946dc18b1d0a5331b0d0">&#9670;&nbsp;</a></span>user_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dpp::cluster::user_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a0dec2a52b080906aebfd3e1b3db02475">snowflake</a>&#160;</td>
          <td class="paramname"><em>user_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedpp.html#a022dce6b086ec4515384eaece59c84c3">command_completion_event_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a user by id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_id</td><td>User ID to retrieve </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when the API call completes. On success the callback will contain a <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">dpp::user_identified</a> object in <a class="el" href="structdpp_1_1confirmation__callback__t.html#a4725ef83209a64c0558a598ec01ad463">confirmation_callback_t::value</a>. On failure, the value is undefined and <a class="el" href="structdpp_1_1confirmation__callback__t.html#a17820d5f9fb0725d64a1bf23c8cc97c7" title="Returns true if the call resulted in an error rather than a legitimate value in the confirmation_call...">confirmation_callback_t::is_error()</a> method will return true. You can obtain full error details with <a class="el" href="structdpp_1_1confirmation__callback__t.html#a79dda1493a0788577d84a8ad82cf7e55" title="Get the error_info object. The error_info object contains the details of any REST error,...">confirmation_callback_t::get_error()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">user_identified</a> object is a subclass of <a class="el" href="classdpp_1_1user.html" title="Represents a user on discord. May or may not be a member of a dpp::guild.">dpp::user</a> which contains further details if you have the oauth2 identify or email scopes. If you do not have these scopes, these fields are empty. You can safely convert a <a class="el" href="classdpp_1_1user__identified.html" title="A user with additional fields only available via the oauth2 identify scope. These are not included in...">user_identified</a> to user with <code>dynamic_cast</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab0d2c95628830a28f9abb09441914e40" name="ab0d2c95628830a28f9abb09441914e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d2c95628830a28f9abb09441914e40">&#9670;&nbsp;</a></span>discord_client</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdpp_1_1discord__client.html">discord_client</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9fae28f81712be86530fe3314d166ad3" name="a9fae28f81712be86530fe3314d166ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fae28f81712be86530fe3314d166ad3">&#9670;&nbsp;</a></span>cache_policy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdpp_1_1cache__policy__t.html">cache_policy_t</a> dpp::cluster::cache_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current cache policy for the cluster. </p>

</div>
</div>
<a id="a5155862c1d7267c7f4ee8781ff3e8d7f" name="a5155862c1d7267c7f4ee8781ff3e8d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5155862c1d7267c7f4ee8781ff3e8d7f">&#9670;&nbsp;</a></span>cluster_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dpp::cluster::cluster_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ID of this cluster, between 0 and MAXCLUSTERS-1 inclusive </p>

</div>
</div>
<a id="a239af1e13449c85658fb37e6589745a0" name="a239af1e13449c85658fb37e6589745a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239af1e13449c85658fb37e6589745a0">&#9670;&nbsp;</a></span>intents</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dpp::cluster::intents</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Current bitmask of gateway intents </p>

</div>
</div>
<a id="a32ce7fc13658a25e2faeadcd36282b0b" name="a32ce7fc13658a25e2faeadcd36282b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ce7fc13658a25e2faeadcd36282b0b">&#9670;&nbsp;</a></span>last_identify</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t dpp::cluster::last_identify</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad80e4df300e69988d163d61c14e540ab" name="ad80e4df300e69988d163d61c14e540ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80e4df300e69988d163d61c14e540ab">&#9670;&nbsp;</a></span>maxclusters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dpp::cluster::maxclusters</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Total number of clusters that are active </p>

</div>
</div>
<a id="ad31317a40181f6864646c8758871b495" name="ad31317a40181f6864646c8758871b495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31317a40181f6864646c8758871b495">&#9670;&nbsp;</a></span>me</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1user.html">dpp::user</a> dpp::cluster::me</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The details of the bot user. This is assumed to be identical across all shards in the cluster. Each connecting shard updates this information. </p>

</div>
</div>
<a id="a7418aa521c49af80822039b013d8d004" name="a7418aa521c49af80822039b013d8d004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7418aa521c49af80822039b013d8d004">&#9670;&nbsp;</a></span>numshards</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dpp::cluster::numshards</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Total number of shards across all clusters </p>

</div>
</div>
<a id="afc8bbb63ca756c719f36ff1c6340d754" name="afc8bbb63ca756c719f36ff1c6340d754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8bbb63ca756c719f36ff1c6340d754">&#9670;&nbsp;</a></span>on_application_command_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1application__command__create__t.html">application_command_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_application_command_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new application command (slash command) is registered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_application_command_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1application__command__create__t.html" title="Create application slash command.">dpp::application_command_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ae349c245c7fa002090b95fd66b88f2a5" name="ae349c245c7fa002090b95fd66b88f2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae349c245c7fa002090b95fd66b88f2a5">&#9670;&nbsp;</a></span>on_application_command_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1application__command__delete__t.html">application_command_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_application_command_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an application command (slash command) is deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_application_command_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1application__command__delete__t.html" title="Application slash command deleted.">dpp::application_command_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ae8f3fb072c9a1a92e680938431477e65" name="ae8f3fb072c9a1a92e680938431477e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f3fb072c9a1a92e680938431477e65">&#9670;&nbsp;</a></span>on_application_command_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1application__command__update__t.html">application_command_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_application_command_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an application command (slash command) is updated. You will only receive this event for application commands that belong to your bot/application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_application_command_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1application__command__update__t.html" title="Update application slash command.">dpp::application_command_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a934bbe75a3c0806262189be1a9038845" name="a934bbe75a3c0806262189be1a9038845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934bbe75a3c0806262189be1a9038845">&#9670;&nbsp;</a></span>on_autocomplete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1autocomplete__t.html">autocomplete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_autocomplete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an auto completed field needs suggestions to present to the user This is triggered by discord when option choices have auto completion enabled which you have associated with a <a class="el" href="classdpp_1_1slashcommand.html" title="Represents an application command, created by your bot either globally, or on a guild.">dpp::slashcommand</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_autocomplete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1autocomplete__t.html" title="Discord requests that we fill a list of auto completion choices for a command option.">dpp::autocomplete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aa178115555d4db7353f0ee05b3d62902" name="aa178115555d4db7353f0ee05b3d62902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa178115555d4db7353f0ee05b3d62902">&#9670;&nbsp;</a></span>on_button_click</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1button__click__t.html">button_click_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_button_click</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a button is clicked attached to a message. Button clicks are triggered by discord when buttons are clicked which you have associated with a message using <a class="el" href="classdpp_1_1component.html" title="Represents the component object. A component is a clickable button or drop down list within a discord...">dpp::component</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_button_click</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1button__click__t.html" title="Click on button.">dpp::button_click_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a156195841560c2e1b1764dfb06b83bdc" name="a156195841560c2e1b1764dfb06b83bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156195841560c2e1b1764dfb06b83bdc">&#9670;&nbsp;</a></span>on_channel_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1channel__create__t.html">channel_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_channel_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new channel is created on a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1channel__create__t.html" title="Create channel.">dpp::channel_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="af77d4a1c6718d1371d53844ec49235c4" name="af77d4a1c6718d1371d53844ec49235c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77d4a1c6718d1371d53844ec49235c4">&#9670;&nbsp;</a></span>on_channel_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1channel__delete__t.html">channel_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_channel_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a channel is deleted from a guild. The channel will still be temporarily avaialble in the cache. Pointers to the channel should not be retained long-term as they will be deleted by the garbage collector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1channel__delete__t.html" title="Delete channel.">dpp::channel_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad3af28a32fb05848d0e975768155999a" name="ad3af28a32fb05848d0e975768155999a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3af28a32fb05848d0e975768155999a">&#9670;&nbsp;</a></span>on_channel_pins_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1channel__pins__update__t.html">channel_pins_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_channel_pins_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a message is pinned. Note that the pinned message is not returned to this event, just the timestamp of the last pinned message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_pins_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1channel__pins__update__t.html" title="Channel pins update.">dpp::channel_pins_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a14d6e3d756c10174c23e58ffe2cf97ba" name="a14d6e3d756c10174c23e58ffe2cf97ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d6e3d756c10174c23e58ffe2cf97ba">&#9670;&nbsp;</a></span>on_channel_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1channel__update__t.html">channel_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_channel_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a channel is edited on a guild. The new channel details have already been applied to the guild when you receive this event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_channel_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1channel__update__t.html" title="Update channel.">dpp::channel_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="af2e24648afcfecd1456e5cb6bfcb4ac6" name="af2e24648afcfecd1456e5cb6bfcb4ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e24648afcfecd1456e5cb6bfcb4ac6">&#9670;&nbsp;</a></span>on_guild_ban_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__ban__add__t.html">guild_ban_add_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_ban_add</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a ban is added to a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_ban_add</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__ban__add__t.html" title="Guild ban add.">dpp::guild_ban_add_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a4652a0d7d8471ffb4885a70b26461d07" name="a4652a0d7d8471ffb4885a70b26461d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4652a0d7d8471ffb4885a70b26461d07">&#9670;&nbsp;</a></span>on_guild_ban_remove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__ban__remove__t.html">guild_ban_remove_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_ban_remove</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a ban is removed from a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_ban_remove</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__ban__remove__t.html" title="Guild ban remove.">dpp::guild_ban_remove_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ab52ce8b7ef61c41773b1b38e46f6cc21" name="ab52ce8b7ef61c41773b1b38e46f6cc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52ce8b7ef61c41773b1b38e46f6cc21">&#9670;&nbsp;</a></span>on_guild_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__create__t.html">guild_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new guild is created. D++ will request members for the guild for its cache using guild_members_chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__create__t.html" title="Create guild.">dpp::guild_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a222659a0402e17e4900f8bdcf46d60a7" name="a222659a0402e17e4900f8bdcf46d60a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222659a0402e17e4900f8bdcf46d60a7">&#9670;&nbsp;</a></span>on_guild_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__delete__t.html">guild_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a guild is deleted. A guild can be deleted via the bot being kicked, the bot leaving the guild explicitly with dpp::guild_delete, or via the guild being unavaialble due to an outage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__delete__t.html" title="Delete guild.">dpp::guild_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a2e0ffdd605394dd9cc10fd58f2b691d5" name="a2e0ffdd605394dd9cc10fd58f2b691d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0ffdd605394dd9cc10fd58f2b691d5">&#9670;&nbsp;</a></span>on_guild_emojis_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__emojis__update__t.html">guild_emojis_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_emojis_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new emojis are added to a guild. The complete set of emojis is sent every time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_emojis_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__emojis__update__t.html" title="Guild emojis update.">dpp::guild_emojis_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ab16da01a26f15814ed53eec781160dae" name="ab16da01a26f15814ed53eec781160dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16da01a26f15814ed53eec781160dae">&#9670;&nbsp;</a></span>on_guild_integrations_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__integrations__update__t.html">guild_integrations_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_integrations_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an integration is updated for a guild. This returns the complete list. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_integrations_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__integrations__update__t.html" title="Guild integrations update.">dpp::guild_integrations_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a8a9a12c6bd98bdce99024a9608aa84af" name="a8a9a12c6bd98bdce99024a9608aa84af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9a12c6bd98bdce99024a9608aa84af">&#9670;&nbsp;</a></span>on_guild_join_request_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__join__request__delete__t.html">guild_join_request_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_join_request_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on guild join request delete. Triggered when a user declines the membership screening questionnaire for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_join_request_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__join__request__delete__t.html" title="Guild join request delete (user declined membership screening)">dpp::guild_join_request_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="abb82d67aef151ddd17ba6857ca285034" name="abb82d67aef151ddd17ba6857ca285034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb82d67aef151ddd17ba6857ca285034">&#9670;&nbsp;</a></span>on_guild_member_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__member__add__t.html">guild_member_add_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_member_add</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new member joins a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_member_add</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__member__add__t.html" title="Guild member add.">dpp::guild_member_add_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="adcb35033028cfd0fd2642fd3dfc8ef02" name="adcb35033028cfd0fd2642fd3dfc8ef02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb35033028cfd0fd2642fd3dfc8ef02">&#9670;&nbsp;</a></span>on_guild_member_remove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__member__remove__t.html">guild_member_remove_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_member_remove</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user leaves a guild (either through being kicked, or choosing to leave) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_member_remove</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__member__remove__t.html" title="Guild member remove.">dpp::guild_member_remove_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ac25cc6467ceb4a55903895a3aa93eaff" name="ac25cc6467ceb4a55903895a3aa93eaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25cc6467ceb4a55903895a3aa93eaff">&#9670;&nbsp;</a></span>on_guild_member_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__member__update__t.html">guild_member_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_member_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when details of a guild member (e.g. their roles or nickname) are updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_member_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__member__update__t.html" title="Guild member update.">dpp::guild_member_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0069b8aa4da038722a777c095962bec9" name="a0069b8aa4da038722a777c095962bec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0069b8aa4da038722a777c095962bec9">&#9670;&nbsp;</a></span>on_guild_members_chunk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__members__chunk__t.html">guild_members_chunk_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_members_chunk</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a set of members is received for a guild. D++ will request these for all new guilds if needed, after the on_guild_create events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_members_chunk</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__members__chunk__t.html" title="Guild members chunk.">dpp::guild_members_chunk_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0b30c2f556abc539494438e7d5c1b4ae" name="a0b30c2f556abc539494438e7d5c1b4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b30c2f556abc539494438e7d5c1b4ae">&#9670;&nbsp;</a></span>on_guild_role_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__role__create__t.html">guild_role_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_role_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new role is created on a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_role_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__role__create__t.html" title="Guild role create.">dpp::guild_role_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a6713bfe6c0df810f89ce73124e036790" name="a6713bfe6c0df810f89ce73124e036790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6713bfe6c0df810f89ce73124e036790">&#9670;&nbsp;</a></span>on_guild_role_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__role__delete__t.html">guild_role_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_role_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a role is deleted in a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_role_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__role__delete__t.html" title="Guild role delete.">dpp::guild_role_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a2613d1afaef70b34dc15d1bbba91ae44" name="a2613d1afaef70b34dc15d1bbba91ae44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2613d1afaef70b34dc15d1bbba91ae44">&#9670;&nbsp;</a></span>on_guild_role_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__role__update__t.html">guild_role_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_role_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an existing role is updated on a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_role_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__role__update__t.html" title="Guild role update.">dpp::guild_role_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0c70bcd16af9713f726a09380ef11b79" name="a0c70bcd16af9713f726a09380ef11b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c70bcd16af9713f726a09380ef11b79">&#9670;&nbsp;</a></span>on_guild_scheduled_event_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__scheduled__event__create__t.html">guild_scheduled_event_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_scheduled_event_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new scheduled event is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__scheduled__event__create__t.html" title="Create scheduled event.">dpp::guild_scheduled_event_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a8b9908ea41c859c6e73274694dc5fbe4" name="a8b9908ea41c859c6e73274694dc5fbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9908ea41c859c6e73274694dc5fbe4">&#9670;&nbsp;</a></span>on_guild_scheduled_event_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__scheduled__event__delete__t.html">guild_scheduled_event_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_scheduled_event_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new scheduled event is deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__scheduled__event__delete__t.html" title="Delete scheduled event.">dpp::guild_scheduled_event_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a092db2b006613f2cc6fdeb5c44678fdd" name="a092db2b006613f2cc6fdeb5c44678fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092db2b006613f2cc6fdeb5c44678fdd">&#9670;&nbsp;</a></span>on_guild_scheduled_event_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__scheduled__event__update__t.html">guild_scheduled_event_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_scheduled_event_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new scheduled event is updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__scheduled__event__update__t.html" title="Create scheduled event.">dpp::guild_scheduled_event_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0ac0a7f419e8112c673cdac0bcd225fb" name="a0ac0a7f419e8112c673cdac0bcd225fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac0a7f419e8112c673cdac0bcd225fb">&#9670;&nbsp;</a></span>on_guild_scheduled_event_user_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__scheduled__event__user__add__t.html">guild_scheduled_event_user_add_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_scheduled_event_user_add</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user is added to a scheduled event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_user_add</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__scheduled__event__user__add__t.html" title="Add user to scheduled event.">dpp::guild_scheduled_event_user_add_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a6609485238c84b358aac33d627f4f409" name="a6609485238c84b358aac33d627f4f409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6609485238c84b358aac33d627f4f409">&#9670;&nbsp;</a></span>on_guild_scheduled_event_user_remove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__scheduled__event__user__remove__t.html">guild_scheduled_event_user_remove_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_scheduled_event_user_remove</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user is removed to a scheduled event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_scheduled_event_user_remove</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__scheduled__event__user__remove__t.html" title="Delete user from scheduled event.">dpp::guild_scheduled_event_user_remove_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aee9047fdd33193acad1e8999217cb79b" name="aee9047fdd33193acad1e8999217cb79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9047fdd33193acad1e8999217cb79b">&#9670;&nbsp;</a></span>on_guild_stickers_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__stickers__update__t.html">guild_stickers_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_stickers_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new stickers are added to a guild. The complete set of stickers is sent every time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_stickers_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__stickers__update__t.html" title="Update guild stickers.">dpp::guild_stickers_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="adaeca29cbe20fe449914f5c77aaf2601" name="adaeca29cbe20fe449914f5c77aaf2601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaeca29cbe20fe449914f5c77aaf2601">&#9670;&nbsp;</a></span>on_guild_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1guild__update__t.html">guild_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_guild_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when details of a guild are updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_guild_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1guild__update__t.html" title="Guild update.">dpp::guild_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a07e6a647d42e6e57140ec67834e8a305" name="a07e6a647d42e6e57140ec67834e8a305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e6a647d42e6e57140ec67834e8a305">&#9670;&nbsp;</a></span>on_integration_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1integration__create__t.html">integration_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_integration_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new intgration is attached to a guild by a user. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_integration_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1integration__create__t.html" title="Integration create.">dpp::integration_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aefd820eae596bdafb6da900e4205182f" name="aefd820eae596bdafb6da900e4205182f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd820eae596bdafb6da900e4205182f">&#9670;&nbsp;</a></span>on_integration_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1integration__delete__t.html">integration_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_integration_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an integration is removed by a user. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_integration_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1integration__delete__t.html" title="Integration delete.">dpp::integration_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a24c1f2756c5d0d9634de77e5bf4f80bd" name="a24c1f2756c5d0d9634de77e5bf4f80bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c1f2756c5d0d9634de77e5bf4f80bd">&#9670;&nbsp;</a></span>on_integration_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1integration__update__t.html">integration_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_integration_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an integration is updated by a user. This returns details of just the single integration that has changed. An integration is a connection to a guild of a user's associated accounts, e.g. youtube or twitch, for automatic assignment of roles etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_integration_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1integration__update__t.html" title="Integration update.">dpp::integration_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a23aa1d8bcc90afe7aa265940763f5a65" name="a23aa1d8bcc90afe7aa265940763f5a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23aa1d8bcc90afe7aa265940763f5a65">&#9670;&nbsp;</a></span>on_interaction_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1interaction__create__t.html">interaction_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_interaction_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new interaction is created. Interactions are created by discord when commands you have registered are issued by a user. For an example of this in action please see <a class="el" href="slashcommands.html">Using Slash Commands and Interactions</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_interaction_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1interaction__create__t.html" title="Create interaction.">dpp::interaction_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a09bcbf92ec745bc2a282a32377d4854a" name="a09bcbf92ec745bc2a282a32377d4854a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bcbf92ec745bc2a282a32377d4854a">&#9670;&nbsp;</a></span>on_invite_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1invite__create__t.html">invite_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_invite_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new invite is created for a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_invite_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1invite__create__t.html" title="Invite create.">dpp::invite_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a5633fcd031f73fd6ab9e827fd33aa414" name="a5633fcd031f73fd6ab9e827fd33aa414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5633fcd031f73fd6ab9e827fd33aa414">&#9670;&nbsp;</a></span>on_invite_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1invite__delete__t.html">invite_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_invite_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an invite is deleted from a guild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_invite_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1invite__delete__t.html" title="Invite delete.">dpp::invite_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a8b68d30779754eaf7f9b74ecc156a372" name="a8b68d30779754eaf7f9b74ecc156a372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b68d30779754eaf7f9b74ecc156a372">&#9670;&nbsp;</a></span>on_log</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1log__t.html">log_t</a>&amp; event)&gt; &gt; dpp::cluster::on_log</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a log message is to be written to the log. You can attach any logging system here you wish, e.g. spdlog, or even just a simple use of std::cout or printf. If nothing attaches this log event, then the library will be silent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_log</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1log__t.html" title="Log messages.">dpp::log_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0acf1be98db275266dea3fc2d83be817" name="a0acf1be98db275266dea3fc2d83be817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acf1be98db275266dea3fc2d83be817">&#9670;&nbsp;</a></span>on_message_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1message__create__t.html">message_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_message_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new message arrives from discord. Note that D++ does not cache messages. If you want to cache these objects you should create something yourself within your bot. Caching of messages is not on the roadmap to be supported as it consumes excessive amounts of RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__create__t.html" title="Create message.">dpp::message_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a7fb3ebaf4cc6db89b398d197d17d9f03" name="a7fb3ebaf4cc6db89b398d197d17d9f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb3ebaf4cc6db89b398d197d17d9f03">&#9670;&nbsp;</a></span>on_message_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1message__delete__t.html">message_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_message_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a message is deleted. The message has already been deleted from Discord when you receive this event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__delete__t.html" title="Message Deleted.">dpp::message_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a7838ae8d979f4a449cec9aaaf267ccdc" name="a7838ae8d979f4a449cec9aaaf267ccdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7838ae8d979f4a449cec9aaaf267ccdc">&#9670;&nbsp;</a></span>on_message_delete_bulk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1message__delete__bulk__t.html">message_delete_bulk_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_message_delete_bulk</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when multiple messages are deleted from a channel or DM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_delete_bulk</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__delete__bulk__t.html" title="Message delete bulk.">dpp::message_delete_bulk_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="af049a65227f648286a9d2e49fcd91bc5" name="af049a65227f648286a9d2e49fcd91bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af049a65227f648286a9d2e49fcd91bc5">&#9670;&nbsp;</a></span>on_message_reaction_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1message__reaction__add__t.html">message_reaction_add_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_message_reaction_add</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new reaction is added to a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_add</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__reaction__add__t.html" title="Message reaction add.">dpp::message_reaction_add_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="abdf5b31fd3b0cecfae99439458aa23e7" name="abdf5b31fd3b0cecfae99439458aa23e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf5b31fd3b0cecfae99439458aa23e7">&#9670;&nbsp;</a></span>on_message_reaction_remove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1message__reaction__remove__t.html">message_reaction_remove_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_message_reaction_remove</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a single reaction is removed from a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_remove</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__reaction__remove__t.html" title="Message reaction remove.">dpp::message_reaction_remove_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ae6f58f47d0dab75191f412c563d8ee39" name="ae6f58f47d0dab75191f412c563d8ee39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f58f47d0dab75191f412c563d8ee39">&#9670;&nbsp;</a></span>on_message_reaction_remove_all</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1message__reaction__remove__all__t.html">message_reaction_remove_all_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_message_reaction_remove_all</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when all reactions are removed from a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_remove_all</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__reaction__remove__all__t.html" title="Message remove all reactions.">dpp::message_reaction_remove_all_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ab84df62d9facbde422bfac46b39efbd2" name="ab84df62d9facbde422bfac46b39efbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84df62d9facbde422bfac46b39efbd2">&#9670;&nbsp;</a></span>on_message_reaction_remove_emoji</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1message__reaction__remove__emoji__t.html">message_reaction_remove_emoji_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_message_reaction_remove_emoji</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when all reactions for a particular emoji are removed from a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_reaction_remove_emoji</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__reaction__remove__emoji__t.html" title="Message remove emoji.">dpp::message_reaction_remove_emoji_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a583d733f99b3ad2c6d547f32979ea516" name="a583d733f99b3ad2c6d547f32979ea516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583d733f99b3ad2c6d547f32979ea516">&#9670;&nbsp;</a></span>on_message_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1message__update__t.html">message_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_message_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a message is updated (edited). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_message_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1message__update__t.html" title="Message update.">dpp::message_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0d8a60045a8b5681d79625e5e1b4f927" name="a0d8a60045a8b5681d79625e5e1b4f927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8a60045a8b5681d79625e5e1b4f927">&#9670;&nbsp;</a></span>on_presence_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1presence__update__t.html">presence_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_presence_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user's presence is updated. To receive these you will need the GUILD_PRESENCES privileged intent. You will receive many of these, very often, and receiving them will significantly increase your bot's CPU usage. If you don't need them it is recommended to not ask for them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_presence_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1presence__update__t.html" title="Presence update.">dpp::presence_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ac5eca020e6b80f8ec68a1ecba86c43dc" name="ac5eca020e6b80f8ec68a1ecba86c43dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5eca020e6b80f8ec68a1ecba86c43dc">&#9670;&nbsp;</a></span>on_ready</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1ready__t.html">ready_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_ready</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a shard is connected and ready. A set of on_guild_create events will follow this event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ready</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1ready__t.html" title="Session ready.">dpp::ready_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a760583fe988bebe640a9a68b908c1a9d" name="a760583fe988bebe640a9a68b908c1a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760583fe988bebe640a9a68b908c1a9d">&#9670;&nbsp;</a></span>on_resumed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1resumed__t.html">resumed_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_resumed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a connection to a shard successfully resumes. A resumed session does not need to re-synchronise guilds, members, etc. This is generally non-fatal and informational only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_resumed</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1resumed__t.html" title="Session resumed.">dpp::resumed_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a8a6ea43ae09004d54e7fb91219abb116" name="a8a6ea43ae09004d54e7fb91219abb116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6ea43ae09004d54e7fb91219abb116">&#9670;&nbsp;</a></span>on_select_click</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1select__click__t.html">select_click_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_select_click</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a select menu is clicked attached to a message. Select menu clicks are triggered by discord when select menus are clicked which you have associated with a message using <a class="el" href="classdpp_1_1component.html" title="Represents the component object. A component is a clickable button or drop down list within a discord...">dpp::component</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_select_click</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1select__click__t.html" title="Click on select.">dpp::select_click_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="af568ad97be5c6a9f08ed4b68fa1dc738" name="af568ad97be5c6a9f08ed4b68fa1dc738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af568ad97be5c6a9f08ed4b68fa1dc738">&#9670;&nbsp;</a></span>on_stage_instance_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1stage__instance__create__t.html">stage_instance_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_stage_instance_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new stage instance is created on a stage channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_stage_instance_create</td><td>User function to attach to event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a17e25040c5693fe302cd6662394b533c" name="a17e25040c5693fe302cd6662394b533c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e25040c5693fe302cd6662394b533c">&#9670;&nbsp;</a></span>on_stage_instance_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1stage__instance__delete__t.html">stage_instance_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_stage_instance_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an existing stage instance is deleted from a stage channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_stage_instance_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1stage__instance__delete__t.html" title="Delete stage instance.">dpp::stage_instance_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a30ebe81fa8df2eb71a126f2f222da2b0" name="a30ebe81fa8df2eb71a126f2f222da2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ebe81fa8df2eb71a126f2f222da2b0">&#9670;&nbsp;</a></span>on_stage_instance_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1stage__instance__update__t.html">stage_instance_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_stage_instance_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a stage instance is updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_stage_instance_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1stage__instance__update__t.html" title="Update stage instance.">dpp::stage_instance_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a0e40ca5a868de5ee11f24a6c4d6e4a6b" name="a0e40ca5a868de5ee11f24a6c4d6e4a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e40ca5a868de5ee11f24a6c4d6e4a6b">&#9670;&nbsp;</a></span>on_thread_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1thread__create__t.html">thread_create_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_thread_create</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a thread is created Note: Threads are not cached by D++, but a list of thread IDs is accessible in a guild object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_create</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__create__t.html" title="Thread Create.">dpp::thread_create_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a6ecde12ab525690cc394208c6682be99" name="a6ecde12ab525690cc394208c6682be99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ecde12ab525690cc394208c6682be99">&#9670;&nbsp;</a></span>on_thread_delete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1thread__delete__t.html">thread_delete_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_thread_delete</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a thread is deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_delete</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__delete__t.html" title="Thread Delete.">dpp::thread_delete_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad849df31420d38c61a8612a7760c5834" name="ad849df31420d38c61a8612a7760c5834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad849df31420d38c61a8612a7760c5834">&#9670;&nbsp;</a></span>on_thread_list_sync</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1thread__list__sync__t.html">thread_list_sync_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_thread_list_sync</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when thread list is synced (upon gaining access to a channel) Note: Threads are not cached by D++, but a list of thread IDs is accessible in a guild object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_list_sync</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__list__sync__t.html" title="Thread List Sync.">dpp::thread_list_sync_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="afdcac1f0134cb08bdaebad831fa483fd" name="afdcac1f0134cb08bdaebad831fa483fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcac1f0134cb08bdaebad831fa483fd">&#9670;&nbsp;</a></span>on_thread_member_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1thread__member__update__t.html">thread_member_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_thread_member_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when current user's thread member object is updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_member_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__member__update__t.html" title="Thread Member Update.">dpp::thread_member_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ac63f0cdfcce6519c2d7748fb05475c81" name="ac63f0cdfcce6519c2d7748fb05475c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63f0cdfcce6519c2d7748fb05475c81">&#9670;&nbsp;</a></span>on_thread_members_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1thread__members__update__t.html">thread_members_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_thread_members_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a thread's member list is updated (without GUILD_MEMBERS intent, is only called for current user) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_members_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__members__update__t.html" title="Thread Members Update.">dpp::thread_members_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aa5cd9a0973faef7e6b60a69225afeaa0" name="aa5cd9a0973faef7e6b60a69225afeaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cd9a0973faef7e6b60a69225afeaa0">&#9670;&nbsp;</a></span>on_thread_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1thread__update__t.html">thread_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_thread_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a thread is updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1thread__update__t.html" title="Thread Update.">dpp::thread_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad9afbcedb627dfa0830b783594a66490" name="ad9afbcedb627dfa0830b783594a66490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9afbcedb627dfa0830b783594a66490">&#9670;&nbsp;</a></span>on_typing_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1typing__start__t.html">typing_start_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_typing_start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user is typing on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_typing_start</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1typing__start__t.html" title="Typing start.">dpp::typing_start_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aba195e369b6280d8cdf978644896673d" name="aba195e369b6280d8cdf978644896673d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba195e369b6280d8cdf978644896673d">&#9670;&nbsp;</a></span>on_user_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1user__update__t.html">user_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_user_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user is updated. This is separate to guild_member_update and includes things such as an avatar change, username change, discriminator change or change in subscription status for nitro. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_user_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1user__update__t.html" title="User update.">dpp::user_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a5b58460acf026a8a30cf589d4961c04e" name="a5b58460acf026a8a30cf589d4961c04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b58460acf026a8a30cf589d4961c04e">&#9670;&nbsp;</a></span>on_voice_buffer_send</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1voice__buffer__send__t.html">voice_buffer_send_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_voice_buffer_send</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when packets are sent from the voice buffer. The voice buffer contains packets that are already encoded with Opus and encrypted with Sodium, and merged into packets by the repacketizer, which is done in the dpp::discord_voice_client::send_audio method. You should use the buffer size properties of <a class="el" href="structdpp_1_1voice__buffer__send__t.html" title="voice buffer send">dpp::voice_buffer_send_t</a> to determine if you should fill the buffer with more content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_buffer_send</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__buffer__send__t.html" title="voice buffer send">dpp::voice_buffer_send_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="aef4005f102e1ff9413feee1ba6876832" name="aef4005f102e1ff9413feee1ba6876832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4005f102e1ff9413feee1ba6876832">&#9670;&nbsp;</a></span>on_voice_client_disconnect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1voice__client__disconnect__t.html">voice_client_disconnect_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_voice_client_disconnect</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on voice client disconnect event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_client_disconnect</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__client__disconnect__t.html" title="voice client disconnect event">dpp::voice_client_disconnect_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="af298505ed4ad0c50a61bff08d81851af" name="af298505ed4ad0c50a61bff08d81851af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af298505ed4ad0c50a61bff08d81851af">&#9670;&nbsp;</a></span>on_voice_client_speaking</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1voice__client__speaking__t.html">voice_client_speaking_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_voice_client_speaking</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on voice client speaking event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_client_speaking</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__client__speaking__t.html" title="voice client speaking event">dpp::voice_client_speaking_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ac9dd03ef61b20d398dd64f0c091b6cf8" name="ac9dd03ef61b20d398dd64f0c091b6cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dd03ef61b20d398dd64f0c091b6cf8">&#9670;&nbsp;</a></span>on_voice_ready</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1voice__ready__t.html">voice_ready_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_voice_ready</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a voice channel is connected and ready to send audio. Note that this is not directly attached to the READY event of the websocket, as there is further connection that needs to be done before audio is ready to send. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_ready</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__ready__t.html" title="voice user talking">dpp::voice_ready_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad17ccb505a153dcfd4ae2ab22f0df37e" name="ad17ccb505a153dcfd4ae2ab22f0df37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17ccb505a153dcfd4ae2ab22f0df37e">&#9670;&nbsp;</a></span>on_voice_receive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1voice__receive__t.html">voice_receive_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_voice_receive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new audio data is received. Each separate user's audio from the voice channel will arrive tagged with their user id in the event, if a user can be attributed to the received audio. </p>
<dl class="section note"><dt>Note</dt><dd>Receiveing audio for bots is not officially supported by discord.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_receive</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__receive__t.html" title="voice receive packet">dpp::voice_receive_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a224e4628b25e9b0f29444793c8dd5335" name="a224e4628b25e9b0f29444793c8dd5335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224e4628b25e9b0f29444793c8dd5335">&#9670;&nbsp;</a></span>on_voice_server_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1voice__server__update__t.html">voice_server_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_voice_server_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when we are told which voice server we can use. This will be sent either when we establish a new voice channel connection, or as discord rearrange their infrastructure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_server_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__server__update__t.html" title="Voice server update.">dpp::voice_server_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="ad0f83901e4107e8b4e806fdbd7ed1251" name="ad0f83901e4107e8b4e806fdbd7ed1251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f83901e4107e8b4e806fdbd7ed1251">&#9670;&nbsp;</a></span>on_voice_state_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1voice__state__update__t.html">voice_state_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_voice_state_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>on voice state update event </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_state_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__state__update__t.html" title="Voice state update.">dpp::voice_state_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a8e80d5055faabfe85259b393734ecae1" name="a8e80d5055faabfe85259b393734ecae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e80d5055faabfe85259b393734ecae1">&#9670;&nbsp;</a></span>on_voice_track_marker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1voice__track__marker__t.html">voice_track_marker_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_voice_track_marker</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when sending of audio passes over a track marker. Track markers are arbitrarily placed "bookmarks" in the audio buffer, placed by the bot developer. Each track marker can have a string value associated with it which is specified in <a class="el" href="classdpp_1_1discord__voice__client.html#a84fc0cb1aaf9691aed818e18daea1b84" title="Insert a track marker into the audio output buffer. A track marker is an arbitrary flag in the buffer...">dpp::discord_voice_client::insert_marker</a> and returned to this event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_track_marker</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__track__marker__t.html" title="Voice state update.">dpp::voice_track_marker_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a5a7100923971433c0de42321f530a639" name="a5a7100923971433c0de42321f530a639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7100923971433c0de42321f530a639">&#9670;&nbsp;</a></span>on_voice_user_talking</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1voice__user__talking__t.html">voice_user_talking_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_voice_user_talking</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a user is talking on a voice channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_voice_user_talking</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1voice__user__talking__t.html" title="voice user talking">dpp::voice_user_talking_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="af5a1f90bab8183454fb6f228dda8dc51" name="af5a1f90bab8183454fb6f228dda8dc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a1f90bab8183454fb6f228dda8dc51">&#9670;&nbsp;</a></span>on_webhooks_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdpp_1_1event__router__t.html">event_router_t</a>&lt; std::function&lt;void(const <a class="el" href="structdpp_1_1webhooks__update__t.html">webhooks_update_t</a>&amp; _event)&gt; &gt; dpp::cluster::on_webhooks_update</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when the webhooks for a guild are updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_webhooks_update</td><td>User function to attach to event Event is called with the parameter type <code>const</code> <a class="el" href="structdpp_1_1webhooks__update__t.html" title="Webhooks update.">dpp::webhooks_update_t</a>&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event_handle An opaque handle to the attached event, which can be used to refer to it later if needed </dd></dl>

</div>
</div>
<a id="a6161f8d412b2e81a06594f727684a260" name="a6161f8d412b2e81a06594f727684a260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6161f8d412b2e81a06594f727684a260">&#9670;&nbsp;</a></span>rest_ping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double dpp::cluster::rest_ping</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >REST latency (HTTPS ping) </p>

</div>
</div>
<a id="a644b186bc4b386a8313e3c5dce456c4e" name="a644b186bc4b386a8313e3c5dce456c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644b186bc4b386a8313e3c5dce456c4e">&#9670;&nbsp;</a></span>token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dpp::cluster::token</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Current bot token for all shards on this cluster and all commands sent via HTTP </p>

</div>
</div>
<a id="ae10466db79966215a799fc2a30010551" name="ae10466db79966215a799fc2a30010551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10466db79966215a799fc2a30010551">&#9670;&nbsp;</a></span>ws_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedpp.html#af7cde3079d745428f44ef6231a2ac672">websocket_protocol_t</a> dpp::cluster::ws_mode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Websocket mode for all shards in the cluster, either ws_json or ws_etf. Production bots should use ETF, while development bots should use JSON. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedpp.html">dpp</a></li><li class="navelem"><a class="el" href="classdpp_1_1cluster.html">cluster</a></li>
  </ul>
</div>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-QTH6YHBNG5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
        gtag('config', 'G-QTH6YHBNG5');
</script>
<div style="z-index: -9999; position: absolute; right: 0; top: 0; font-size: 0.0001rem;color:transparent;background:none">
	<!-- For crawlability of past versions -->
	<a href='/9.0.13/'>D++ Library version 9.0.13</a><a href='/9.0.12/'>D++ Library version 9.0.12</a><a href='/9.0.11/'>D++ Library version 9.0.11</a><a href='/9.0.10/'>D++ Library version 9.0.10</a><a href='/9.0.9/'>D++ Library version 9.0.9</a><a href='/9.0.8/'>D++ Library version 9.0.8</a><a href='/9.0.7/'>D++ Library version 9.0.7</a><a href='/9.0.6/'>D++ Library version 9.0.6</a><a href='/9.0.5/'>D++ Library version 9.0.5</a><a href='/9.0.4/'>D++ Library version 9.0.4</a><a href='/9.0.3/'>D++ Library version 9.0.3</a><a href='/9.0.2/'>D++ Library version 9.0.2</a><a href='/9.0.1/'>D++ Library version 9.0.1</a><a href='/9.0.0/'>D++ Library version 9.0.0</a><a href='/1.0.2/'>D++ Library version 1.0.2</a><a href='/1.0.1/'>D++ Library version 1.0.1</a><a href='/1.0.0/'>D++ Library version 1.0.0</a>
</div>
</body>
</html>
